{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\node_modules\\buffer\\index.js","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\node_modules\\webpack\\buildin\\global.js","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\delimiterMark.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\delimiterSearcher.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\scopeData.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\tag.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\tagParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\templateCompiler.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\delimiters.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\malformedFileError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\maxXmlDepthError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingArgumentError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingCloseDelimiterError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingStartDelimiterError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unclosedTagError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unidentifiedFileTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unknownContentTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unopenedTagError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unsupportedFileTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\mimeType.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\contentTypesFile.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\docx.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\docxParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\mediaFiles.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\rels.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\defaultPlugins.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\imagePlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopListStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopParagraphStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopTableStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loopPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\pluginContent.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\rawXmlPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\templatePlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\textPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\templateHandler.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\templateHandlerOptions.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\array.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\base64.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\binary.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\path.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\sha1.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\types.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlNode.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\jsZipHelper.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\zip.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\zipObject.ts","external \"base64-js\"","external \"ieee754\"","external \"isarray\"","external \"jszip\"","external \"lodash.get\"","external \"xmldom\""],"names":["DelimiterMark","constructor","initial","Object","assign","DelimiterSearcher","findDelimiters","node","delimiters","findRecurse","depth","maxXmlDepth","MaxXmlDepthError","XmlNode","isTextNode","curTokens","findInNode","length","childNodesLength","childNodes","i","child","textContent","delimiterMarks","startDelimiter","push","index","isOpen","xmlTextNode","endDelimiter","getProp","require","ScopeData","data","allData","getScopeData","lastKey","path","result","curPath","slice","undefined","curScopePath","concat","TagDisposition","TagParser","docParser","MissingArgumentError","tagRegex","RegExp","tagStart","tagEnd","parse","tags","openedTag","openedDelimiter","lastNormalizedNode","lastInflictedOffset","delimiter","closeTagText","MissingStartDelimiterError","openTagText","MissingCloseDelimiterError","normalizeTagNodes","processTag","openDelimiter","closeDelimiter","inflictedOffset","startTextNode","endTextNode","sameNode","splitTextNode","joinTextNodesRange","tag","rawText","tagParts","exec","tagContent","trim","disposition","SelfClosed","containerTagOpen","Open","name","containerTagClose","Close","TemplateCompiler","delimiterSearcher","tagParser","plugins","defaultContentType","containerContentType","pluginsLookup","p","contentType","compile","context","parseTags","doTagReplacements","tagIndex","detectContentType","plugin","UnknownContentTypeError","join","job","simpleTagReplacements","closingTagIndex","findCloseTagIndex","scopeTags","containerTagReplacements","pop","scopeData","PluginContent","isPluginContent","_type","fromIndex","openTag","closeTag","UnclosedTagError","Delimiters","encodeAndValidate","Error","keys","key","value","encodeValue","MalformedFileError","expectedFileType","setPrototypeOf","prototype","maxDepth","argName","openDelimiterText","closeDelimiterText","tagName","UnidentifiedFileTypeError","tagRawText","UnopenedTagError","UnsupportedFileTypeError","fileType","MimeType","MimeTypeHelper","getDefaultExtension","mime","Png","Jpeg","Gif","Bmp","Svg","getOfficeRelType","ContentTypesFile","zip","xmlParser","ensureContentType","parseContentTypesFile","contentTypes","extension","typeNode","createGeneralNode","attributes","root","addedNew","count","filter","save","xmlContent","serialize","setFile","contentTypesFilePath","contentTypesXml","getFile","getContentText","nodeName","genNode","contentTypeAttribute","find","attr","Docx","documentPath","_documentPath","isFileExist","rels","Rels","mediaFiles","MediaFiles","getDocument","_document","xml","getDocumentText","xmlDocument","domDocument","domParse","documentElement","addMedia","content","type","mediaFilePath","add","relId","export","outputType","saveChanges","document","DocxParser","load","textNode","splitIndex","addBefore","firstXmlTextNode","secondXmlTextNode","wordTextNode","containingTextNode","newWordTextNode","cloneNode","insertBefore","lastTextChild","curIndex","parentNode","indexOf","insertChild","firstText","secondText","substring","from","to","firstRunNode","containingRunNode","secondRunNode","paragraphNode","firstWordTextNode","secondWordTextNode","totalText","curRunNode","curWordTextNode","firstTextNodeChild","TEXT_NODE","curXmlTextNode","textToRemove","nextSibling","remove","runToRemove","joinParagraphs","first","second","childIndex","curChild","RUN_NODE","removeChild","appendChild","isTableCellNode","TABLE_CELL_NODE","isParagraphNode","PARAGRAPH_NODE","isListParagraph","paragraphProperties","paragraphPropertiesNode","listNumberProperties","findChildByName","NUMBER_PROPERTIES_NODE","PARAGRAPH_PROPERTIES_NODE","findParentByName","containingParagraphNode","containingTableRowNode","TABLE_ROW_NODE","Map","mediaFile","files","has","get","hashMediaFiles","base64","Binary","toBase64","hash","hashes","nextFileId","mediaDir","set","listFiles","startsWith","filename","Path","getFilename","fileData","getContentBase64","fileHash","partPath","partDir","getDirectory","partFilename","relsFilePath","relTarget","substr","parseRelsFile","relTargetKey","getRelTargetKey","relTargets","getNextRelId","relType","relNode","relIds","nextRelId","relsXml","relsFile","rel","idAttr","toLowerCase","typeAttr","targetAttr","target","createDefaultPlugins","LoopPlugin","RawXmlPlugin","ImagePlugin","TextPlugin","nextImageId","TemplatePlugin","utilities","docxParser","source","imageId","docx","format","imageXml","createMarkup","width","height","insertAfter","markupText","pixelsToEmu","pictureMarkup","markupXml","stripTextNodes","pixels","Math","round","LoopListStrategy","setUtilities","isApplicable","containingParagraph","splitBefore","firstParagraph","lastParagraph","paragraphsToRepeat","siblingsInRange","firstNode","nodesToRepeat","lastNode","mergeBack","paragraphGroups","lastParagraphs","curParagraphsGroup","paragraph","LoopParagraphStrategy","areSame","parent","firstParagraphIndex","lastParagraphIndex","splitResult","splitByChild","firstParagraphSplit","lastParagraphSplit","middleParagraphs","inBetween","removeSiblings","mergeTo","LoopTableStrategy","firstRow","lastRow","rowsToRepeat","rowGroups","curRowsGroup","row","LOOP_CONTENT_TYPE","loopStrategies","forEach","strategy","Array","isArray","loopStrategy","repeatedNodes","repeat","compiledNodes","nodes","times","allResults","curResult","map","nodeGroups","compiledNodeGroups","curNodes","dummyRootNode","compiler","newNode","TEXT_CONTENT_TYPE","stringValue","toString","lines","split","replaceSingleLine","replaceMultiLine","text","getSpacePreserveAttribute","runNode","lineBreak","getLineBreak","lineNode","createWordTextNode","createTextNode","TemplateHandler","options","XmlParser","TemplateHandlerOptions","process","templateFile","loadDocx","getText","docxFile","getXml","file","Zip","pushMany","destArray","items","apply","last","array","toDictionary","keySelector","valueSelector","res","item","Base64","encode","str","btoa","Buffer","isBlob","binary","isBlobConstructor","isArrayBuffer","isArrayBufferConstructor","isBuffer","isBufferConstructor","binaryType","Blob","ArrayBuffer","Promise","resolve","fileReader","FileReader","onload","readAsBinaryString","binaryStr","Uint8Array","reduce","byte","String","fromCharCode","lastSlashIndex","lastIndexOf","sha1","msg","utf8Encode","msgLength","j","wordArray","charCodeAt","w","H0","H1","H2","H3","H4","A","B","C","D","E","temp","blockStart","rotateLeft","cvtHex","n","s","t4","val","v","replace","utfStr","c","inheritsFrom","derived","base","isPromiseLike","candidate","then","XmlNodeType","TEXT_NODE_NAME","nodeType","Text","General","TypeError","hasChildren","suffix","childrenXml","fromDomNode","domNode","xmlNode","ELEMENT_NODE","curAttribute","prevChild","domChild","deep","clone","cloneNodeDeep","referenceNode","beforeNodeIndex","referenceNodeIndex","RangeError","childAfter","childBefore","splice","currentLastChild","allTextNodes","lastTextNode","newTextNode","removed","lastRemoved","removeMe","markerNode","removeMarkerNode","getDescendantPath","findParent","predicate","childName","range","curNode","recursiveStripTextNodes","childOrIndex","beforeChild","original","prevChildClone","childClone","descendant","curChildIndex","reverse","oldChildren","strippedChild","doc","parser","parseFromString","xmlHeader","xmldom","DOMParser","JsZipHelper","toJsZipOutputType","binaryOrType","JSZip","loadAsync","ZipObject","zipOutputType","output","generateAsync","compression","compressionOptions","level","zipObject","isDirectory","dir","async","getContentBinary"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,4BAAW;AAChC,cAAc,mBAAO,CAAC,wBAAS;AAC/B,cAAc,mBAAO,CAAC,wBAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;AC5vDA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;;;;;;;;;ACjBO,MAAMA,aAAN,CAAoB;AAGvB;;;;AAIA;;;AAKAC,aAAW,CAACC,OAAD,EAAmC;AAAA;;AAAA;;AAAA;;AAC1CC,UAAM,CAACC,MAAP,CAAc,IAAd,EAAoBF,OAApB;AACH;;AAdsB;;;;;;;;;;;;;;;;;;;;;;ACF3B;;AACA;;AACA;;;;AAGO,MAAMG,iBAAN,CAAwB;AAAA;AAAA,yCAEN,EAFM;;AAAA,4CAGH,GAHG;;AAAA,0CAIL,GAJK;A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","file":"easy-template-x.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"easy-template-x\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"easy-template-x\"] = factory();\n\telse\n\t\troot[\"easy-template-x\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { XmlTextNode } from \"../xml\";\r\n\r\nexport class DelimiterMark {\r\n\r\n    public xmlTextNode: XmlTextNode;\r\n    /**\r\n     * Index inside the text node\r\n     */\r\n    public index: number;\r\n    /**\r\n     * Is this an open delimiter or a close delimiter\r\n     */\r\n    public isOpen: boolean;\r\n\r\n    constructor(initial?: Partial<DelimiterMark>) {\r\n        Object.assign(this, initial);\r\n    }\r\n}","import { MaxXmlDepthError } from '../errors';\r\nimport { pushMany } from '../utils';\r\nimport { XmlNode, XmlTextNode } from '../xml';\r\nimport { DelimiterMark } from './delimiterMark';\r\n\r\nexport class DelimiterSearcher {\r\n\r\n    public maxXmlDepth = 20;\r\n    public startDelimiter = \"{\";\r\n    public endDelimiter = \"}\";\r\n\r\n    public findDelimiters(node: XmlNode): DelimiterMark[] {\r\n        const delimiters: DelimiterMark[] = [];\r\n        this.findRecurse(node, delimiters, 0);\r\n        return delimiters;\r\n    }\r\n\r\n    private findRecurse(node: XmlNode, delimiters: DelimiterMark[], depth: number): void {\r\n        if (depth > this.maxXmlDepth)\r\n            throw new MaxXmlDepthError(this.maxXmlDepth);\r\n\r\n        if (!node)\r\n            return;\r\n\r\n        // process self\r\n        if (XmlNode.isTextNode(node)) {\r\n\r\n            const curTokens = this.findInNode(node);\r\n            if (curTokens.length) {\r\n                pushMany(delimiters, curTokens);\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        // process child nodes\r\n        const childNodesLength = (node.childNodes ? node.childNodes.length : 0);\r\n        for (let i = 0; i < childNodesLength; i++) {\r\n            const child = node.childNodes[i];\r\n            this.findRecurse(child, delimiters, depth + 1);\r\n        }\r\n    }\r\n\r\n    private findInNode(node: XmlTextNode): DelimiterMark[] {\r\n\r\n        if (!node.textContent) {\r\n            return [];\r\n        }\r\n\r\n        // TODO: support delimiters longer than one character\r\n        \r\n        const delimiterMarks: DelimiterMark[] = [];\r\n        for (let i = 0; i < node.textContent.length; i++) {\r\n            if (node.textContent[i] === this.startDelimiter) {\r\n                delimiterMarks.push({\r\n                    index: i,\r\n                    isOpen: true,\r\n                    xmlTextNode: node\r\n                });\r\n            } else if (node.textContent[i] === this.endDelimiter) {\r\n                delimiterMarks.push({\r\n                    index: i,\r\n                    isOpen: false,\r\n                    xmlTextNode: node\r\n                });\r\n            }\r\n        }\r\n\r\n        return delimiterMarks;\r\n    }\r\n}","export * from './delimiterMark';\r\nexport * from './delimiterSearcher';\r\nexport * from './scopeData';\r\nexport * from './tag';\r\nexport * from './tagParser';\r\nexport * from './templateCompiler';\r\nexport * from './templateContext';\r\n","import { TemplateContent, TemplateData } from '../templateData';\r\nimport { last } from '../utils';\r\n\r\nconst getProp = require('lodash.get');\r\n\r\nexport class ScopeData {\r\n    \r\n    public readonly path: (string | number)[] = [];\r\n    public readonly allData: TemplateData;\r\n\r\n    constructor(data: TemplateData) {\r\n        this.allData = data;\r\n    }\r\n\r\n    public getScopeData(): TemplateContent | TemplateData[] {\r\n\r\n        const lastKey = last(this.path);\r\n\r\n        let result: any;\r\n        let curPath = this.path.slice();\r\n\r\n        while (result === undefined && curPath.length) {\r\n            const curScopePath = curPath.slice(0, curPath.length - 1);\r\n            result = getProp(this.allData, curScopePath.concat(lastKey));\r\n            curPath = curScopePath;\r\n        }\r\n        return result;\r\n    }\r\n}","import { XmlTextNode } from '../xml';\r\n\r\nexport enum TagDisposition {\r\n    Open = \"Open\",\r\n    Close = \"Close\",\r\n    SelfClosed = \"SelfClosed\"\r\n}\r\n\r\nexport interface Tag {    \r\n    name: string;\r\n    /**\r\n     * The full tag text, for instance: \"{#my-tag}\".\r\n     */\r\n    rawText: string;\r\n    disposition: TagDisposition;\r\n    xmlTextNode: XmlTextNode;\r\n}","import { Delimiters } from '../delimiters';\r\nimport { MissingArgumentError, MissingCloseDelimiterError, MissingStartDelimiterError } from '../errors';\r\nimport { DocxParser } from '../office';\r\nimport { XmlTextNode } from '../xml';\r\nimport { DelimiterMark } from './delimiterMark';\r\nimport { Tag, TagDisposition } from './tag';\r\n\r\nexport class TagParser {\r\n\r\n    private readonly tagRegex: RegExp;\r\n\r\n    constructor(\r\n        private readonly docParser: DocxParser,\r\n        private readonly delimiters: Delimiters\r\n    ) {\r\n        if (!docParser)\r\n            throw new MissingArgumentError(nameof(docParser));\r\n        if (!delimiters)\r\n            throw new MissingArgumentError(nameof(delimiters));\r\n\r\n        this.tagRegex = new RegExp(`^[${delimiters.tagStart}](.*?)[${delimiters.tagEnd}]`, 'mi');\r\n    }\r\n\r\n    public parse(delimiters: DelimiterMark[]): Tag[] {\r\n        const tags: Tag[] = [];\r\n\r\n        let openedTag: Partial<Tag>;\r\n        let openedDelimiter: DelimiterMark;\r\n        let lastNormalizedNode: XmlTextNode;\r\n        let lastInflictedOffset: number;\r\n        for (const delimiter of delimiters) {\r\n\r\n            // close before open\r\n            if (!openedTag && !delimiter.isOpen) {\r\n                const closeTagText = delimiter.xmlTextNode.textContent;\r\n                throw new MissingStartDelimiterError(closeTagText);\r\n            }\r\n\r\n            // open before close\r\n            if (openedTag && delimiter.isOpen) {\r\n                const openTagText = openedDelimiter.xmlTextNode.textContent;\r\n                throw new MissingCloseDelimiterError(openTagText);\r\n            }\r\n\r\n            // valid open\r\n            if (!openedTag && delimiter.isOpen) {\r\n                openedTag = {};\r\n                openedDelimiter = delimiter;\r\n            }\r\n\r\n            // valid close\r\n            if (openedTag && !delimiter.isOpen) {\r\n\r\n                // normalize the underlying xml structure\r\n                // (make sure the tag's node only includes the tag's text)\r\n                if (lastNormalizedNode === openedDelimiter.xmlTextNode) {\r\n                    openedDelimiter.index -= lastInflictedOffset;\r\n                }\r\n                if (lastNormalizedNode === delimiter.xmlTextNode) {\r\n                    delimiter.index -= lastInflictedOffset;\r\n                }\r\n                lastNormalizedNode = delimiter.xmlTextNode;\r\n                lastInflictedOffset = this.normalizeTagNodes(openedDelimiter, delimiter);\r\n                openedTag.xmlTextNode = openedDelimiter.xmlTextNode;\r\n\r\n                // extract tag info from tag's text\r\n                this.processTag(openedTag as Tag);\r\n                tags.push(openedTag as Tag);\r\n                openedTag = null;\r\n                openedDelimiter = null;\r\n            }\r\n        }\r\n\r\n        return tags;\r\n    }\r\n\r\n    /**\r\n     * Consolidate all tag's text into a single text node.\r\n     * \r\n     * Example: \r\n     * \r\n     * Input text node: \"some text {some tag} some more text\" \r\n     * Output text nodes: [ \"some text \", \"{some tag}\", \" some more text\" ]\r\n     */\r\n    private normalizeTagNodes(openDelimiter: DelimiterMark, closeDelimiter: DelimiterMark): number {\r\n\r\n        // we change the node's text and therefor needs to update following delimiters\r\n        let inflictedOffset = 0;\r\n\r\n        let startTextNode = openDelimiter.xmlTextNode;\r\n        let endTextNode = closeDelimiter.xmlTextNode;\r\n        const sameNode = (startTextNode === endTextNode);\r\n\r\n        // trim start\r\n        if (openDelimiter.index > 0) {\r\n            inflictedOffset += openDelimiter.index;\r\n            this.docParser.splitTextNode(startTextNode, openDelimiter.index, true);\r\n        }\r\n\r\n        // trim end\r\n        if (closeDelimiter.index < endTextNode.textContent.length - 1) {\r\n            inflictedOffset += closeDelimiter.index + 1;\r\n            endTextNode = this.docParser.splitTextNode(endTextNode, closeDelimiter.index + 1, true);\r\n            if (sameNode) {\r\n                startTextNode = endTextNode;\r\n            }\r\n        }\r\n\r\n        // join nodes\r\n        if (!sameNode) {\r\n            this.docParser.joinTextNodesRange(startTextNode, endTextNode);\r\n            endTextNode = startTextNode;\r\n        }\r\n\r\n        // update references\r\n        openDelimiter.xmlTextNode = startTextNode;\r\n        closeDelimiter.xmlTextNode = endTextNode;\r\n\r\n        // return the created offset\r\n        return inflictedOffset;\r\n    }\r\n\r\n    private processTag(tag: Tag): void {\r\n        tag.rawText = tag.xmlTextNode.textContent;\r\n\r\n        const tagParts = this.tagRegex.exec(tag.rawText);\r\n        const tagContent = (tagParts[1] || '').trim();\r\n        if (!tagContent || !tagContent.length) {\r\n            tag.disposition = TagDisposition.SelfClosed;\r\n            return;\r\n        }\r\n\r\n        if (tagContent[0] === this.delimiters.containerTagOpen) {\r\n            tag.disposition = TagDisposition.Open;\r\n            tag.name = tagContent.slice(1);\r\n\r\n        } else if (tagContent[0] === this.delimiters.containerTagClose) {\r\n            tag.disposition = TagDisposition.Close;\r\n            tag.name = tagContent.slice(1);\r\n\r\n        } else {\r\n            tag.disposition = TagDisposition.SelfClosed;\r\n            tag.name = tagContent;\r\n        }\r\n    }\r\n}","import { UnclosedTagError, UnknownContentTypeError } from '../errors';\r\nimport { PluginContent, TemplatePlugin } from '../plugins';\r\nimport { isPromiseLike, toDictionary } from '../utils';\r\nimport { XmlNode } from '../xml';\r\nimport { DelimiterSearcher } from './delimiterSearcher';\r\nimport { ScopeData } from './scopeData';\r\nimport { Tag, TagDisposition } from './tag';\r\nimport { TagParser } from './tagParser';\r\nimport { TemplateContext } from './templateContext';\r\n\r\n/**\r\n * The TemplateCompiler works roughly the same way as a source code compiler.\r\n * It's main steps are:\r\n * \r\n * 1. find delimiters (lexical analysis) :: (Document) => DelimiterMark[]\r\n * 2. extract tags (syntax analysis) :: (DelimiterMark[]) => Tag[]\r\n * 3. perform document replace (code generation) :: (Tag[], data) => Document*\r\n * \r\n * see: https://en.wikipedia.org/wiki/Compiler\r\n */\r\nexport class TemplateCompiler {\r\n\r\n    private readonly pluginsLookup: IMap<TemplatePlugin>;\r\n\r\n    constructor(\r\n        private readonly delimiterSearcher: DelimiterSearcher,\r\n        private readonly tagParser: TagParser,\r\n        plugins: TemplatePlugin[],\r\n        private readonly defaultContentType: string,\r\n        private readonly containerContentType: string\r\n    ) {\r\n        this.pluginsLookup = toDictionary(plugins, p => p.contentType);\r\n    }\r\n\r\n    /**\r\n     * Compiles the template and performs the required replacements using the\r\n     * specified data.\r\n     */\r\n    public async compile(node: XmlNode, data: ScopeData, context: TemplateContext): Promise<void> {\r\n        const tags = this.parseTags(node);\r\n        await this.doTagReplacements(tags, data, context);\r\n    }\r\n\r\n    public parseTags(node: XmlNode): Tag[] {\r\n        const delimiters = this.delimiterSearcher.findDelimiters(node);\r\n        const tags = this.tagParser.parse(delimiters);\r\n        return tags;\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private async doTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        for (let tagIndex = 0; tagIndex < tags.length; tagIndex++) {\r\n\r\n            const tag = tags[tagIndex];\r\n            data.path.push(tag.name);\r\n            const contentType = this.detectContentType(tag, data);\r\n            const plugin = this.pluginsLookup[contentType];\r\n            if (!plugin) {\r\n                throw new UnknownContentTypeError(\r\n                    contentType,\r\n                    tag.rawText,\r\n                    data.path.join('.')\r\n                );\r\n            }\r\n\r\n            if (tag.disposition === TagDisposition.SelfClosed) {\r\n\r\n                // replace simple tag                \r\n                const job = plugin.simpleTagReplacements(tag, data, context);\r\n                if (isPromiseLike(job)) {\r\n                    await job;\r\n                }\r\n\r\n            } else if (tag.disposition === TagDisposition.Open) {\r\n\r\n                // get all tags between the open and close tags\r\n                const closingTagIndex = this.findCloseTagIndex(tagIndex, tag, tags);\r\n                const scopeTags = tags.slice(tagIndex, closingTagIndex + 1);\r\n                tagIndex = closingTagIndex;\r\n\r\n                // replace container tag\r\n                const job = plugin.containerTagReplacements(scopeTags, data, context);\r\n                if (isPromiseLike(job)) {\r\n                    await job;\r\n                }\r\n            }\r\n\r\n            data.path.pop();\r\n        }\r\n    }\r\n\r\n    private detectContentType(tag: Tag, data: ScopeData): string {\r\n\r\n        if (tag.disposition === TagDisposition.Open || tag.disposition === TagDisposition.Close)\r\n            return this.containerContentType;\r\n\r\n        const scopeData = data.getScopeData();\r\n        if (PluginContent.isPluginContent(scopeData))\r\n            return scopeData._type;\r\n\r\n        return this.defaultContentType;\r\n    }\r\n\r\n    private findCloseTagIndex(fromIndex: number, openTag: Tag, tags: Tag[]): number {\r\n\r\n        let i = fromIndex;\r\n        for (; i < tags.length; i++) {\r\n            const closeTag = tags[i];\r\n            if (\r\n                closeTag.name === openTag.name &&\r\n                closeTag.disposition === TagDisposition.Close\r\n            ) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (i === tags.length) {\r\n            throw new UnclosedTagError(openTag.name);\r\n        }\r\n\r\n        return i;\r\n    }\r\n}","import { XmlNode } from \"./xml\";\r\n\r\nexport class Delimiters {\r\n\r\n    public tagStart = \"{\";\r\n    public tagEnd = \"}\";\r\n    public containerTagOpen = \"#\";\r\n    public containerTagClose = \"/\";\r\n\r\n    constructor(initial?: Delimiters) {\r\n        Object.assign(this, initial);\r\n\r\n        this.encodeAndValidate();\r\n\r\n        if (this.tagStart === this.tagEnd)\r\n            throw new Error(`${nameof(this.tagStart)} can not be equal to ${nameof(this.tagEnd)}`);\r\n\r\n        if (this.containerTagOpen === this.containerTagClose)\r\n            throw new Error(`${nameof(this.containerTagOpen)} can not be equal to ${nameof(this.containerTagClose)}`);\r\n    }\r\n\r\n    private encodeAndValidate() {\r\n        const keys: (keyof Delimiters)[] = ['tagStart', 'tagEnd', 'containerTagOpen', 'containerTagClose'];\r\n        for (const key of keys) {\r\n            const value = this[key];\r\n\r\n            if (!value)\r\n                throw new Error(`${key} must be specified.`);\r\n\r\n            if (value.length > 1)\r\n                throw new Error(`Only single character delimiters supported (${key}: '${value}').`);\r\n\r\n            this[key] = XmlNode.encodeValue(value);\r\n        }\r\n    }\r\n}","export * from './malformedFileError';\r\nexport * from './maxXmlDepthError';\r\nexport * from './missingArgumentError';\r\nexport * from './missingCloseDelimiterError';\r\nexport * from './missingStartDelimiterError';\r\nexport * from './unclosedTagError';\r\nexport * from './unidentifiedFileTypeError';\r\nexport * from './unknownContentTypeError';\r\nexport * from './unopenedTagError';\r\nexport * from './unsupportedFileTypeError';\r\n","export class MalformedFileError extends Error {\r\n\r\n    public readonly expectedFileType: string;\r\n\r\n    constructor(expectedFileType: string) {\r\n        super(`Malformed file detected. Make sure the file is a valid ${expectedFileType} file.`);\r\n\r\n        this.expectedFileType = expectedFileType;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MalformedFileError.prototype);\r\n    }\r\n}","export class MaxXmlDepthError extends Error {\r\n\r\n    public readonly maxDepth: number;\r\n\r\n    constructor(maxDepth: number) {\r\n        super(`XML maximum depth reached (max depth: ${maxDepth}).`);\r\n\r\n        this.maxDepth = maxDepth;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MaxXmlDepthError.prototype);\r\n    }\r\n}","export class MissingArgumentError extends Error {\r\n\r\n    public readonly argName: string;\r\n\r\n    constructor(argName: string) {\r\n        super(`Argument '${argName}' is missing.`);\r\n\r\n        this.argName = argName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingArgumentError.prototype);\r\n    }\r\n}","export class MissingCloseDelimiterError extends Error {\r\n\r\n    public readonly openDelimiterText: string;\r\n\r\n    constructor(openDelimiterText: string) {\r\n        super(`Close delimiter is missing from '${openDelimiterText}'.`);\r\n\r\n        this.openDelimiterText = openDelimiterText;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingCloseDelimiterError.prototype);\r\n    }\r\n}","export class MissingStartDelimiterError extends Error {\r\n\r\n    public readonly closeDelimiterText: string;\r\n\r\n    constructor(closeDelimiterText: string) {\r\n        super(`Open delimiter is missing from '${closeDelimiterText}'.`);\r\n\r\n        this.closeDelimiterText = closeDelimiterText;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingStartDelimiterError.prototype);\r\n    }\r\n}","export class UnclosedTagError extends Error {\r\n\r\n    public readonly tagName: string;\r\n\r\n    constructor(tagName: string) {\r\n        super(`Tag '${tagName}' is never closed.`);\r\n\r\n        this.tagName = tagName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnclosedTagError.prototype);\r\n    }\r\n}","export class UnidentifiedFileTypeError extends Error {\r\n    constructor() {\r\n        super(`The filetype for this file could not be identified, is this file corrupted?`);\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnidentifiedFileTypeError.prototype);\r\n    }\r\n}","export class UnknownContentTypeError extends Error {\r\n\r\n    public readonly tagRawText: string;\r\n    public readonly contentType: string;\r\n    public readonly path: string;\r\n\r\n    constructor(contentType: string, tagRawText: string, path: string) {\r\n        super(`Content type '${contentType}' does not have a registered plugin to handle it.`);\r\n\r\n        this.contentType = contentType;\r\n        this.tagRawText = tagRawText;\r\n        this.path = path;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnknownContentTypeError.prototype);\r\n    }\r\n}","export class UnopenedTagError extends Error {\r\n\r\n    public readonly tagName: string;\r\n\r\n    constructor(tagName: string) {\r\n        super(`Tag '${tagName}' is closed but was never opened.`);\r\n\r\n        this.tagName = tagName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnopenedTagError.prototype);\r\n    }\r\n}","export class UnsupportedFileTypeError extends Error {\r\n\r\n    public readonly fileType: string;\r\n\r\n    constructor(fileType: string) {\r\n        super(`Filetype \"${fileType}\" is not supported.`);\r\n\r\n        this.fileType = fileType;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnsupportedFileTypeError.prototype);\r\n    }\r\n}","export * from './compilation';\r\nexport * from './errors';\r\nexport * from './office';\r\nexport * from './plugins';\r\nexport * from './utils';\r\nexport * from './xml';\r\nexport * from './delimiters';\r\nexport * from './mimeType';\r\nexport * from './templateData';\r\nexport * from './templateHandler';\r\nexport * from './templateHandlerOptions';\r\n","import { UnsupportedFileTypeError } from './errors';\r\n\r\nexport enum MimeType {\r\n    Png = 'image/png',\r\n    Jpeg = 'image/jpeg',\r\n    Gif = 'image/gif',\r\n    Bmp = 'image/bmp',\r\n    Svg = 'image/svg+xml'\r\n}\r\n\r\nexport class MimeTypeHelper {\r\n\r\n    public static getDefaultExtension(mime: MimeType): string {\r\n        switch (mime) {\r\n            case MimeType.Png:\r\n                return 'png';\r\n            case MimeType.Jpeg:\r\n                return 'jpg';\r\n            case MimeType.Gif:\r\n                return 'gif';\r\n            case MimeType.Bmp:\r\n                return 'bmp';\r\n            case MimeType.Svg:\r\n                return 'svg';\r\n            default:\r\n                throw new UnsupportedFileTypeError(mime);\r\n        }\r\n    }\r\n\r\n    public static getOfficeRelType(mime: MimeType): string {\r\n        switch (mime) {\r\n            case MimeType.Png:\r\n            case MimeType.Jpeg:\r\n            case MimeType.Gif:\r\n            case MimeType.Bmp:\r\n            case MimeType.Svg:\r\n                return \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\";\r\n            default:\r\n                throw new UnsupportedFileTypeError(mime);\r\n        }\r\n    }\r\n}","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { XmlGeneralNode, XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * http://officeopenxml.com/anatomyofOOXML.php\r\n */\r\nexport class ContentTypesFile {\r\n\r\n    private static readonly contentTypesFilePath = '[Content_Types].xml';\r\n\r\n    private addedNew = false;\r\n\r\n    private root: XmlNode;\r\n\r\n    private contentTypes: IMap<boolean>;\r\n\r\n    constructor(\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n    }\r\n\r\n    public async ensureContentType(mime: MimeType): Promise<void> {\r\n\r\n        // parse the content types file\r\n        await this.parseContentTypesFile();\r\n\r\n        // already exists\r\n        if (this.contentTypes[mime])\r\n            return;\r\n\r\n        // add new\r\n        const extension = MimeTypeHelper.getDefaultExtension(mime);\r\n        const typeNode = XmlNode.createGeneralNode('Default');\r\n        typeNode.attributes = [\r\n            { name: \"Extension\", value: extension },\r\n            { name: \"ContentType\", value: mime }\r\n        ];\r\n        this.root.childNodes.push(typeNode);\r\n\r\n        // update state\r\n        this.addedNew = true;\r\n        this.contentTypes[mime] = true;\r\n    }\r\n\r\n    public async count(): Promise<number> {\r\n        await this.parseContentTypesFile();\r\n        return this.root.childNodes.filter(node => !XmlNode.isTextNode(node)).length;\r\n    }\r\n\r\n    public async save(): Promise<void> {\r\n\r\n        // not change - no need to save\r\n        if (!this.addedNew)\r\n            return;\r\n\r\n        const xmlContent = this.xmlParser.serialize(this.root);\r\n        this.zip.setFile(ContentTypesFile.contentTypesFilePath, xmlContent);\r\n    }\r\n\r\n    private async parseContentTypesFile(): Promise<void> {\r\n        if (this.root)\r\n            return;\r\n\r\n        // parse the xml file\r\n        const contentTypesXml = await this.zip.getFile(ContentTypesFile.contentTypesFilePath).getContentText();\r\n        this.root = this.xmlParser.parse(contentTypesXml);\r\n\r\n        // build the content types lookup\r\n        this.contentTypes = {};\r\n        for (const node of this.root.childNodes) {\r\n\r\n            if (node.nodeName !== 'Default')\r\n                continue;\r\n\r\n            const genNode = (node as XmlGeneralNode);\r\n            const contentTypeAttribute = genNode.attributes.find(attr => attr.name === 'ContentType');\r\n            if (!contentTypeAttribute)\r\n                continue;\r\n\r\n            this.contentTypes[contentTypeAttribute.value];\r\n        }\r\n    }\r\n}","import { MalformedFileError } from '../errors';\r\nimport { MimeType } from '../mimeType';\r\nimport { Binary } from '../utils';\r\nimport { XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\nimport { ContentTypesFile } from './contentTypesFile';\r\nimport { MediaFiles } from './mediaFiles';\r\nimport { Rels } from './rels';\r\n\r\n/**\r\n * Represents a single docx file.\r\n */\r\nexport class Docx {\r\n\r\n    public get documentPath(): string {\r\n\r\n        if (!this._documentPath) {\r\n\r\n            if (this.zip.isFileExist(\"word/document.xml\")) {\r\n                this._documentPath = \"word/document.xml\";\r\n            }\r\n\r\n            // https://github.com/open-xml-templating/docxtemplater/issues/366\r\n            else if (this.zip.isFileExist(\"word/document2.xml\")) {\r\n                this._documentPath = \"word/document2.xml\";\r\n            }\r\n        }\r\n\r\n        return this._documentPath;\r\n    }\r\n\r\n    private _documentPath: string;\r\n    private _document: XmlNode;\r\n\r\n    private readonly rels: Rels;\r\n    private readonly mediaFiles: MediaFiles;\r\n    private readonly contentTypes: ContentTypesFile;\r\n\r\n    constructor(\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n        if (!this.documentPath)\r\n            throw new MalformedFileError('docx');\r\n\r\n        this.rels = new Rels(this.documentPath, zip, xmlParser);\r\n        this.mediaFiles = new MediaFiles(zip);\r\n        this.contentTypes = new ContentTypesFile(zip, xmlParser);\r\n    }\r\n\r\n    //\r\n    // public methods\r\n    //\r\n\r\n    /**\r\n     * The xml root of the main document file.\r\n     */\r\n    public async getDocument(): Promise<XmlNode> {\r\n        if (!this._document) {\r\n            const xml = await this.zip.getFile(this.documentPath).getContentText();\r\n            this._document = this.xmlParser.parse(xml);\r\n        }\r\n        return this._document;\r\n    }\r\n\r\n    /**\r\n     * Get the text content of the main document file.\r\n     */\r\n    public async getDocumentText(): Promise<string> {\r\n        const xmlDocument = await this.getDocument();\r\n\r\n        // ugly but good enough...\r\n        const xml = this.xmlParser.serialize(xmlDocument);\r\n        const domDocument = this.xmlParser.domParse(xml);\r\n\r\n        return domDocument.documentElement.textContent;\r\n    }\r\n\r\n    /**\r\n     * Add a media resource to the document archive and return the created rel ID.\r\n     */\r\n    public async addMedia(content: Binary, type: MimeType): Promise<string> {\r\n\r\n        const mediaFilePath = await this.mediaFiles.add(content, type);\r\n        const relId = await this.rels.add(mediaFilePath, type);\r\n        await this.contentTypes.ensureContentType(type);\r\n        return relId;\r\n    }\r\n\r\n    public async export<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        await this.saveChanges();\r\n        return await this.zip.export(outputType);\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //        \r\n\r\n    private async saveChanges() {\r\n\r\n        // save main document\r\n        const document = await this.getDocument();\r\n        const xmlContent = this.xmlParser.serialize(document);\r\n        this.zip.setFile(this.documentPath, xmlContent);\r\n\r\n        // save other parts\r\n        await this.rels.save();\r\n        await this.contentTypes.save();\r\n    }\r\n}","import { XmlNode, XmlParser, XmlTextNode } from '../xml';\r\nimport { Zip } from '../zip';\r\nimport { Docx } from './docx';\r\n\r\nexport class DocxParser {\r\n\r\n    /*\r\n     * Word markup intro:\r\n     * \r\n     * In Word text nodes are contained in \"run\" nodes (which specifies text\r\n     * properties such as font and color). The \"run\" nodes in turn are\r\n     * contained in paragraph nodes which is the core unit of content.\r\n     * \r\n     * Example:\r\n     *\r\n     * <w:p>    <-- paragraph\r\n     *   <w:r>      <-- run\r\n     *     <w:rPr>      <-- run properties\r\n     *       <w:b/>     <-- bold\r\n     *     </w:rPr>\r\n     *     <w:t>This is text.</w:t>     <-- actual text\r\n     *   </w:r>\r\n     * </w:p> \r\n     *\r\n     * see: http://officeopenxml.com/WPcontentOverview.php\r\n     */\r\n\r\n    public static readonly PARAGRAPH_NODE = 'w:p';\r\n    public static readonly PARAGRAPH_PROPERTIES_NODE = 'w:pPr';\r\n    public static readonly RUN_NODE = 'w:r';\r\n    public static readonly TEXT_NODE = 'w:t';\r\n    public static readonly TABLE_ROW_NODE = 'w:tr';\r\n    public static readonly TABLE_CELL_NODE = 'w:tc';\r\n    public static readonly NUMBER_PROPERTIES_NODE = 'w:numPr';\r\n\r\n    //\r\n    // constructor\r\n    //\r\n\r\n    constructor(\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n    }\r\n\r\n    //\r\n    // parse document\r\n    //\r\n\r\n    public load(zip: Zip): Docx {\r\n        return new Docx(zip, this.xmlParser);\r\n    }    \r\n\r\n    //\r\n    // content manipulation\r\n    //\r\n\r\n    /**\r\n     * Split the text node into two text nodes, each with it's own wrapping <w:t> node.\r\n     * Returns the newly created text node.\r\n     * \r\n     * @param textNode \r\n     * @param splitIndex \r\n     * @param addBefore Should the new node be added before or after the original node.\r\n     */\r\n    public splitTextNode(textNode: XmlTextNode, splitIndex: number, addBefore: boolean): XmlTextNode {\r\n\r\n        let firstXmlTextNode: XmlTextNode;\r\n        let secondXmlTextNode: XmlTextNode;\r\n\r\n        // split nodes\r\n        const wordTextNode = this.containingTextNode(textNode);\r\n        const newWordTextNode = XmlNode.cloneNode(wordTextNode, true);\r\n        if (addBefore) {\r\n\r\n            // insert new node before existing one\r\n            XmlNode.insertBefore(newWordTextNode, wordTextNode);\r\n\r\n            firstXmlTextNode = XmlNode.lastTextChild(newWordTextNode);\r\n            secondXmlTextNode = textNode;\r\n\r\n        } else {\r\n\r\n            // insert new node after existing one\r\n            const curIndex = wordTextNode.parentNode.childNodes.indexOf(wordTextNode);\r\n            XmlNode.insertChild(wordTextNode.parentNode, newWordTextNode, curIndex + 1);\r\n\r\n            firstXmlTextNode = textNode;\r\n            secondXmlTextNode = XmlNode.lastTextChild(newWordTextNode);\r\n        }\r\n\r\n        // edit text\r\n        const firstText = firstXmlTextNode.textContent;\r\n        const secondText = secondXmlTextNode.textContent;\r\n        firstXmlTextNode.textContent = firstText.substring(0, splitIndex);\r\n        secondXmlTextNode.textContent = secondText.substring(splitIndex);\r\n\r\n        return (addBefore ? firstXmlTextNode : secondXmlTextNode);\r\n    }\r\n\r\n    /**\r\n     * Move all text between the 'from' and 'to' nodes to the 'from' node.\r\n     */\r\n    public joinTextNodesRange(from: XmlTextNode, to: XmlTextNode): void {\r\n\r\n        // find run nodes\r\n        const firstRunNode = this.containingRunNode(from);\r\n        const secondRunNode = this.containingRunNode(to);\r\n\r\n        const paragraphNode = firstRunNode.parentNode;\r\n        if (secondRunNode.parentNode !== paragraphNode)\r\n            throw new Error('Can not join text nodes from separate paragraphs.');\r\n\r\n        // find \"word text nodes\"\r\n        const firstWordTextNode = this.containingTextNode(from);\r\n        const secondWordTextNode = this.containingTextNode(to);\r\n        const totalText: string[] = [];\r\n\r\n        // iterate runs\r\n        let curRunNode = firstRunNode;\r\n        while (curRunNode) {\r\n\r\n            // iterate text nodes\r\n            let curWordTextNode: XmlNode;\r\n            if (curRunNode === firstRunNode) {\r\n                curWordTextNode = firstWordTextNode;\r\n            } else {\r\n                curWordTextNode = this.firstTextNodeChild(curRunNode);\r\n            }\r\n            while (curWordTextNode) {\r\n\r\n                if (curWordTextNode.nodeName !== DocxParser.TEXT_NODE)\r\n                    continue;\r\n\r\n                // move text to first node\r\n                const curXmlTextNode = XmlNode.lastTextChild(curWordTextNode);\r\n                totalText.push(curXmlTextNode.textContent);\r\n\r\n                // next text node\r\n                const textToRemove = curWordTextNode;\r\n                if (curWordTextNode === secondWordTextNode) {\r\n                    curWordTextNode = null;\r\n                } else {\r\n                    curWordTextNode = curWordTextNode.nextSibling;\r\n                }\r\n\r\n                // remove current text node\r\n                if (textToRemove !== firstWordTextNode) {\r\n                    XmlNode.remove(textToRemove);\r\n                }\r\n            }\r\n\r\n            // next run\r\n            const runToRemove = curRunNode;\r\n            if (curRunNode === secondRunNode) {\r\n                curRunNode = null;\r\n            } else {\r\n                curRunNode = curRunNode.nextSibling;\r\n            }\r\n\r\n            // remove current run\r\n            if (!runToRemove.childNodes || !runToRemove.childNodes.length) {\r\n                XmlNode.remove(runToRemove);\r\n            }\r\n        }\r\n\r\n        // set the text content\r\n        const firstXmlTextNode = XmlNode.lastTextChild(firstWordTextNode);\r\n        firstXmlTextNode.textContent = totalText.join('');\r\n    }\r\n\r\n    /**\r\n     * Take all runs from 'second' and move them to 'first'.\r\n     */\r\n    public joinParagraphs(first: XmlNode, second: XmlNode): void {\r\n        if (first === second)\r\n            return;\r\n\r\n        let childIndex = 0;\r\n        while (second.childNodes && childIndex < second.childNodes.length) {\r\n            const curChild = second.childNodes[childIndex];\r\n            if (curChild.nodeName === DocxParser.RUN_NODE) {\r\n                XmlNode.removeChild(second, childIndex);\r\n                XmlNode.appendChild(first, curChild);\r\n            } else {\r\n                childIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    //\r\n    // node queries\r\n    //\r\n\r\n    public isTableCellNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.TABLE_CELL_NODE;\r\n    }\r\n\r\n    public isParagraphNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.PARAGRAPH_NODE;\r\n    }\r\n\r\n    public isListParagraph(paragraphNode: XmlNode): boolean {\r\n        const paragraphProperties = this.paragraphPropertiesNode(paragraphNode);\r\n        const listNumberProperties = XmlNode.findChildByName(paragraphProperties, DocxParser.NUMBER_PROPERTIES_NODE);\r\n        return !!listNumberProperties;\r\n    }\r\n\r\n    public paragraphPropertiesNode(paragraphNode: XmlNode): XmlNode {\r\n        if (!this.isParagraphNode(paragraphNode))\r\n            throw new Error(`Expected paragraph node but received a '${paragraphNode.nodeName}' node.`);\r\n\r\n        return XmlNode.findChildByName(paragraphNode, DocxParser.PARAGRAPH_PROPERTIES_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search for the first direct child **Word** text node (i.e. a <w:t> node).\r\n     */\r\n    public firstTextNodeChild(node: XmlNode): XmlNode {\r\n\r\n        if (!node)\r\n            return null;\r\n\r\n        if (node.nodeName !== DocxParser.RUN_NODE)\r\n            return null;\r\n\r\n        if (!node.childNodes)\r\n            return null;\r\n\r\n        for (const child of node.childNodes) {\r\n            if (child.nodeName === DocxParser.TEXT_NODE)\r\n                return child;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first **Word** text node (i.e. a <w:t> node).\r\n     */\r\n    public containingTextNode(node: XmlTextNode): XmlNode {\r\n\r\n        if (!node)\r\n            return null;\r\n\r\n        if (!XmlNode.isTextNode(node))\r\n            throw new Error(`'Invalid argument ${nameof(node)}. Expected a XmlTextNode.`);\r\n\r\n        return XmlNode.findParentByName(node, DocxParser.TEXT_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first run node.\r\n     */\r\n    public containingRunNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.RUN_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first paragraph node.\r\n     */\r\n    public containingParagraphNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.PARAGRAPH_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first \"table row\" node.\r\n     */\r\n    public containingTableRowNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.TABLE_ROW_NODE);\r\n    }\r\n}","export * from './docx';\r\nexport * from './docxParser';\r\n","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { Binary, Path, sha1 } from '../utils';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * Handles media files of the main document.\r\n */\r\nexport class MediaFiles {\r\n\r\n    private static readonly mediaDir = 'word/media';\r\n\r\n    private hashes: IMap<string>;\r\n    private readonly files = new Map<Binary, string>();\r\n    private nextFileId = 0;\r\n\r\n    constructor(private readonly zip: Zip) {\r\n    }\r\n\r\n    /**\r\n     * Returns the media file path.\r\n     */\r\n    public async add(mediaFile: Binary, mime: MimeType): Promise<string> {\r\n\r\n        // check if already added\r\n        if (this.files.has(mediaFile))\r\n            return this.files.get(mediaFile);\r\n\r\n        // hash existing media files\r\n        await this.hashMediaFiles();\r\n\r\n        // hash the new file  \r\n        // Note: Even though hashing the base64 string may seem inefficient\r\n        // (requires extra step in some cases) in practice it is significantly\r\n        // faster than hashing a 'binarystring'.\r\n        const base64 = await Binary.toBase64(mediaFile);\r\n        const hash = sha1(base64);\r\n\r\n        // check if file already exists\r\n        // note: this can be optimized by keeping both mapping by filename as well as by hash\r\n        let path = Object.keys(this.hashes).find(p => this.hashes[p] === hash);\r\n        if (path)\r\n            return path;\r\n\r\n        // generate unique media file name\r\n        const extension = MimeTypeHelper.getDefaultExtension(mime);\r\n        do {\r\n            this.nextFileId++;\r\n            path = `${MediaFiles.mediaDir}/media${this.nextFileId}.${extension}`;\r\n        } while (this.hashes[path]);\r\n\r\n        // add media to zip\r\n        await this.zip.setFile(path, mediaFile);\r\n\r\n        // add media to our lookups\r\n        this.hashes[path] = hash;\r\n        this.files.set(mediaFile, path);\r\n\r\n        // return\r\n        return path;\r\n    }\r\n\r\n    public async count(): Promise<number> {\r\n        await this.hashMediaFiles();\r\n        return Object.keys(this.hashes).length;\r\n    }\r\n\r\n    private async hashMediaFiles(): Promise<void> {\r\n        if (this.hashes)\r\n            return;\r\n\r\n        this.hashes = {};\r\n        for (const path of this.zip.listFiles()) {\r\n\r\n            if (!path.startsWith(MediaFiles.mediaDir))\r\n                continue;\r\n\r\n            const filename = Path.getFilename(path);\r\n            if (!filename)\r\n                continue;\r\n\r\n            const fileData = await this.zip.getFile(path).getContentBase64();\r\n            const fileHash = sha1(fileData);\r\n            this.hashes[filename] = fileHash;\r\n        }\r\n    }\r\n}","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { Path } from '../utils';\r\nimport { XmlGeneralNode, XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * Handles the relationship logic of a single docx \"part\".  \r\n * http://officeopenxml.com/anatomyofOOXML.php\r\n */\r\nexport class Rels {\r\n\r\n    private root: XmlNode;\r\n    private relIds: IMap<boolean>;\r\n    private relTargets: IMap<string>;\r\n    private nextRelId = 0;\r\n\r\n    private readonly partDir: string;\r\n    private readonly relsFilePath: string;\r\n\r\n    constructor(\r\n        partPath: string,\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n\r\n        this.partDir = Path.getDirectory(partPath);\r\n        const partFilename = Path.getFilename(partPath);\r\n        this.relsFilePath = `${this.partDir}/_rels/${partFilename}.rels`;\r\n    }\r\n\r\n    /**\r\n     * Returns the rel ID.\r\n     */\r\n    public async add(relTarget: string, mime: MimeType): Promise<string> {\r\n\r\n        // relTarget should be relative to the part dir\r\n        if (relTarget.startsWith(this.partDir)) {\r\n            relTarget = relTarget.substr(this.partDir.length + 1);\r\n        }\r\n\r\n        // parse rels file\r\n        await this.parseRelsFile();\r\n\r\n        // already exists?\r\n        const relTargetKey = this.getRelTargetKey(mime, relTarget);\r\n        let relId = this.relTargets[relTargetKey];\r\n        if (relId)\r\n            return relId;\r\n\r\n        // add rel node\r\n        relId = this.getNextRelId();\r\n        const relType = MimeTypeHelper.getOfficeRelType(mime);\r\n        const relNode = XmlNode.createGeneralNode('Relationship');\r\n        relNode.attributes = [\r\n            { name: \"Id\", value: relId },\r\n            { name: \"Type\", value: relType },\r\n            { name: \"Target\", value: relTarget }\r\n        ];\r\n        this.root.childNodes.push(relNode);\r\n\r\n        // update lookups\r\n        this.relIds[relId] = true;\r\n        this.relTargets[relTargetKey] = relId;\r\n\r\n        // return\r\n        return relId;\r\n    }\r\n\r\n    /**\r\n     * Save the rels file back to the zip.\r\n     */\r\n    public async save(): Promise<void> {\r\n\r\n        // not change - no need to save\r\n        if (!this.root)\r\n            return;\r\n\r\n        const xmlContent = this.xmlParser.serialize(this.root);\r\n        this.zip.setFile(this.relsFilePath, xmlContent);\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private getNextRelId(): string {\r\n\r\n        let relId: string;;\r\n        do {\r\n            this.nextRelId++;\r\n            relId = 'rId' + this.nextRelId;\r\n        } while (this.relIds[relId]);\r\n\r\n        return relId;\r\n    }\r\n\r\n    private async parseRelsFile(): Promise<void> {\r\n        if (this.root)\r\n            return;\r\n\r\n        // parse the xml file\r\n        let relsXml: string;\r\n        const relsFile = this.zip.getFile(this.relsFilePath);\r\n        if (relsFile) {\r\n            relsXml = await relsFile.getContentText();\r\n        } else {\r\n            relsXml = `<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\r\n                      </Relationships>`;\r\n        }\r\n        this.root = this.xmlParser.parse(relsXml);\r\n\r\n        // build lookups\r\n        this.relIds = {};\r\n        this.relTargets = {};\r\n        for (const rel of this.root.childNodes) {\r\n\r\n            const attributes = (rel as XmlGeneralNode).attributes;\r\n            if (!attributes)\r\n                continue;\r\n\r\n            // relIds lookup\r\n            const idAttr = attributes.find(attr => attr.name.toLowerCase() === 'id');\r\n            if (!idAttr || !idAttr.value)\r\n                continue;\r\n            this.relIds[idAttr.value] = true;\r\n\r\n            // rel target lookup\r\n            const typeAttr = attributes.find(attr => attr.name.toLowerCase() === 'Type');\r\n            const targetAttr = attributes.find(attr => attr.name.toLowerCase() === 'Target');\r\n            if (typeAttr && typeAttr.value && targetAttr && targetAttr.value) {\r\n                const relTargetKey = this.getRelTargetKey(typeAttr.value as MimeType, targetAttr.value);\r\n                this.relTargets[relTargetKey] = idAttr.value;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getRelTargetKey(type: MimeType, target: string): string {\r\n        return `${type} - ${target}`;\r\n    }\r\n}","import { ImagePlugin } from './imagePlugin';\r\nimport { LoopPlugin } from './loopPlugin';\r\nimport { RawXmlPlugin } from './rawXmlPlugin';\r\nimport { TemplatePlugin } from './templatePlugin';\r\nimport { TextPlugin } from './textPlugin';\r\n\r\nexport function createDefaultPlugins(): TemplatePlugin[] {\r\n    return [\r\n        new LoopPlugin(), \r\n        new RawXmlPlugin(),\r\n        new ImagePlugin(),\r\n        new TextPlugin()\r\n    ];\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { XmlGeneralNode, XmlNode } from '../xml';\r\nimport { ImageContent } from './imageContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\n/**\r\n * Apparently it is not that important for the ID to be unique...  \r\n * Word displays two images correctly even if they both have the same ID.\r\n * Further more, Word will assign each a unique ID upon saving (it assigns\r\n * consecutive integers starting with 1).  \r\n * \r\n * Note: The same principal applies to image names.\r\n *\r\n * Tested in Word v1908\r\n */\r\nlet nextImageId = 1;\r\n\r\nexport class ImagePlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = 'image';\r\n\r\n    public async simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const content = data.getScopeData() as ImageContent;\r\n        if (!content || !content.source) {\r\n            XmlNode.remove(wordTextNode);\r\n            return;\r\n        }\r\n\r\n        const imageId = nextImageId++;\r\n        const relId = await context.docx.addMedia(content.source, content.format);\r\n        const imageXml = this.createMarkup(imageId, relId, content.width, content.height);\r\n\r\n        XmlNode.insertAfter(imageXml, wordTextNode);\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n\r\n    private createMarkup(imageId: number, relId: string, width: number, height: number): XmlNode {\r\n\r\n        // http://officeopenxml.com/drwPicInline.php\r\n\r\n        //\r\n        // Performance note:  \r\n        //\r\n        // I've tried to improve the markup generation performance by parsing\r\n        // the string once and caching the result (and of course customizing it\r\n        // per image) but it made no change whatsoever (in both cases 1000 items\r\n        // loop takes around 8 seconds on my machine) so I'm sticking with this\r\n        // approach which I find to be more readable.\r\n        //\r\n\r\n        const name = `Picture ${imageId}`;\r\n        const markupText = `\r\n            <w:drawing>\r\n                <wp:inline distT=\"0\" distB=\"0\" distL=\"0\" distR=\"0\">\r\n                    <wp:extent cx=\"${this.pixelsToEmu(width)}\" cy=\"${this.pixelsToEmu(height)}\"/>\r\n                    <wp:effectExtent l=\"0\" t=\"0\" r=\"0\" b=\"0\"/>\r\n                    <wp:docPr id=\"${imageId}\" name=\"${name}\"/>\r\n                    <wp:cNvGraphicFramePr>\r\n                        <a:graphicFrameLocks xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" noChangeAspect=\"1\"/>\r\n                    </wp:cNvGraphicFramePr>\r\n                    <a:graphic xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">\r\n                        <a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/picture\">\r\n                            ${this.pictureMarkup(name, relId, width, height)}\r\n                        </a:graphicData>\r\n                    </a:graphic>\r\n                </wp:inline>\r\n            </w:drawing>\r\n        `;\r\n\r\n        const markupXml = this.utilities.xmlParser.parse(markupText) as XmlGeneralNode;\r\n        XmlNode.stripTextNodes(markupXml); // remove whitespace\r\n\r\n        return markupXml;\r\n    }\r\n\r\n    private pictureMarkup(name: string, relId: string, width: number, height: number) {\r\n\r\n        // http://officeopenxml.com/drwPic.php\r\n\r\n        // legend:\r\n        // nvPicPr - non-visual picture properties - id, name, etc.\r\n        // blipFill - binary large image (or) picture fill - image size, image fill, etc.\r\n        // spPr - shape properties - frame size, frame fill, etc.\r\n\r\n        return `\r\n            <pic:pic xmlns:pic=\"http://schemas.openxmlformats.org/drawingml/2006/picture\">\r\n                <pic:nvPicPr>\r\n                    <pic:cNvPr id=\"0\" name=\"${name}\"/>\r\n                    <pic:cNvPicPr>\r\n                        <a:picLocks noChangeAspect=\"1\" noChangeArrowheads=\"1\"/>\r\n                    </pic:cNvPicPr>\r\n                </pic:nvPicPr>\r\n                <pic:blipFill>\r\n                    <a:blip r:embed=\"${relId}\">\r\n                        <a:extLst>\r\n                            <a:ext uri=\"{28A0092B-C50C-407E-A947-70E740481C1C}\">\r\n                                <a14:useLocalDpi xmlns:a14=\"http://schemas.microsoft.com/office/drawing/2010/main\" val=\"0\"/>\r\n                            </a:ext>\r\n                        </a:extLst>\r\n                    </a:blip>\r\n                    <a:srcRect/>\r\n                    <a:stretch>\r\n                        <a:fillRect/>\r\n                    </a:stretch>\r\n                </pic:blipFill>\r\n                <pic:spPr bwMode=\"auto\">\r\n                    <a:xfrm>\r\n                        <a:off x=\"0\" y=\"0\"/>\r\n                        <a:ext cx=\"${this.pixelsToEmu(width)}\" cy=\"${this.pixelsToEmu(height)}\"/>\r\n                    </a:xfrm>\r\n                    <a:prstGeom prst=\"rect\">\r\n                        <a:avLst/>\r\n                    </a:prstGeom>\r\n                    <a:noFill/>\r\n                    <a:ln>\r\n                        <a:noFill/>\r\n                    </a:ln>\r\n                </pic:spPr>\r\n            </pic:pic>\r\n        `;\r\n    }\r\n\r\n    private pixelsToEmu(pixels: number): number {\r\n\r\n        // https://stackoverflow.com/questions/20194403/openxml-distance-size-units\r\n        // https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-units#other-units-of-measurement\r\n        // https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML\r\n        // http://www.java2s.com/Code/CSharp/2D-Graphics/ConvertpixelstoEMUEMUtopixels.htm\r\n\r\n        return Math.round(pixels * 9525);\r\n    }\r\n}","export * from './defaultPlugins';\r\nexport * from './imageContent';\r\nexport * from './imagePlugin';\r\nexport * from './loopPlugin';\r\nexport * from './pluginContent';\r\nexport * from './rawXmlContent';\r\nexport * from './rawXmlPlugin';\r\nexport * from './templatePlugin';\r\nexport * from './textPlugin';\r\n","export * from './iLoopStrategy';\r\nexport * from './loopListStrategy';\r\nexport * from './loopParagraphStrategy';\r\nexport * from './loopTableStrategy';\r\n","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopListStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        const containingParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        return this.utilities.docxParser.isListParagraph(containingParagraph);\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        const firstParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        const lastParagraph = this.utilities.docxParser.containingParagraphNode(closeTag.xmlTextNode);\r\n        const paragraphsToRepeat = XmlNode.siblingsInRange(firstParagraph, lastParagraph);\r\n\r\n        // remove the loop tags\r\n        XmlNode.remove(openTag.xmlTextNode);\r\n        XmlNode.remove(closeTag.xmlTextNode);\r\n\r\n        return {\r\n            firstNode: firstParagraph,\r\n            nodesToRepeat: paragraphsToRepeat,\r\n            lastNode: lastParagraph\r\n        };\r\n    }\r\n\r\n    public mergeBack(paragraphGroups: XmlNode[][], firstParagraph: XmlNode, lastParagraphs: XmlNode): void {\r\n\r\n        for (const curParagraphsGroup of paragraphGroups) {\r\n            for (const paragraph of curParagraphsGroup) {\r\n                XmlNode.insertBefore(paragraph, lastParagraphs);\r\n            }\r\n        }\r\n\r\n        // remove the old paragraphs\r\n        XmlNode.remove(firstParagraph);\r\n        if (firstParagraph !== lastParagraphs) {\r\n            XmlNode.remove(lastParagraphs);\r\n        }\r\n    }\r\n}","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopParagraphStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        return true;\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        // gather some info\r\n        let firstParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        let lastParagraph = this.utilities.docxParser.containingParagraphNode(closeTag.xmlTextNode);\r\n        const areSame = (firstParagraph === lastParagraph);\r\n        const parent = firstParagraph.parentNode;\r\n        const firstParagraphIndex = parent.childNodes.indexOf(firstParagraph);\r\n        const lastParagraphIndex = areSame ? firstParagraphIndex : parent.childNodes.indexOf(lastParagraph);\r\n\r\n        // split first paragraphs\r\n        let splitResult = XmlNode.splitByChild(firstParagraph, openTag.xmlTextNode, true);\r\n        firstParagraph = splitResult[0];\r\n        const firstParagraphSplit = splitResult[1];\r\n        if (areSame)\r\n            lastParagraph = firstParagraphSplit;\r\n\r\n        // split last paragraph\r\n        splitResult = XmlNode.splitByChild(lastParagraph, closeTag.xmlTextNode, true);\r\n        const lastParagraphSplit = splitResult[0];\r\n        lastParagraph = splitResult[1];\r\n\r\n        // fix references\r\n        XmlNode.removeChild(parent, firstParagraphIndex + 1);\r\n        if (!areSame)\r\n            XmlNode.removeChild(parent, lastParagraphIndex);\r\n        firstParagraphSplit.parentNode = null;\r\n        lastParagraphSplit.parentNode = null;\r\n\r\n        // extract all paragraphs in between\r\n        let middleParagraphs: XmlNode[];\r\n        if (areSame) {\r\n            this.utilities.docxParser.joinParagraphs(firstParagraphSplit, lastParagraphSplit);\r\n            middleParagraphs = [firstParagraphSplit];\r\n        } else {\r\n            const inBetween = XmlNode.removeSiblings(firstParagraph, lastParagraph);\r\n            middleParagraphs = [firstParagraphSplit].concat(inBetween).concat(lastParagraphSplit);\r\n        }\r\n\r\n        return {\r\n            firstNode: firstParagraph,\r\n            nodesToRepeat: middleParagraphs,\r\n            lastNode: lastParagraph\r\n        };\r\n    }\r\n\r\n    public mergeBack(middleParagraphs: XmlNode[][], firstParagraph: XmlNode, lastParagraph: XmlNode): void {\r\n\r\n        let mergeTo = firstParagraph;\r\n        for (const curParagraphsGroup of middleParagraphs) {\r\n\r\n            // merge first paragraphs\r\n            this.utilities.docxParser.joinParagraphs(mergeTo, curParagraphsGroup[0]);\r\n\r\n            // add middle and last paragraphs to the original document\r\n            for (let i = 1; i < curParagraphsGroup.length; i++) {\r\n                XmlNode.insertBefore(curParagraphsGroup[i], lastParagraph);\r\n                mergeTo = curParagraphsGroup[i];\r\n            }\r\n        }\r\n\r\n        // merge last paragraph\r\n        this.utilities.docxParser.joinParagraphs(mergeTo, lastParagraph);\r\n\r\n        // remove the old last paragraph (was merged into the new one)\r\n        XmlNode.remove(lastParagraph);\r\n    }\r\n}\r\n","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopTableStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        const containingParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        if (!containingParagraph.parentNode)\r\n            return false;\r\n        return this.utilities.docxParser.isTableCellNode(containingParagraph.parentNode);\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        const firstRow = this.utilities.docxParser.containingTableRowNode(openTag.xmlTextNode);\r\n        const lastRow = this.utilities.docxParser.containingTableRowNode(closeTag.xmlTextNode);\r\n        const rowsToRepeat = XmlNode.siblingsInRange(firstRow, lastRow);\r\n\r\n        // remove the loop tags\r\n        XmlNode.remove(openTag.xmlTextNode);\r\n        XmlNode.remove(closeTag.xmlTextNode);\r\n\r\n        return {\r\n            firstNode: firstRow,\r\n            nodesToRepeat: rowsToRepeat,\r\n            lastNode: lastRow\r\n        };\r\n    }\r\n\r\n    public mergeBack(rowGroups: XmlNode[][], firstRow: XmlNode, lastRow: XmlNode): void {\r\n\r\n        for (const curRowsGroup of rowGroups) {\r\n            for (const row of curRowsGroup) {\r\n                XmlNode.insertBefore(row, lastRow);\r\n            }\r\n        }\r\n\r\n        // remove the old rows\r\n        XmlNode.remove(firstRow);\r\n        if (firstRow !== lastRow) {\r\n            XmlNode.remove(lastRow);\r\n        }\r\n    }\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { TemplateData } from '../templateData';\r\nimport { last } from '../utils';\r\nimport { XmlNode } from '../xml';\r\nimport { ILoopStrategy, LoopListStrategy, LoopParagraphStrategy, LoopTableStrategy } from './loop';\r\nimport { PluginUtilities, TemplatePlugin } from './templatePlugin';\r\n\r\nexport const LOOP_CONTENT_TYPE = 'loop';\r\n\r\nexport class LoopPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = LOOP_CONTENT_TYPE;\r\n\r\n    private readonly loopStrategies: ILoopStrategy[] = [\r\n        new LoopTableStrategy(),\r\n        new LoopListStrategy(),\r\n        new LoopParagraphStrategy() // the default strategy\r\n    ];\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n        this.loopStrategies.forEach(strategy => strategy.setUtilities(utilities));\r\n    }    \r\n\r\n    public async containerTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        let value = data.getScopeData() as TemplateData[];\r\n\r\n        if (!value || !Array.isArray(value) || !value.length)\r\n            value = [];\r\n\r\n        // vars\r\n        const openTag = tags[0];\r\n        const closeTag = last(tags);\r\n\r\n        // select the suitable strategy\r\n        const loopStrategy = this.loopStrategies.find(strategy => strategy.isApplicable(openTag, closeTag));\r\n        if (!loopStrategy)\r\n            throw new Error(`No loop strategy found for tag '${openTag.rawText}'.`);\r\n\r\n        // prepare to loop\r\n        const { firstNode, nodesToRepeat, lastNode } = loopStrategy.splitBefore(openTag, closeTag);\r\n\r\n        // repeat (loop) the content\r\n        const repeatedNodes = this.repeat(nodesToRepeat, value.length);\r\n\r\n        // recursive compilation \r\n        // (this step can be optimized in the future if we'll keep track of the\r\n        // path to each token and use that to create new tokens instead of\r\n        // search through the text again)\r\n        const compiledNodes = await this.compile(repeatedNodes, data, context);\r\n\r\n        // merge back to the document\r\n        loopStrategy.mergeBack(compiledNodes, firstNode, lastNode);\r\n    }\r\n\r\n    private repeat(nodes: XmlNode[], times: number): XmlNode[][] {\r\n        if (!nodes.length || !times)\r\n            return [];\r\n\r\n        const allResults: XmlNode[][] = [];\r\n\r\n        for (let i = 0; i < times; i++) {\r\n            const curResult = nodes.map(node => XmlNode.cloneNode(node, true));\r\n            allResults.push(curResult);\r\n        }\r\n\r\n        return allResults;\r\n    }\r\n\r\n    private async compile(nodeGroups: XmlNode[][], data: ScopeData, context: TemplateContext): Promise<XmlNode[][]> {\r\n        const compiledNodeGroups: XmlNode[][] = [];\r\n\r\n        // compile each node group with it's relevant data\r\n        for (let i = 0; i < nodeGroups.length; i++) {\r\n\r\n            // create dummy root node\r\n            const curNodes = nodeGroups[i];\r\n            const dummyRootNode = XmlNode.createGeneralNode('dummyRootNode');\r\n            curNodes.forEach(node => XmlNode.appendChild(dummyRootNode, node));\r\n\r\n            // compile the new root\r\n            data.path.push(i);\r\n            await this.utilities.compiler.compile(dummyRootNode, data, context);\r\n            data.path.pop();\r\n\r\n            // disconnect from dummy root\r\n            const curResult: XmlNode[] = [];\r\n            while (dummyRootNode.childNodes && dummyRootNode.childNodes.length) {\r\n                const child = XmlNode.removeChild(dummyRootNode, 0);\r\n                curResult.push(child);\r\n            }\r\n            compiledNodeGroups.push(curResult);\r\n        }\r\n\r\n        return compiledNodeGroups;\r\n    }\r\n}","\r\nexport interface PluginContent {\r\n    _type: string;\r\n}\r\n\r\nexport const PluginContent = {\r\n    isPluginContent(content: any): content is PluginContent {\r\n        return !!content && typeof content._type === 'string';\r\n    }\r\n};","import { ScopeData, Tag } from '../compilation';\r\nimport { XmlNode } from '../xml';\r\nimport { RawXmlContent } from './rawXmlContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport class RawXmlPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = 'rawXml';\r\n\r\n    /**\r\n     * Replace the current <w:t> node with the specified xml markup.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData): void {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const value = data.getScopeData() as RawXmlContent;\r\n        if (value && typeof value.xml === 'string') {\r\n            const newNode = this.utilities.xmlParser.parse(value.xml);\r\n            XmlNode.insertBefore(newNode, wordTextNode);\r\n        }\r\n\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n}","import { ScopeData, Tag, TemplateCompiler, TemplateContext } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlParser } from '../xml';\r\n\r\nexport interface PluginUtilities {\r\n    compiler: TemplateCompiler;\r\n    docxParser: DocxParser;\r\n    xmlParser: XmlParser;\r\n}\r\n\r\n/* eslint-disable @typescript-eslint/member-ordering */\r\n\r\nexport abstract class TemplatePlugin {\r\n\r\n    /**\r\n     * The content type this plugin handles.\r\n     */\r\n    public abstract get contentType(): string;\r\n\r\n    protected utilities: PluginUtilities;\r\n\r\n    /**\r\n     * Called by the TemplateHandler at runtime.\r\n     */\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    /**\r\n     * This method is called for each self-closing tag.\r\n     * It should implement the specific document manipulation required by the tag.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): void | Promise<void> {\r\n        // noop\r\n    }\r\n\r\n    /**\r\n     * This method is called for each container tag. It should implement the\r\n     * specific document manipulation required by the tag.\r\n     *\r\n     * @param tags All tags between the opening tag and closing tag (inclusive,\r\n     * i.e. tags[0] is the opening tag and the last item in the tags array is\r\n     * the closing tag).\r\n     */\r\n    public containerTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): void | Promise<void> {\r\n        // noop\r\n    }\r\n}","import { ScopeData, Tag } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlAttribute, XmlGeneralNode, XmlNode, XmlTextNode } from '../xml';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport const TEXT_CONTENT_TYPE = 'text';\r\n\r\nexport class TextPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = TEXT_CONTENT_TYPE;\r\n\r\n    /**\r\n     * Replace the node text content with the specified value.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData): void {\r\n\r\n        const value = data.getScopeData();\r\n        const stringValue = (value === null || value === undefined) ? '' : value.toString();\r\n        const lines = stringValue.split('\\n');\r\n\r\n        if (lines.length < 2) {\r\n            this.replaceSingleLine(tag.xmlTextNode, lines.length ? lines[0] : '');\r\n        } else {\r\n            this.replaceMultiLine(tag.xmlTextNode, lines);\r\n        }\r\n    }\r\n\r\n    private replaceSingleLine(textNode: XmlTextNode, text: string) {\r\n\r\n        // set text\r\n        textNode.textContent = text;\r\n\r\n        // make sure leading and trailing whitespace are preserved\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(textNode) as XmlGeneralNode;\r\n        if (!wordTextNode.attributes) {\r\n            wordTextNode.attributes = [];\r\n        }\r\n        if (!wordTextNode.attributes.find(attr => attr.name === 'xml:space')) {\r\n            wordTextNode.attributes.push(this.getSpacePreserveAttribute());\r\n        }\r\n    }\r\n\r\n    private replaceMultiLine(textNode: XmlTextNode, lines: string[]) {\r\n\r\n        const runNode = this.utilities.docxParser.containingRunNode(textNode);\r\n\r\n        // first line\r\n        textNode.textContent = lines[0];\r\n\r\n        // other lines\r\n        for (let i = 1; i < lines.length; i++) {\r\n\r\n            // add line break\r\n            const lineBreak = this.getLineBreak();\r\n            XmlNode.appendChild(runNode, lineBreak);\r\n\r\n            // add text\r\n            const lineNode = this.createWordTextNode(lines[i]);\r\n            XmlNode.appendChild(runNode, lineNode);\r\n        }\r\n    }\r\n\r\n    private getSpacePreserveAttribute(): XmlAttribute {\r\n        return {\r\n            name: 'xml:space',\r\n            value: 'preserve'\r\n        };\r\n    }\r\n\r\n    private getLineBreak(): XmlNode {\r\n        return XmlNode.createGeneralNode('w:br');\r\n    }\r\n\r\n    private createWordTextNode(text: string): XmlNode {\r\n        const wordTextNode = XmlNode.createGeneralNode(DocxParser.TEXT_NODE);\r\n        wordTextNode.attributes = [this.getSpacePreserveAttribute()];\r\n        wordTextNode.childNodes = [\r\n            XmlNode.createTextNode(text)\r\n        ];\r\n        return wordTextNode;\r\n    }    \r\n}","import { DelimiterSearcher, ScopeData, Tag, TagParser, TemplateCompiler, TemplateContext } from './compilation';\r\nimport { MalformedFileError } from './errors';\r\nimport { Docx, DocxParser } from './office';\r\nimport { TemplateData } from './templateData';\r\nimport { TemplateHandlerOptions } from './templateHandlerOptions';\r\nimport { Binary } from './utils';\r\nimport { XmlNode, XmlParser } from './xml';\r\nimport { Zip } from './zip';\r\n\r\nexport class TemplateHandler {\r\n\r\n    private readonly xmlParser = new XmlParser();\r\n    private readonly docxParser: DocxParser;\r\n    private readonly compiler: TemplateCompiler;\r\n\r\n    private readonly options: TemplateHandlerOptions;\r\n\r\n    constructor(options?: TemplateHandlerOptions) {\r\n        this.options = new TemplateHandlerOptions(options);\r\n\r\n        //\r\n        // this is the library's composition root\r\n        //\r\n\r\n        this.docxParser = new DocxParser(this.xmlParser);\r\n\r\n        const delimiterSearcher = new DelimiterSearcher();\r\n        delimiterSearcher.startDelimiter = this.options.delimiters.tagStart;\r\n        delimiterSearcher.endDelimiter = this.options.delimiters.tagEnd;\r\n        delimiterSearcher.maxXmlDepth = this.options.maxXmlDepth;\r\n\r\n        const tagParser = new TagParser(this.docxParser, this.options.delimiters);\r\n\r\n        this.compiler = new TemplateCompiler(\r\n            delimiterSearcher,\r\n            tagParser,\r\n            this.options.plugins,\r\n            this.options.defaultContentType,\r\n            this.options.containerContentType\r\n        );\r\n\r\n        this.options.plugins.forEach(plugin => {\r\n            plugin.setUtilities({\r\n                xmlParser: this.xmlParser,\r\n                docxParser: this.docxParser,\r\n                compiler: this.compiler\r\n            });\r\n        });\r\n    }\r\n\r\n    public async process<T extends Binary>(templateFile: T, data: TemplateData): Promise<T> {\r\n\r\n        // load the docx file\r\n        const docx = await this.loadDocx(templateFile);\r\n        const document = await docx.getDocument();\r\n\r\n        // process content (do replacements)        \r\n        const scopeData = new ScopeData(data);\r\n        const context: TemplateContext = {\r\n            docx\r\n        };\r\n        await this.compiler.compile(document, scopeData, context);\r\n\r\n        // export the result\r\n        return docx.export(templateFile.constructor as Constructor<T>);\r\n    }\r\n\r\n    public async parseTags(templateFile: Binary): Promise<Tag[]> {\r\n        const docx = await this.loadDocx(templateFile);\r\n        const document = await docx.getDocument();\r\n        return this.compiler.parseTags(document);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of the main document file.\r\n     */\r\n    public async getText(docxFile: Binary): Promise<string> {\r\n        const docx = await this.loadDocx(docxFile);\r\n        const text = await docx.getDocumentText();\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Get the xml tree of the main document file.\r\n     */\r\n    public async getXml(docxFile: Binary): Promise<XmlNode> {\r\n        const docx = await this.loadDocx(docxFile);\r\n        const document = await docx.getDocument();\r\n        return document;\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private async loadDocx(file: Binary): Promise<Docx> {\r\n\r\n        // load the zip file\r\n        let zip: Zip;\r\n        try {\r\n            zip = await Zip.load(file);\r\n        } catch {\r\n            throw new MalformedFileError('docx');\r\n        }\r\n\r\n        // load the docx file\r\n        const docx = this.docxParser.load(zip);\r\n        return docx;\r\n    }\r\n}","import { Delimiters } from './delimiters';\r\nimport { createDefaultPlugins, LOOP_CONTENT_TYPE, TemplatePlugin, TEXT_CONTENT_TYPE } from './plugins';\r\n\r\nexport class TemplateHandlerOptions {\r\n\r\n    public plugins?: TemplatePlugin[] = createDefaultPlugins();\r\n\r\n    public defaultContentType = TEXT_CONTENT_TYPE;\r\n\r\n    public containerContentType = LOOP_CONTENT_TYPE;\r\n\r\n    public delimiters?= new Delimiters();\r\n\r\n    public maxXmlDepth? = 20;\r\n\r\n    constructor(initial?: Partial<TemplateHandlerOptions>) {\r\n        Object.assign(this, initial);\r\n\r\n        if (initial) {\r\n            this.delimiters = new Delimiters(initial.delimiters);\r\n        }\r\n\r\n        if (!this.plugins.length) {\r\n            throw new Error('Plugins list can not be empty');\r\n        }\r\n    }\r\n}","\r\nexport type ItemMapper<TIn, TOut = string> = (item: TIn, index: number) => TOut;\r\n\r\nexport function pushMany<T>(destArray: T[], items: T[]): void {\r\n    Array.prototype.push.apply(destArray, items);\r\n}\r\n\r\nexport function last<T>(array: T[]): T {\r\n    if (!array.length)\r\n        return undefined;\r\n    return array[array.length - 1];\r\n}\r\n\r\nexport function toDictionary<TIn, TOut = TIn>(array: TIn[], keySelector: ItemMapper<TIn>, valueSelector?: ItemMapper<TIn, TOut>): IMap<TOut> {\r\n    if (!array.length)\r\n        return {};\r\n\r\n    const res: IMap<any> = {};\r\n    array.forEach((item, index) => {\r\n        const key = keySelector(item, index);\r\n        const value = (valueSelector ? valueSelector(item, index) : item);\r\n        if (res[key])\r\n            throw new Error(`Key '${key}' already exists in the dictionary.`);\r\n        res[key] = value;\r\n    });\r\n    return res;\r\n};","export class Base64 {\r\n\r\n    public static encode(str: string): string {\r\n        \r\n        // browser\r\n        if (typeof btoa !== 'undefined') \r\n            return btoa(str);\r\n\r\n        // node\r\n        // https://stackoverflow.com/questions/23097928/node-js-btoa-is-not-defined-error#38446960\r\n        return new Buffer(str, 'binary').toString('base64');\r\n    }\r\n}","import { Base64 } from './base64';\r\nimport { inheritsFrom } from './types';\r\n\r\nexport type Binary = Blob | Buffer | ArrayBuffer;\r\n\r\nexport const Binary = {\r\n\r\n    //\r\n    // type detection\r\n    //\r\n\r\n    isBlob(binary: any): binary is Blob {\r\n        return this.isBlobConstructor(binary.constructor);\r\n    },\r\n\r\n    isArrayBuffer(binary: any): binary is ArrayBuffer {\r\n        return this.isArrayBufferConstructor(binary.constructor);\r\n    },\r\n\r\n    isBuffer(binary: any): binary is Buffer {\r\n        return this.isBufferConstructor(binary.constructor);\r\n    },\r\n\r\n    isBlobConstructor(binaryType: Constructor<any>): binaryType is Constructor<Blob> {\r\n        return (typeof Blob !== 'undefined' && inheritsFrom(binaryType, Blob));\r\n    },\r\n\r\n    isArrayBufferConstructor(binaryType: Constructor<any>): binaryType is Constructor<ArrayBuffer> {\r\n        return (typeof ArrayBuffer !== 'undefined' && inheritsFrom(binaryType, ArrayBuffer));\r\n    },\r\n\r\n    isBufferConstructor(binaryType: Constructor<any>): binaryType is Constructor<Buffer> {\r\n        return (typeof Buffer !== 'undefined' && inheritsFrom(binaryType, Buffer));\r\n    },\r\n\r\n    //\r\n    // utilities\r\n    //\r\n\r\n    toBase64(binary: Binary): Promise<string> {\r\n\r\n        if (this.isBlob(binary)) {\r\n            return new Promise(resolve => {\r\n                const fileReader = new FileReader();\r\n                fileReader.onload = function () {\r\n                    const base64 = Base64.encode(this.result as string);\r\n                    resolve(base64);\r\n                };\r\n                fileReader.readAsBinaryString(binary);\r\n            });\r\n        }\r\n\r\n        if (this.isBuffer(binary)) {\r\n            return Promise.resolve(binary.toString('base64'));\r\n        }\r\n\r\n        if (this.isArrayBuffer(binary)) {\r\n            // https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string#42334410\r\n            const binaryStr = new Uint8Array(binary).reduce((str, byte) => str + String.fromCharCode(byte), '');\r\n            const base64 = Base64.encode(binaryStr);\r\n            return Promise.resolve(base64);\r\n        }\r\n\r\n        throw new Error(`Binary type '${(binary as any).constructor.name}' is not supported.`);\r\n    }\r\n};\r\n\r\n","export * from './array';\r\nexport * from './base64';\r\nexport * from './binary';\r\nexport * from './path';\r\nexport * from './sha1';\r\nexport * from './types';\r\n","export class Path {\r\n\r\n    public static getFilename(path: string): string {\r\n        const lastSlashIndex = path.lastIndexOf('/');\r\n        return path.substr(lastSlashIndex + 1);\r\n    }\r\n\r\n    public static getDirectory(path: string): string {\r\n        const lastSlashIndex = path.lastIndexOf('/');\r\n        return path.substring(0, lastSlashIndex);\r\n    }\r\n}","/**\r\n * Secure Hash Algorithm (SHA1)\r\n * \r\n * Taken from here: http://www.webtoolkit.info/javascript-sha1.html\r\n * \r\n * Recommended here: https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript#6122732\r\n */\r\nexport function sha1(msg: string) {\r\n\r\n    msg = utf8Encode(msg);\r\n    const msgLength = msg.length;\r\n\r\n    let i, j;\r\n\r\n    const wordArray = [];\r\n    for (i = 0; i < msgLength - 3; i += 4) {\r\n        j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 |\r\n            msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);\r\n        wordArray.push(j);\r\n    }\r\n\r\n    switch (msgLength % 4) {\r\n        case 0:\r\n            i = 0x080000000;\r\n            break;\r\n        case 1:\r\n            i = msg.charCodeAt(msgLength - 1) << 24 | 0x0800000;\r\n            break;\r\n        case 2:\r\n            i = msg.charCodeAt(msgLength - 2) << 24 | msg.charCodeAt(msgLength - 1) << 16 | 0x08000;\r\n            break;\r\n        case 3:\r\n            i = msg.charCodeAt(msgLength - 3) << 24 | msg.charCodeAt(msgLength - 2) << 16 | msg.charCodeAt(msgLength - 1) << 8 | 0x80;\r\n            break;\r\n    }\r\n    wordArray.push(i);\r\n\r\n    while ((wordArray.length % 16) != 14) {\r\n        wordArray.push(0);\r\n    }\r\n\r\n    wordArray.push(msgLength >>> 29);\r\n    wordArray.push((msgLength << 3) & 0x0ffffffff);\r\n\r\n    const w = new Array(80);\r\n    let H0 = 0x67452301;\r\n    let H1 = 0xEFCDAB89;\r\n    let H2 = 0x98BADCFE;\r\n    let H3 = 0x10325476;\r\n    let H4 = 0xC3D2E1F0;\r\n    let A, B, C, D, E;\r\n    let temp;\r\n    for (let blockStart = 0; blockStart < wordArray.length; blockStart += 16) {\r\n\r\n        for (i = 0; i < 16; i++) {\r\n            w[i] = wordArray[blockStart + i];\r\n        }\r\n        for (i = 16; i <= 79; i++) {\r\n            w[i] = rotateLeft(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);\r\n        }\r\n        A = H0;\r\n        B = H1;\r\n        C = H2;\r\n        D = H3;\r\n        E = H4;\r\n        for (i = 0; i <= 19; i++) {\r\n            temp = (rotateLeft(A, 5) + ((B & C) | (~B & D)) + E + w[i] + 0x5A827999) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 20; i <= 39; i++) {\r\n            temp = (rotateLeft(A, 5) + (B ^ C ^ D) + E + w[i] + 0x6ED9EBA1) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 40; i <= 59; i++) {\r\n            temp = (rotateLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + w[i] + 0x8F1BBCDC) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 60; i <= 79; i++) {\r\n            temp = (rotateLeft(A, 5) + (B ^ C ^ D) + E + w[i] + 0xCA62C1D6) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        H0 = (H0 + A) & 0x0ffffffff;\r\n        H1 = (H1 + B) & 0x0ffffffff;\r\n        H2 = (H2 + C) & 0x0ffffffff;\r\n        H3 = (H3 + D) & 0x0ffffffff;\r\n        H4 = (H4 + E) & 0x0ffffffff;\r\n    }\r\n    temp = cvtHex(H0) + cvtHex(H1) + cvtHex(H2) + cvtHex(H3) + cvtHex(H4);\r\n    return temp.toLowerCase();\r\n}\r\n\r\nfunction rotateLeft(n: any, s: any) {\r\n    const t4 = (n << s) | (n >>> (32 - s));\r\n    return t4;\r\n}\r\n\r\nfunction cvtHex(val: any) {\r\n    let str = \"\";\r\n    for (let i = 7; i >= 0; i--) {\r\n        const v = (val >>> (i * 4)) & 0x0f;\r\n        str += v.toString(16);\r\n    }\r\n    return str;\r\n}\r\n\r\nfunction utf8Encode(str: string) {\r\n    str = str.replace(/\\r\\n/g, \"\\n\");\r\n    let utfStr = \"\";\r\n    for (let n = 0; n < str.length; n++) {\r\n        const c = str.charCodeAt(n);\r\n        if (c < 128) {\r\n            utfStr += String.fromCharCode(c);\r\n\r\n        } else if ((c > 127) && (c < 2048)) {\r\n            utfStr += String.fromCharCode((c >> 6) | 192);\r\n            utfStr += String.fromCharCode((c & 63) | 128);\r\n\r\n        } else {\r\n            utfStr += String.fromCharCode((c >> 12) | 224);\r\n            utfStr += String.fromCharCode(((c >> 6) & 63) | 128);\r\n            utfStr += String.fromCharCode((c & 63) | 128);\r\n        }\r\n    }\r\n    return utfStr;\r\n}\r\n","\r\nexport function inheritsFrom(derived: Constructor<any>, base: Constructor<any>): boolean {\r\n    // https://stackoverflow.com/questions/14486110/how-to-check-if-a-javascript-class-inherits-another-without-creating-an-obj\r\n    return derived === base || derived.prototype instanceof base;\r\n}\r\n\r\nexport function isPromiseLike<T>(candidate: any): candidate is PromiseLike<T> {\r\n    return !!candidate && typeof candidate === 'object' && typeof candidate.then === 'function';\r\n}","export * from './xmlNode';\r\nexport * from './xmlParser';\r\n","import { MissingArgumentError } from '../errors';\r\nimport { last } from '../utils';\r\n\r\nexport enum XmlNodeType {\r\n    Text = \"Text\",\r\n    General = \"General\"\r\n}\r\n\r\nexport type XmlNode = XmlTextNode | XmlGeneralNode;\r\n\r\nexport interface XmlNodeBase {\r\n    nodeType: XmlNodeType;\r\n    nodeName: string;\r\n    parentNode?: XmlNode;\r\n    childNodes?: XmlNode[];\r\n    nextSibling?: XmlNode;\r\n}\r\n\r\nexport const TEXT_NODE_NAME = '#text'; // see: https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName\r\n\r\nexport interface XmlTextNode extends XmlNodeBase {\r\n    nodeType: XmlNodeType.Text;\r\n    nodeName: typeof TEXT_NODE_NAME;\r\n    textContent: string;\r\n}\r\n\r\nexport interface XmlGeneralNode extends XmlNodeBase {\r\n    nodeType: XmlNodeType.General;\r\n    attributes?: XmlAttribute[];\r\n}\r\n\r\nexport interface XmlAttribute {\r\n    name: string;\r\n    value: string;\r\n}\r\n\r\nexport const XmlNode = {\r\n\r\n    //\r\n    // factories\r\n    //\r\n\r\n    createTextNode(text?: string): XmlTextNode {\r\n        return {\r\n            nodeType: XmlNodeType.Text,\r\n            nodeName: TEXT_NODE_NAME,\r\n            textContent: text\r\n        };\r\n    },\r\n\r\n    createGeneralNode(name: string): XmlGeneralNode {\r\n        return {\r\n            nodeType: XmlNodeType.General,\r\n            nodeName: name\r\n        };\r\n    },\r\n\r\n    //\r\n    // serialization\r\n    //\r\n\r\n    /**\r\n     * Encode string to make it safe to use inside xml tags.\r\n     * \r\n     * https://stackoverflow.com/questions/7918868/how-to-escape-xml-entities-in-javascript\r\n     */\r\n    encodeValue(str: string): string {\r\n        if (str === null || str === undefined)\r\n            throw new MissingArgumentError(nameof(str));\r\n        if (typeof str !== 'string')\r\n            throw new TypeError(`Expected a string, got '${(str as any).constructor.name}'.`);\r\n\r\n        return str.replace(/[<>&'\"]/g, c => {\r\n            switch (c) {\r\n                case '<': return '&lt;';\r\n                case '>': return '&gt;';\r\n                case '&': return '&amp;';\r\n                case '\\'': return '&apos;';\r\n                case '\"': return '&quot;';\r\n            }\r\n            return '';\r\n        });\r\n    },\r\n\r\n    serialize(node: XmlNode): string {\r\n        if (this.isTextNode(node))\r\n            return this.encodeValue(node.textContent || '');\r\n\r\n        // attributes\r\n        let attributes = '';\r\n        if (node.attributes && node.attributes.length) {\r\n            attributes = ' ' + node.attributes\r\n                .map(attr => `${attr.name}=\"${attr.value}\"`)\r\n                .join(' ');\r\n        }\r\n\r\n        // open tag\r\n        const hasChildren = (node.childNodes || []).length > 0;\r\n        const suffix = hasChildren ? '' : '/';\r\n        const openTag = `<${node.nodeName}${attributes}${suffix}>`;\r\n\r\n        let xml: string;\r\n\r\n        if (hasChildren) {\r\n\r\n            // child nodes\r\n            const childrenXml = node.childNodes\r\n                .map(child => this.serialize(child))\r\n                .join('');\r\n\r\n            // close tag\r\n            const closeTag = `</${node.nodeName}>`;\r\n\r\n            xml = openTag + childrenXml + closeTag;\r\n        } else {\r\n            xml = openTag;\r\n        }\r\n\r\n        return xml;\r\n    },\r\n\r\n    /**\r\n     * The conversion is always deep.\r\n     */\r\n    fromDomNode(domNode: Node): XmlNode {\r\n        let xmlNode: XmlNode;\r\n\r\n        // basic properties\r\n        if (domNode.nodeType === domNode.TEXT_NODE) {\r\n\r\n            xmlNode = this.createTextNode(domNode.textContent);\r\n\r\n        } else {\r\n\r\n            xmlNode = this.createGeneralNode(domNode.nodeName);\r\n\r\n            // attributes\r\n            if (domNode.nodeType === domNode.ELEMENT_NODE) {\r\n                const attributes = (domNode as Element).attributes;\r\n                if (attributes) {\r\n                    (xmlNode as XmlGeneralNode).attributes = [];\r\n                    for (let i = 0; i < attributes.length; i++) {\r\n                        const curAttribute = attributes.item(i);\r\n                        (xmlNode as XmlGeneralNode).attributes.push({\r\n                            name: curAttribute.name,\r\n                            value: curAttribute.value\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // children\r\n        if (domNode.childNodes) {\r\n            xmlNode.childNodes = [];\r\n            let prevChild: XmlNode;\r\n            for (let i = 0; i < domNode.childNodes.length; i++) {\r\n\r\n                // clone child\r\n                const domChild = domNode.childNodes.item(i);\r\n                const curChild = this.fromDomNode(domChild);\r\n\r\n                // set references                \r\n                xmlNode.childNodes.push(curChild);\r\n                curChild.parentNode = xmlNode;\r\n                if (prevChild) {\r\n                    prevChild.nextSibling = curChild;\r\n                }\r\n                prevChild = curChild;\r\n            }\r\n        }\r\n\r\n        return xmlNode as XmlNode;\r\n    },\r\n\r\n    //\r\n    // core functions\r\n    //\r\n\r\n    isTextNode(node: XmlNode): node is XmlTextNode {\r\n        if (node.nodeType === XmlNodeType.Text || node.nodeName === TEXT_NODE_NAME) {\r\n            if (!(node.nodeType === XmlNodeType.Text && node.nodeName === TEXT_NODE_NAME)) {\r\n                throw new Error(`Invalid text node. Type: '${node.nodeType}', Name: '${node.nodeName}'.`);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    cloneNode(node: XmlNode, deep: boolean): XmlNode {\r\n        if (!node)\r\n            throw new MissingArgumentError(nameof(node));\r\n\r\n        if (!deep) {\r\n            const clone = Object.assign({}, node);\r\n            clone.parentNode = null;\r\n            clone.childNodes = (node.childNodes ? [] : null);\r\n            clone.nextSibling = null;\r\n            return clone;\r\n        } else {\r\n            const clone = cloneNodeDeep(node);\r\n            clone.parentNode = null;\r\n            return clone;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Insert the node as a new sibling, before the original node.\r\n     *\r\n     * * **Note**: It is more efficient to use the insertChild function if you\r\n     *   already know the relevant index.\r\n     */\r\n    insertBefore(newNode: XmlNode, referenceNode: XmlNode): void {\r\n        if (!newNode)\r\n            throw new MissingArgumentError(nameof(newNode));\r\n        if (!referenceNode)\r\n            throw new MissingArgumentError(nameof(referenceNode));\r\n\r\n        if (!referenceNode.parentNode)\r\n            throw new Error(`'${nameof(referenceNode)}' has no parent`);\r\n\r\n        const childNodes = referenceNode.parentNode.childNodes;\r\n        const beforeNodeIndex = childNodes.indexOf(referenceNode);\r\n        XmlNode.insertChild(referenceNode.parentNode, newNode, beforeNodeIndex);\r\n    },\r\n\r\n    /**\r\n     * Insert the node as a new sibling, after the original node.\r\n     *\r\n     * * **Note**: It is more efficient to use the insertChild function if you\r\n     *   already know the relevant index.\r\n     */\r\n    insertAfter(newNode: XmlNode, referenceNode: XmlNode): void {\r\n        if (!newNode)\r\n            throw new MissingArgumentError(nameof(newNode));\r\n        if (!referenceNode)\r\n            throw new MissingArgumentError(nameof(referenceNode));\r\n\r\n        if (!referenceNode.parentNode)\r\n            throw new Error(`'${nameof(referenceNode)}' has no parent`);\r\n\r\n        const childNodes = referenceNode.parentNode.childNodes;\r\n        const referenceNodeIndex = childNodes.indexOf(referenceNode);\r\n        XmlNode.insertChild(referenceNode.parentNode, newNode, referenceNodeIndex + 1);\r\n    },\r\n\r\n    insertChild(parent: XmlNode, child: XmlNode, childIndex: number): void {\r\n        if (!parent)\r\n            throw new MissingArgumentError(nameof(parent));\r\n        if (XmlNode.isTextNode(parent))\r\n            throw new Error('Appending children to text nodes is forbidden');\r\n        if (!child)\r\n            throw new MissingArgumentError(nameof(child));\r\n\r\n        if (!parent.childNodes)\r\n            parent.childNodes = [];\r\n\r\n        // revert to append\r\n        if (childIndex === parent.childNodes.length) {\r\n            XmlNode.appendChild(parent, child);\r\n            return;\r\n        }\r\n\r\n        if (childIndex > parent.childNodes.length)\r\n            throw new RangeError(`Child index ${childIndex} is out of range. Parent has only ${parent.childNodes.length} child nodes.`);\r\n\r\n        // update references\r\n        child.parentNode = parent;\r\n\r\n        const childAfter = parent.childNodes[childIndex];\r\n        child.nextSibling = childAfter;\r\n\r\n        if (childIndex > 0) {\r\n            const childBefore = parent.childNodes[childIndex - 1];\r\n            childBefore.nextSibling = child;\r\n        }\r\n\r\n        // append\r\n        parent.childNodes.splice(childIndex, 0, child);\r\n    },\r\n\r\n    appendChild(parent: XmlNode, child: XmlNode): void {\r\n        if (!parent)\r\n            throw new MissingArgumentError(nameof(parent));\r\n        if (XmlNode.isTextNode(parent))\r\n            throw new Error('Appending children to text nodes is forbidden');\r\n        if (!child)\r\n            throw new MissingArgumentError(nameof(child));\r\n\r\n        if (!parent.childNodes)\r\n            parent.childNodes = [];\r\n\r\n        // update references\r\n        if (parent.childNodes.length) {\r\n            const currentLastChild = parent.childNodes[parent.childNodes.length - 1];\r\n            currentLastChild.nextSibling = child;\r\n        }\r\n        child.nextSibling = null;\r\n        child.parentNode = parent;\r\n\r\n        // append\r\n        parent.childNodes.push(child);\r\n    },\r\n\r\n    /**\r\n     * Removes the node from it's parent.\r\n     * \r\n     * * **Note**: It is more efficient to call removeChild(parent, childIndex).\r\n     */\r\n    remove(node: XmlNode): void {\r\n        if (!node)\r\n            throw new MissingArgumentError(nameof(node));\r\n\r\n        if (!node.parentNode)\r\n            throw new Error('Node has no parent');\r\n\r\n        removeChild(node.parentNode, node);\r\n    },\r\n\r\n    removeChild,\r\n\r\n    //\r\n    // utility functions\r\n    //    \r\n\r\n    /**\r\n     * Gets the last direct child text node if it exists. Otherwise creates a\r\n     * new text node, appends it to 'node' and return the newly created text\r\n     * node.\r\n     *\r\n     * The function also makes sure the returned text node has a valid string\r\n     * value.\r\n     */\r\n    lastTextChild(node: XmlNode): XmlTextNode {\r\n        if (XmlNode.isTextNode(node)) {\r\n            return node;\r\n        }\r\n\r\n        // existing text nodes\r\n        if (node.childNodes) {\r\n            const allTextNodes = node.childNodes.filter(child => XmlNode.isTextNode(child)) as XmlTextNode[];\r\n            if (allTextNodes.length) {\r\n                const lastTextNode = last(allTextNodes);\r\n                if (!lastTextNode.textContent)\r\n                    lastTextNode.textContent = '';\r\n                return lastTextNode;\r\n            }\r\n        }\r\n\r\n        // create new text node\r\n        const newTextNode: XmlTextNode = {\r\n            nodeType: XmlNodeType.Text,\r\n            nodeName: TEXT_NODE_NAME,\r\n            textContent: ''\r\n        };\r\n\r\n        XmlNode.appendChild(node, newTextNode);\r\n        return newTextNode;\r\n    },\r\n\r\n    /**\r\n     * Remove sibling nodes between 'from' and 'to' excluding both.\r\n     * Return the removed nodes.\r\n     */\r\n    removeSiblings(from: XmlNode, to: XmlNode): XmlNode[] {\r\n        if (from === to)\r\n            return [];\r\n\r\n        const removed: XmlNode[] = [];\r\n        let lastRemoved: XmlNode;\r\n        from = from.nextSibling;\r\n        while (from !== to) {\r\n            const removeMe = from;\r\n            from = from.nextSibling;\r\n\r\n            XmlNode.remove(removeMe);\r\n            removed.push(removeMe);\r\n\r\n            if (lastRemoved)\r\n                lastRemoved.nextSibling = removeMe;\r\n            lastRemoved = removeMe;\r\n        }\r\n\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Split the original node into two sibling nodes.\r\n     * Returns both nodes.\r\n     *\r\n     * @param root The node to split\r\n     * @param markerNode The node that marks the split position.      \r\n     */\r\n    splitByChild(root: XmlNode, markerNode: XmlNode, removeMarkerNode: boolean): [XmlNode, XmlNode] {\r\n\r\n        // find the split path\r\n        const path = getDescendantPath(root, markerNode);\r\n\r\n        // split\r\n        const split = XmlNode.cloneNode(root, false);\r\n        const childIndex = path[0] + 1;\r\n        while (childIndex < root.childNodes.length) {\r\n            const curChild = root.childNodes[childIndex];\r\n            XmlNode.remove(curChild);\r\n            XmlNode.appendChild(split, curChild);\r\n        }\r\n\r\n        if (root.parentNode) {\r\n            XmlNode.insertAfter(split, root);\r\n        }\r\n\r\n        // remove marker node\r\n        if (removeMarkerNode && root.childNodes.length) {\r\n            XmlNode.removeChild(root, root.childNodes.length - 1);\r\n        }\r\n\r\n        return [root, split];\r\n    },\r\n\r\n    findParent(node: XmlNode, predicate: (node: XmlNode) => boolean): XmlNode {\r\n        if (!node)\r\n            return null;\r\n\r\n        while (node.parentNode) {\r\n\r\n            if (predicate(node))\r\n                return node;\r\n\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    findParentByName(node: XmlNode, nodeName: string): XmlNode {\r\n        return XmlNode.findParent(node, n => n.nodeName === nodeName);\r\n    },\r\n\r\n    findChildByName(node: XmlNode, childName: string): XmlNode {\r\n        if (!node)\r\n            return null;\r\n        return (node.childNodes || []).find(child => child.nodeName === childName);\r\n    },\r\n\r\n    /**\r\n     * Returns all siblings between 'firstNode' and 'lastNode' inclusive.\r\n     */\r\n    siblingsInRange(firstNode: XmlNode, lastNode: XmlNode): XmlNode[] {\r\n        if (!firstNode)\r\n            throw new MissingArgumentError(nameof(firstNode));\r\n        if (!lastNode)\r\n            throw new MissingArgumentError(nameof(lastNode));\r\n\r\n        const range: XmlNode[] = [];\r\n        let curNode = firstNode;\r\n        while (curNode && curNode !== lastNode) {\r\n            range.push(curNode);\r\n            curNode = curNode.nextSibling;\r\n        }\r\n\r\n        if (!curNode)\r\n            throw new Error('Nodes are not siblings.');\r\n\r\n        range.push(lastNode);\r\n        return range;\r\n    },\r\n\r\n    /**\r\n     * Recursively removes text nodes leaving only \"general nodes\".\r\n     */\r\n    stripTextNodes(node: XmlGeneralNode): void {\r\n        recursiveStripTextNodes(node);\r\n    },\r\n};\r\n\r\n//\r\n// overloaded functions\r\n//\r\n\r\n/**\r\n * Remove a child node from it's parent. Returns the removed child.\r\n * \r\n * * **Note:** Prefer calling with explicit index.\r\n */\r\nfunction removeChild(parent: XmlNode, child: XmlNode): XmlNode;\r\n/**\r\n * Remove a child node from it's parent. Returns the removed child.\r\n */\r\nfunction removeChild(parent: XmlNode, childIndex: number): XmlNode;\r\nfunction removeChild(parent: XmlNode, childOrIndex: XmlNode | number): XmlNode {\r\n    if (!parent)\r\n        throw new MissingArgumentError(nameof(parent));\r\n    if (childOrIndex === null || childOrIndex === undefined)\r\n        throw new MissingArgumentError(nameof(childOrIndex));\r\n\r\n    if (!parent.childNodes || !parent.childNodes.length)\r\n        throw new Error('Parent node has node children');\r\n\r\n    // get child index\r\n    let childIndex: number;\r\n    if (typeof childOrIndex === 'number') {\r\n        childIndex = childOrIndex;\r\n    } else {\r\n        childIndex = parent.childNodes.indexOf(childOrIndex);\r\n        if (childIndex === -1)\r\n            throw new Error('Specified child node is not a child of the specified parent');\r\n    }\r\n\r\n    if (childIndex >= parent.childNodes.length)\r\n        throw new RangeError(`Child index ${childIndex} is out of range. Parent has only ${parent.childNodes.length} child nodes.`);\r\n\r\n    // update references\r\n    const child = parent.childNodes[childIndex];\r\n    if (childIndex > 0) {\r\n        const beforeChild = parent.childNodes[childIndex - 1];\r\n        beforeChild.nextSibling = child.nextSibling;\r\n    }\r\n    child.parentNode = null;\r\n    child.nextSibling = null;\r\n\r\n    // remove and return\r\n    return parent.childNodes.splice(childIndex, 1)[0];\r\n}\r\n\r\n//\r\n// private functions\r\n//\r\n\r\nfunction cloneNodeDeep(original: XmlNode): XmlNode {\r\n\r\n    const clone: XmlNode = ({} as any);\r\n\r\n    // basic properties\r\n    clone.nodeType = original.nodeType;\r\n    clone.nodeName = original.nodeName;\r\n    if (XmlNode.isTextNode(original)) {\r\n        (clone as XmlTextNode).textContent = original.textContent;\r\n    } else {\r\n        const attributes = original.attributes;\r\n        if (attributes) {\r\n            (clone as XmlGeneralNode).attributes = attributes.map(attr => ({ name: attr.name, value: attr.value }));\r\n        }\r\n    }\r\n\r\n    // children\r\n    if (original.childNodes) {\r\n        clone.childNodes = [];\r\n        let prevChildClone: XmlNode;\r\n        for (const child of original.childNodes) {\r\n\r\n            // clone child\r\n            const childClone = cloneNodeDeep(child);\r\n\r\n            // set references                \r\n            clone.childNodes.push(childClone);\r\n            childClone.parentNode = clone;\r\n            if (prevChildClone) {\r\n                prevChildClone.nextSibling = childClone;\r\n            }\r\n            prevChildClone = childClone;\r\n        }\r\n    }\r\n\r\n    return clone;\r\n}\r\n\r\nfunction getDescendantPath(root: XmlNode, descendant: XmlNode): number[] {\r\n    const path: number[] = [];\r\n\r\n    let node = descendant;\r\n    while (node !== root) {\r\n        const parent = node.parentNode;\r\n        if (!parent)\r\n            throw new Error(`Argument ${nameof(descendant)} is not a descendant of ${nameof(root)}`);\r\n\r\n        const curChildIndex = parent.childNodes.indexOf(node);\r\n        path.push(curChildIndex);\r\n\r\n        node = parent;\r\n    }\r\n\r\n    return path.reverse();\r\n}\r\n\r\nfunction recursiveStripTextNodes(node: XmlGeneralNode): XmlGeneralNode {\r\n\r\n    if (!node.childNodes)\r\n        return node;\r\n\r\n    const oldChildren = node.childNodes;\r\n    node.childNodes = [];\r\n    for (const child of oldChildren) {\r\n        if (XmlNode.isTextNode(child))\r\n            continue;\r\n        const strippedChild = recursiveStripTextNodes(child);\r\n        node.childNodes.push(strippedChild);\r\n    }\r\n\r\n    return node;\r\n}","import * as xmldom from 'xmldom';\r\nimport { MissingArgumentError } from '../errors';\r\nimport { XmlNode } from './xmlNode';\r\n\r\nexport class XmlParser {\r\n\r\n    private static xmlHeader = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>';\r\n    /**\r\n     * We always use the DOMParser from 'xmldom', even in the browser since it\r\n     * handles xml namespaces more forgivingly (required mainly by the\r\n     * RawXmlPlugin).\r\n     */\r\n    private static readonly parser = new xmldom.DOMParser();\r\n\r\n    public parse(str: string): XmlNode {\r\n        const doc = this.domParse(str);\r\n        return XmlNode.fromDomNode(doc.documentElement);\r\n    }\r\n\r\n    public domParse(str: string): Document {\r\n        if (str === null || str === undefined)\r\n            throw new MissingArgumentError(nameof(str));\r\n\r\n        return XmlParser.parser.parseFromString(str, \"text/xml\");\r\n    }\r\n\r\n    public serialize(xmlNode: XmlNode): string {\r\n        return XmlParser.xmlHeader + XmlNode.serialize(xmlNode);\r\n    }    \r\n}\r\n","export * from './zip';\r\nexport * from './zipObject';\r\n","import * as JSZip from 'jszip';\r\nimport { MissingArgumentError } from '../errors';\r\nimport { Binary } from '../utils';\r\n\r\nexport class JsZipHelper {\r\n\r\n    public static toJsZipOutputType(binary: Binary): JSZip.OutputType;\r\n    public static toJsZipOutputType(binaryType: Constructor<Binary>): JSZip.OutputType;\r\n    public static toJsZipOutputType(binaryOrType: Binary | Constructor<Binary>): JSZip.OutputType {\r\n\r\n        if (!binaryOrType)\r\n            throw new MissingArgumentError(nameof(binaryOrType));\r\n\r\n        let binaryType: Constructor<Binary>;\r\n        if (typeof binaryOrType === 'function') {\r\n            binaryType = binaryOrType as Constructor<Binary>;\r\n        } else {\r\n            binaryType = binaryOrType.constructor as Constructor<Binary>;\r\n        }\r\n\r\n        if (Binary.isBlobConstructor(binaryType))\r\n            return 'blob';\r\n        if (Binary.isArrayBufferConstructor(binaryType))\r\n            return 'arraybuffer';\r\n        if (Binary.isBufferConstructor(binaryType))\r\n            return 'nodebuffer';\r\n\r\n        throw new Error(`Binary type '${binaryType.name}' is not supported.`);\r\n    };\r\n}","import * as JSZip from 'jszip';\r\nimport { Binary } from '../utils';\r\nimport { JsZipHelper } from './jsZipHelper';\r\nimport { ZipObject } from './zipObject';\r\n\r\nexport class Zip {\r\n\r\n    public static async load(file: Binary): Promise<Zip> {\r\n        const zip = await JSZip.loadAsync(file);\r\n        return new Zip(zip);\r\n    }\r\n\r\n    private constructor(private readonly zip: JSZip) {\r\n    }\r\n\r\n    public getFile(path: string): ZipObject {\r\n        return new ZipObject(this.zip.files[path]);\r\n    }\r\n\r\n    public setFile(path: string, content: string | Binary): void {\r\n        this.zip.file(path, content);\r\n    }\r\n\r\n    public isFileExist(path: string): boolean {\r\n        return !!this.zip.files[path];\r\n    }\r\n\r\n    public listFiles(): string[] {\r\n        return Object.keys(this.zip.files);\r\n    }\r\n\r\n    public async export<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        const zipOutputType: JSZip.OutputType = JsZipHelper.toJsZipOutputType(outputType);\r\n        const output = await this.zip.generateAsync({\r\n            type: zipOutputType,\r\n            compression: \"DEFLATE\",\r\n            compressionOptions: {\r\n                level: 6 // between 1 (best speed) and 9 (best compression)\r\n            }\r\n        });\r\n        return output as T;\r\n    }\r\n}","import * as JSZip from 'jszip';\r\nimport { Binary } from '../utils';\r\nimport { JsZipHelper } from './jsZipHelper';\r\n\r\nexport class ZipObject {\r\n\r\n    public get name(): string {\r\n        return this.zipObject.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this.zipObject.name = value;\r\n    }\r\n\r\n    public get isDirectory(): boolean {\r\n        return this.zipObject.dir;\r\n    }\r\n\r\n    constructor(private readonly zipObject: JSZip.JSZipObject) { }\r\n\r\n    public getContentText(): Promise<string> {\r\n        return this.zipObject.async('text');\r\n    }\r\n    \r\n    public getContentBase64(): Promise<string> {\r\n        return this.zipObject.async('binarystring');\r\n    }\r\n\r\n    public getContentBinary<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        const zipOutputType: JSZip.OutputType = JsZipHelper.toJsZipOutputType(outputType);\r\n        return this.zipObject.async(zipOutputType) as any;\r\n    }\r\n}","module.exports = require(\"base64-js\");","module.exports = require(\"ieee754\");","module.exports = require(\"isarray\");","module.exports = require(\"jszip\");","module.exports = require(\"lodash.get\");","module.exports = require(\"xmldom\");"],"sourceRoot":""}
