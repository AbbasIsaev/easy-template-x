{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\node_modules\\buffer\\index.js","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\node_modules\\webpack\\buildin\\global.js","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\delimiterSearcher.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\scopeData.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\tag.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\tagParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\templateCompiler.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\delimiters.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\malformedFileError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\maxXmlDepthError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingArgumentError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingCloseDelimiterError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingStartDelimiterError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unclosedTagError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unidentifiedFileTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unknownContentTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unopenedTagError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unsupportedFileTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\mimeType.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\contentTypesFile.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\docx.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\docxParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\mediaFiles.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\rels.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\defaultPlugins.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\imagePlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\linkPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopListStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopParagraphStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopTableStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loopPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\pluginContent.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\rawXmlPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\templatePlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\textPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\templateHandler.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\templateHandlerOptions.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\array.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\base64.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\binary.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\path.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\sha1.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\types.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlDepthTracker.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlNode.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\jsZipHelper.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\zip.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\zipObject.ts","external \"base64-js\"","external \"ieee754\"","external \"isarray\"","external \"jszip\"","external \"lodash.get\"","external \"xmldom\""],"names":["MatchState","reset","delimiterIndex","openNodes","firstMatchIndex","DelimiterSearcher","constructor","docxParser","MissingArgumentError","findDelimiters","node","delimiters","match","depth","XmlDepthTracker","maxXmlDepth","lookForOpenDelimiter","isParagraphNode","shouldSearchNode","findNextNode","push","textIndex","textContent","length","delimiterPattern","startDelimiter","endDelimiter","char","firstNode","lastNode","joinTextNodesRange","delimiterMark","createDelimiterMark","XmlNode","isTextNode","parentNode","childNodes","increment","nextSibling","decrement","isOpenDelimiter","index","isOpen","xmlTextNode","getProp","require","ScopeData","data","allData","getScopeData","lastKey","path","result","curPath","slice","undefined","curScopePath","concat","TagDisposition","TagParser","docParser","tagRegex","RegExp","tagStart","tagEnd","parse","tags","openedTag","openedDelimiter","i","delimiter","closeTagText","MissingStartDelimiterError","openTagText","MissingCloseDelimiterError","normalizeTagNodes","processTag","openDelimiter","closeDelimiter","closeDelimiterIndex","allDelimiters","startTextNode","endTextNode","sameNode","splitTextNode","updated","curDelimiter","tag","rawText","tagParts","exec","tagContent","trim","disposition","SelfClosed","containerTagOpen","Open","name","containerTagClose","Close","TemplateCompiler","delimiterSearcher","tagParser","plugins","defaultContentType","containerContentType","pluginsLookup","p","contentType","compile","context","parseTags","doTagReplacements","tagIndex","detectContentType","plugin","UnknownContentTypeError","join","job","simpleTagReplacements","closingTagIndex","findCloseTagIndex","scopeTags","containerTagReplacements","pop","scopeData","PluginContent","isPluginContent","_type","fromIndex","openTag","closeTag","UnclosedTagError","Delimiters","initial","Object","assign","encodeAndValidate","Error","keys","key","value","encodeValue","MalformedFileError","expectedFileType","setPrototypeOf","prototype","MaxXmlDepthError","maxDepth","argName","openDelimiterText","closeDelimiterText","tagName","UnidentifiedFileTypeError","tagRawText","UnopenedTagError","UnsupportedFileTypeError","fileType","MimeType","MimeTypeHelper","getDefaultExtension","mime","Png","Jpeg","Gif","Bmp","Svg","getOfficeRelType","ContentTypesFile","zip","xmlParser","ensureContentType","parseContentTypesFile","contentTypes","extension","typeNode","createGeneralNode","attributes","root","addedNew","count","filter","save","xmlContent","serialize","setFile","contentTypesFilePath","contentTypesXml","getFile","getContentText","nodeName","genNode","contentTypeAttribute","Docx","documentPath","_documentPath","isFileExist","rels","Rels","mediaFiles","MediaFiles","getDocument","_document","xml","getDocumentText","xmlDocument","domDocument","domParse","documentElement","export","outputType","saveChanges","document","DocxParser","load","textNode","splitIndex","addBefore","firstXmlTextNode","secondXmlTextNode","wordTextNode","containingTextNode","newWordTextNode","cloneNode","setSpacePreserveAttribute","insertBefore","lastTextChild","curIndex","indexOf","insertChild","firstText","secondText","substring","from","to","firstRunNode","containingRunNode","secondRunNode","paragraphNode","firstWordTextNode","secondWordTextNode","totalText","curRunNode","curWordTextNode","firstTextNodeChild","TEXT_NODE","curXmlTextNode","textToRemove","remove","runToRemove","joinParagraphs","first","second","childIndex","curChild","RUN_NODE","removeChild","appendChild","isTableCellNode","TABLE_CELL_NODE","PARAGRAPH_NODE","isListParagraph","paragraphProperties","paragraphPropertiesNode","listNumberProperties","findChildByName","NUMBER_PROPERTIES_NODE","PARAGRAPH_PROPERTIES_NODE","child","findParentByName","containingParagraphNode","containingTableRowNode","TABLE_ROW_NODE","Map","add","mediaFile","files","has","get","hashMediaFiles","base64","Binary","toBase64","hash","hashes","find","nextFileId","mediaDir","set","listFiles","startsWith","filename","Path","getFilename","fileData","getContentBase64","fileHash","partPath","partDir","getDirectory","partFilename","relsFilePath","relTarget","relType","additionalAttributes","substr","parseRelsFile","relTargetKey","getRelTargetKey","relId","relTargets","getNextRelId","relNode","relIds","nextRelId","relsXml","relsFile","rel","idAttr","typeAttr","targetAttr","type","target","createDefaultPlugins","LoopPlugin","RawXmlPlugin","ImagePlugin","LinkPlugin","TextPlugin","nextImageId","TemplatePlugin","utilities","content","source","mediaFilePath","docx","format","imageId","imageXml","createMarkup","width","height","insertAfter","markupText","pixelsToEmu","pictureMarkup","markupXml","removeEmptyTextNodes","pixels","Math","round","linkAttributes","TargetMode","linkRelType","wordRunNode","linkMarkup","generateMarkup","insertHyperlinkNode","text","runProps","RUN_PROPERTIES_NODE","linkRunProps","unshift","textNodesInRun","LoopListStrategy","setUtilities","isApplicable","containingParagraph","splitBefore","firstParagraph","lastParagraph","paragraphsToRepeat","siblingsInRange","nodesToRepeat","mergeBack","paragraphGroups","lastParagraphs","curParagraphsGroup","paragraph","LoopParagraphStrategy","areSame","parent","firstParagraphIndex","lastParagraphIndex","splitResult","splitByChild","firstParagraphSplit","lastParagraphSplit","middleParagraphs","inBetween","removeSiblings","mergeTo","LoopTableStrategy","firstRow","lastRow","rowsToRepeat","rowGroups","curRowsGroup","row","LOOP_CONTENT_TYPE","loopStrategies","forEach","strategy","Array","isArray","loopStrategy","repeatedNodes","repeat","compiledNodes","nodes","times","allResults","curResult","map","nodeGroups","compiledNodeGroups","curNodes","dummyRootNode","compiler","newNode","TEXT_CONTENT_TYPE","stringValue","toString","lines","split","replaceSingleLine","replaceMultiLine","runNode","lineBreak","getLineBreak","lineNode","createWordTextNode","createTextNode","TemplateHandler","options","EASY_VERSION","XmlParser","TemplateHandlerOptions","process","templateFile","loadDocx","getText","docxFile","getXml","file","Zip","pushMany","destArray","items","apply","array","last","toDictionary","keySelector","valueSelector","res","item","Base64","encode","str","btoa","Buffer","isBlob","binary","isBlobConstructor","isArrayBuffer","isArrayBufferConstructor","isBuffer","isBufferConstructor","binaryType","Blob","ArrayBuffer","Promise","resolve","fileReader","FileReader","onload","readAsBinaryString","binaryStr","Uint8Array","reduce","byte","String","fromCharCode","lastSlashIndex","lastIndexOf","sha1","msg","utf8Encode","msgLength","j","wordArray","charCodeAt","w","H0","H1","H2","H3","H4","A","B","C","D","E","temp","blockStart","rotateLeft","cvtHex","toLowerCase","n","s","t4","val","v","replace","utfStr","c","inheritsFrom","derived","base","isPromiseLike","candidate","then","XmlNodeType","TEXT_NODE_NAME","nodeType","Text","General","TypeError","attributeNames","hasChildren","suffix","childrenXml","fromDomNode","domNode","xmlNode","ELEMENT_NODE","curAttribute","prevChild","domChild","deep","clone","cloneNodeDeep","referenceNode","beforeNodeIndex","referenceNodeIndex","RangeError","childAfter","childBefore","splice","currentLastChild","allTextNodes","lastTextNode","newTextNode","removed","lastRemoved","removeMe","markerNode","removeMarkerNode","getDescendantPath","findParent","predicate","childName","range","curNode","recursiveRemoveEmptyTextNodes","childOrIndex","beforeChild","original","prevChildClone","childClone","descendant","curChildIndex","reverse","oldChildren","strippedChild","doc","parser","parseFromString","xmlHeader","xmldom","DOMParser","JsZipHelper","toJsZipOutputType","binaryOrType","JSZip","loadAsync","ZipObject","zipOutputType","output","generateAsync","compression","compressionOptions","level","zipObject","isDirectory","dir","async","getContentBinary"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,4BAAW;AAChC,cAAc,mBAAO,CAAC,wBAAS;AAC/B,cAAc,mBAAO,CAAC,wBAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;;;AC5vDA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;;AAEA;;AACA;;;;AAGA,MAAMA,UAAN,CAAiB;AAAA;AAAA,4CAEW,CAFX;;AAAA,uCAGqB,EAHrB;;AAAA,6CAIY,CAAC,CAJb;AAAA;;AAMNC,OAAP,GAAe;AACX,SAAKC,cAAL,GAAsB,CAAtB;AACA,SAAKC,SAAL,GAAiB,EAAjB;AACA,SAAKC,eAAL,GAAuB,CAAC,CAAxB;AACH;;AAVY;;AAaV,MAAMC,iBAAN,CAAwB;AA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","file":"easy-template-x.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"easy-template-x\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"easy-template-x\"] = factory();\n\telse\n\t\troot[\"easy-template-x\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","import { MissingArgumentError } from '../errors';\r\nimport { DocxParser } from '../office';\r\nimport { first, last } from '../utils';\r\nimport { XmlDepthTracker, XmlNode, XmlTextNode } from '../xml';\r\nimport { DelimiterMark } from './delimiterMark';\r\n\r\nclass MatchState {\r\n\r\n    public delimiterIndex = 0;\r\n    public openNodes: XmlTextNode[] = [];\r\n    public firstMatchIndex = -1;\r\n\r\n    public reset() {\r\n        this.delimiterIndex = 0;\r\n        this.openNodes = [];\r\n        this.firstMatchIndex = -1;\r\n    }\r\n}\r\n\r\nexport class DelimiterSearcher {\r\n\r\n    public maxXmlDepth = 20;\r\n    public startDelimiter = \"{\";\r\n    public endDelimiter = \"}\";\r\n\r\n    constructor(private readonly docxParser: DocxParser) {\r\n        if (!docxParser)\r\n            throw new MissingArgumentError(nameof(docxParser));\r\n    }\r\n\r\n    public findDelimiters(node: XmlNode): DelimiterMark[] {\r\n\r\n        //\r\n        // Performance note: \r\n        //\r\n        // The search efficiency is o(m*n) where n is the text size and m is the\r\n        // delimiter length. We could use a variation of the KMP algorithm here\r\n        // to reduce it to o(m+n) but since our m is expected to be small\r\n        // (delimiters defaults to 2 characters and even on custom inputs are\r\n        // not expected to be much longer) it does not worth the extra\r\n        // complexity and effort.\r\n        //\r\n\r\n        const delimiters: DelimiterMark[] = [];\r\n        const match = new MatchState();\r\n        const depth = new XmlDepthTracker(this.maxXmlDepth);\r\n        let lookForOpenDelimiter = true;\r\n\r\n        while (node) {\r\n\r\n            // reset state on paragraph transition\r\n            if (this.docxParser.isParagraphNode(node)) {\r\n                match.reset();\r\n            }\r\n\r\n            // skip irrelevant nodes\r\n            if (!this.shouldSearchNode(node)) {\r\n                node = this.findNextNode(node, depth);\r\n                continue;\r\n            }\r\n\r\n            // search delimiters in text nodes\r\n            match.openNodes.push(node);\r\n            let textIndex = 0;\r\n            while (textIndex < node.textContent.length) {\r\n\r\n                const delimiterPattern = lookForOpenDelimiter ? this.startDelimiter : this.endDelimiter;\r\n\r\n                // char match\r\n                const char = node.textContent[textIndex];\r\n                if (char === delimiterPattern[match.delimiterIndex]) {\r\n\r\n                    // first match\r\n                    if (match.firstMatchIndex === -1) {\r\n                        match.firstMatchIndex = textIndex;\r\n                    }\r\n\r\n                    // full delimiter match\r\n                    if (match.delimiterIndex === delimiterPattern.length - 1) {\r\n\r\n                        // move all delimiters characters to the same text node\r\n                        if (match.openNodes.length > 1) {\r\n                            \r\n                            const firstNode = first(match.openNodes);\r\n                            const lastNode = last(match.openNodes);\r\n                            this.docxParser.joinTextNodesRange(firstNode, lastNode);\r\n                            \r\n                            textIndex += (firstNode.textContent.length - node.textContent.length);\r\n                            node = firstNode;\r\n                        }\r\n\r\n                        // store delimiter\r\n                        const delimiterMark = this.createDelimiterMark(match, lookForOpenDelimiter);\r\n                        delimiters.push(delimiterMark);\r\n\r\n                        // update state\r\n                        lookForOpenDelimiter = !lookForOpenDelimiter;\r\n                        match.reset();\r\n                        if (textIndex < node.textContent.length - 1) {\r\n                            match.openNodes.push(node);\r\n                        }\r\n\r\n                    } else {\r\n                        match.delimiterIndex++;\r\n                    }\r\n                }\r\n\r\n                // no match\r\n                else {\r\n\r\n                    //\r\n                    // go back to first open node\r\n                    //\r\n                    // Required for cases where the text has repeating\r\n                    // characters that are the same as a delimiter prefix.  \r\n                    // For instance:  \r\n                    // Delimiter is '{!' and template text contains the string '{{!'\r\n                    //\r\n                    if (match.firstMatchIndex !== -1) {\r\n                        node = first(match.openNodes);\r\n                        textIndex = match.firstMatchIndex;\r\n                    }\r\n\r\n                    // update state\r\n                    match.reset();\r\n                    if (textIndex < node.textContent.length - 1) {\r\n                        match.openNodes.push(node);\r\n                    }\r\n                }\r\n\r\n                textIndex++;\r\n            }\r\n\r\n            node = this.findNextNode(node, depth);\r\n        }\r\n\r\n        return delimiters;\r\n    }\r\n\r\n    private shouldSearchNode(node: XmlNode): node is XmlTextNode {\r\n\r\n        if (!XmlNode.isTextNode(node))\r\n            return false;\r\n        if (!node.textContent)\r\n            return false;\r\n        if (!node.parentNode)\r\n            return false;\r\n        if (!this.docxParser.isTextNode(node.parentNode))\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    private findNextNode(node: XmlNode, depth: XmlDepthTracker): XmlNode {\r\n\r\n        // children\r\n        if (node.childNodes && node.childNodes.length) {\r\n            depth.increment();\r\n            return node.childNodes[0];\r\n        }\r\n\r\n        // siblings\r\n        if (node.nextSibling)\r\n            return node.nextSibling;\r\n\r\n        // parent sibling\r\n        while (node.parentNode) {\r\n\r\n            if (node.parentNode.nextSibling) {\r\n                depth.decrement();\r\n                return node.parentNode.nextSibling;\r\n            }\r\n\r\n            // go up\r\n            depth.decrement();\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private createDelimiterMark(match: MatchState, isOpenDelimiter: boolean): DelimiterMark {\r\n        return {\r\n            index: match.firstMatchIndex,\r\n            isOpen: isOpenDelimiter,\r\n            xmlTextNode: match.openNodes[0]\r\n        };\r\n    }\r\n}","export * from './delimiterMark';\r\nexport * from './delimiterSearcher';\r\nexport * from './scopeData';\r\nexport * from './tag';\r\nexport * from './tagParser';\r\nexport * from './templateCompiler';\r\nexport * from './templateContext';\r\n","import { TemplateContent, TemplateData } from '../templateData';\r\nimport { last } from '../utils';\r\n\r\nconst getProp = require('lodash.get');\r\n\r\nexport class ScopeData {\r\n    \r\n    public readonly path: (string | number)[] = [];\r\n    public readonly allData: TemplateData;\r\n\r\n    constructor(data: TemplateData) {\r\n        this.allData = data;\r\n    }\r\n\r\n    public getScopeData(): TemplateContent | TemplateData[] {\r\n\r\n        const lastKey = last(this.path);\r\n\r\n        let result: any;\r\n        let curPath = this.path.slice();\r\n\r\n        while (result === undefined && curPath.length) {\r\n            const curScopePath = curPath.slice(0, curPath.length - 1);\r\n            result = getProp(this.allData, curScopePath.concat(lastKey));\r\n            curPath = curScopePath;\r\n        }\r\n        return result;\r\n    }\r\n}","import { XmlTextNode } from '../xml';\r\n\r\nexport enum TagDisposition {\r\n    Open = \"Open\",\r\n    Close = \"Close\",\r\n    SelfClosed = \"SelfClosed\"\r\n}\r\n\r\nexport interface Tag {    \r\n    name: string;\r\n    /**\r\n     * The full tag text, for instance: \"{#my-tag}\".\r\n     */\r\n    rawText: string;\r\n    disposition: TagDisposition;\r\n    xmlTextNode: XmlTextNode;\r\n}","import { Delimiters } from '../delimiters';\r\nimport { MissingArgumentError, MissingCloseDelimiterError, MissingStartDelimiterError } from '../errors';\r\nimport { DocxParser } from '../office';\r\nimport { DelimiterMark } from './delimiterMark';\r\nimport { Tag, TagDisposition } from './tag';\r\n\r\nexport class TagParser {\r\n\r\n    private readonly tagRegex: RegExp;\r\n\r\n    constructor(\r\n        private readonly docParser: DocxParser,\r\n        private readonly delimiters: Delimiters\r\n    ) {\r\n        if (!docParser)\r\n            throw new MissingArgumentError(nameof(docParser));\r\n        if (!delimiters)\r\n            throw new MissingArgumentError(nameof(delimiters));\r\n\r\n        // TODO: regex escape\r\n        this.tagRegex = new RegExp(`^[${delimiters.tagStart}](.*?)[${delimiters.tagEnd}]`, 'mi');\r\n    }\r\n\r\n    public parse(delimiters: DelimiterMark[]): Tag[] {\r\n        const tags: Tag[] = [];\r\n\r\n        let openedTag: Partial<Tag>;\r\n        let openedDelimiter: DelimiterMark;\r\n        for (let i = 0; i < delimiters.length; i++) {\r\n            const delimiter = delimiters[i];\r\n\r\n            // close before open\r\n            if (!openedTag && !delimiter.isOpen) {\r\n                const closeTagText = delimiter.xmlTextNode.textContent;\r\n                throw new MissingStartDelimiterError(closeTagText);\r\n            }\r\n\r\n            // open before close\r\n            if (openedTag && delimiter.isOpen) {\r\n                const openTagText = openedDelimiter.xmlTextNode.textContent;\r\n                throw new MissingCloseDelimiterError(openTagText);\r\n            }\r\n\r\n            // valid open\r\n            if (!openedTag && delimiter.isOpen) {\r\n                openedTag = {};\r\n                openedDelimiter = delimiter;\r\n            }\r\n\r\n            // valid close\r\n            if (openedTag && !delimiter.isOpen) {\r\n\r\n                // normalize the underlying xml structure\r\n                // (make sure the tag's node only includes the tag's text)\r\n                this.normalizeTagNodes(openedDelimiter, delimiter, i, delimiters);\r\n                openedTag.xmlTextNode = openedDelimiter.xmlTextNode;\r\n\r\n                // extract tag info from tag's text\r\n                this.processTag(openedTag as Tag);\r\n                tags.push(openedTag as Tag);\r\n                openedTag = null;\r\n                openedDelimiter = null;\r\n            }\r\n        }\r\n\r\n        return tags;\r\n    }\r\n\r\n    /**\r\n     * Consolidate all tag's text into a single text node.\r\n     * \r\n     * Example: \r\n     * \r\n     * Text node before: \"some text {some tag} some more text\" \r\n     * Text nodes after: [ \"some text \", \"{some tag}\", \" some more text\" ]\r\n     */\r\n    private normalizeTagNodes(\r\n        openDelimiter: DelimiterMark,\r\n        closeDelimiter: DelimiterMark,\r\n        closeDelimiterIndex: number,\r\n        allDelimiters: DelimiterMark[]\r\n    ): void {\r\n\r\n        let startTextNode = openDelimiter.xmlTextNode;\r\n        let endTextNode = closeDelimiter.xmlTextNode;\r\n        const sameNode = (startTextNode === endTextNode);\r\n\r\n        // trim start\r\n        if (openDelimiter.index > 0) {\r\n            this.docParser.splitTextNode(startTextNode, openDelimiter.index, true);\r\n            if (sameNode) {\r\n                closeDelimiter.index -= openDelimiter.index;\r\n            }\r\n        }\r\n\r\n        // trim end\r\n        if (closeDelimiter.index < endTextNode.textContent.length - 1) {\r\n            endTextNode = this.docParser.splitTextNode(endTextNode, closeDelimiter.index + 1, true);\r\n            if (sameNode) {\r\n                startTextNode = endTextNode;\r\n            }\r\n        }\r\n\r\n        // join nodes\r\n        if (!sameNode) {\r\n            this.docParser.joinTextNodesRange(startTextNode, endTextNode);\r\n            endTextNode = startTextNode;\r\n        }\r\n\r\n        // update offsets of next delimiters\r\n        for (let i = closeDelimiterIndex + 1; i < allDelimiters.length; i++) {\r\n\r\n            let updated = false;\r\n            const curDelimiter = allDelimiters[i];\r\n\r\n            if (curDelimiter.xmlTextNode === openDelimiter.xmlTextNode) {\r\n                curDelimiter.index -= openDelimiter.index;\r\n                updated = true;\r\n            }\r\n\r\n            if (curDelimiter.xmlTextNode === closeDelimiter.xmlTextNode) {\r\n                curDelimiter.index -= closeDelimiter.index + 1;\r\n                updated = true;\r\n            }\r\n\r\n            if (!updated)\r\n                break;\r\n        }\r\n\r\n        // update references\r\n        openDelimiter.xmlTextNode = startTextNode;\r\n        closeDelimiter.xmlTextNode = endTextNode;\r\n    }\r\n\r\n    private processTag(tag: Tag): void {\r\n        tag.rawText = tag.xmlTextNode.textContent;\r\n\r\n        const tagParts = this.tagRegex.exec(tag.rawText);\r\n        const tagContent = (tagParts[1] || '').trim();\r\n        if (!tagContent || !tagContent.length) {\r\n            tag.disposition = TagDisposition.SelfClosed;\r\n            return;\r\n        }\r\n\r\n        if (tagContent[0] === this.delimiters.containerTagOpen) {\r\n            tag.disposition = TagDisposition.Open;\r\n            tag.name = tagContent.slice(1);\r\n\r\n        } else if (tagContent[0] === this.delimiters.containerTagClose) {\r\n            tag.disposition = TagDisposition.Close;\r\n            tag.name = tagContent.slice(1);\r\n\r\n        } else {\r\n            tag.disposition = TagDisposition.SelfClosed;\r\n            tag.name = tagContent;\r\n        }\r\n    }\r\n}","import { UnclosedTagError, UnknownContentTypeError } from '../errors';\r\nimport { PluginContent, TemplatePlugin } from '../plugins';\r\nimport { isPromiseLike, toDictionary } from '../utils';\r\nimport { XmlNode } from '../xml';\r\nimport { DelimiterSearcher } from './delimiterSearcher';\r\nimport { ScopeData } from './scopeData';\r\nimport { Tag, TagDisposition } from './tag';\r\nimport { TagParser } from './tagParser';\r\nimport { TemplateContext } from './templateContext';\r\n\r\n/**\r\n * The TemplateCompiler works roughly the same way as a source code compiler.\r\n * It's main steps are:\r\n * \r\n * 1. find delimiters (lexical analysis) :: (Document) => DelimiterMark[]\r\n * 2. extract tags (syntax analysis) :: (DelimiterMark[]) => Tag[]\r\n * 3. perform document replace (code generation) :: (Tag[], data) => Document*\r\n * \r\n * see: https://en.wikipedia.org/wiki/Compiler\r\n */\r\nexport class TemplateCompiler {\r\n\r\n    private readonly pluginsLookup: IMap<TemplatePlugin>;\r\n\r\n    constructor(\r\n        private readonly delimiterSearcher: DelimiterSearcher,\r\n        private readonly tagParser: TagParser,\r\n        plugins: TemplatePlugin[],\r\n        private readonly defaultContentType: string,\r\n        private readonly containerContentType: string\r\n    ) {\r\n        this.pluginsLookup = toDictionary(plugins, p => p.contentType);\r\n    }\r\n\r\n    /**\r\n     * Compiles the template and performs the required replacements using the\r\n     * specified data.\r\n     */\r\n    public async compile(node: XmlNode, data: ScopeData, context: TemplateContext): Promise<void> {\r\n        const tags = this.parseTags(node);\r\n        await this.doTagReplacements(tags, data, context);\r\n    }\r\n\r\n    public parseTags(node: XmlNode): Tag[] {\r\n        const delimiters = this.delimiterSearcher.findDelimiters(node);\r\n        const tags = this.tagParser.parse(delimiters);\r\n        return tags;\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private async doTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        for (let tagIndex = 0; tagIndex < tags.length; tagIndex++) {\r\n\r\n            const tag = tags[tagIndex];\r\n            data.path.push(tag.name);\r\n            const contentType = this.detectContentType(tag, data);\r\n            const plugin = this.pluginsLookup[contentType];\r\n            if (!plugin) {\r\n                throw new UnknownContentTypeError(\r\n                    contentType,\r\n                    tag.rawText,\r\n                    data.path.join('.')\r\n                );\r\n            }\r\n\r\n            if (tag.disposition === TagDisposition.SelfClosed) {\r\n\r\n                // replace simple tag                \r\n                const job = plugin.simpleTagReplacements(tag, data, context);\r\n                if (isPromiseLike(job)) {\r\n                    await job;\r\n                }\r\n\r\n            } else if (tag.disposition === TagDisposition.Open) {\r\n\r\n                // get all tags between the open and close tags\r\n                const closingTagIndex = this.findCloseTagIndex(tagIndex, tag, tags);\r\n                const scopeTags = tags.slice(tagIndex, closingTagIndex + 1);\r\n                tagIndex = closingTagIndex;\r\n\r\n                // replace container tag\r\n                const job = plugin.containerTagReplacements(scopeTags, data, context);\r\n                if (isPromiseLike(job)) {\r\n                    await job;\r\n                }\r\n            }\r\n\r\n            data.path.pop();\r\n        }\r\n    }\r\n\r\n    private detectContentType(tag: Tag, data: ScopeData): string {\r\n\r\n        if (tag.disposition === TagDisposition.Open || tag.disposition === TagDisposition.Close)\r\n            return this.containerContentType;\r\n\r\n        const scopeData = data.getScopeData();\r\n        if (PluginContent.isPluginContent(scopeData))\r\n            return scopeData._type;\r\n\r\n        return this.defaultContentType;\r\n    }\r\n\r\n    private findCloseTagIndex(fromIndex: number, openTag: Tag, tags: Tag[]): number {\r\n\r\n        let i = fromIndex;\r\n        for (; i < tags.length; i++) {\r\n            const closeTag = tags[i];\r\n            if (\r\n                closeTag.name === openTag.name &&\r\n                closeTag.disposition === TagDisposition.Close\r\n            ) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (i === tags.length) {\r\n            throw new UnclosedTagError(openTag.name);\r\n        }\r\n\r\n        return i;\r\n    }\r\n}","import { XmlNode } from \"./xml\";\r\n\r\nexport class Delimiters {\r\n\r\n    public tagStart = \"{\";\r\n    public tagEnd = \"}\";\r\n    public containerTagOpen = \"#\";\r\n    public containerTagClose = \"/\";\r\n\r\n    constructor(initial?: Partial<Delimiters>) {\r\n        Object.assign(this, initial);\r\n\r\n        this.encodeAndValidate();\r\n\r\n        if (this.containerTagOpen === this.containerTagClose)\r\n            throw new Error(`${nameof(this.containerTagOpen)} can not be equal to ${nameof(this.containerTagClose)}`);\r\n    }\r\n\r\n    private encodeAndValidate() {\r\n        const keys: (keyof Delimiters)[] = ['tagStart', 'tagEnd', 'containerTagOpen', 'containerTagClose'];\r\n        for (const key of keys) {\r\n            const value = this[key];\r\n\r\n            if (!value)\r\n                throw new Error(`${key} must be specified.`);\r\n\r\n            this[key] = XmlNode.encodeValue(value);\r\n        }\r\n    }\r\n}","export * from './malformedFileError';\r\nexport * from './maxXmlDepthError';\r\nexport * from './missingArgumentError';\r\nexport * from './missingCloseDelimiterError';\r\nexport * from './missingStartDelimiterError';\r\nexport * from './unclosedTagError';\r\nexport * from './unidentifiedFileTypeError';\r\nexport * from './unknownContentTypeError';\r\nexport * from './unopenedTagError';\r\nexport * from './unsupportedFileTypeError';\r\n","export class MalformedFileError extends Error {\r\n\r\n    public readonly expectedFileType: string;\r\n\r\n    constructor(expectedFileType: string) {\r\n        super(`Malformed file detected. Make sure the file is a valid ${expectedFileType} file.`);\r\n\r\n        this.expectedFileType = expectedFileType;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MalformedFileError.prototype);\r\n    }\r\n}","export class MaxXmlDepthError extends Error {\r\n\r\n    public readonly maxDepth: number;\r\n\r\n    constructor(maxDepth: number) {\r\n        super(`XML maximum depth reached (max depth: ${maxDepth}).`);\r\n\r\n        this.maxDepth = maxDepth;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MaxXmlDepthError.prototype);\r\n    }\r\n}","export class MissingArgumentError extends Error {\r\n\r\n    public readonly argName: string;\r\n\r\n    constructor(argName: string) {\r\n        super(`Argument '${argName}' is missing.`);\r\n\r\n        this.argName = argName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingArgumentError.prototype);\r\n    }\r\n}","export class MissingCloseDelimiterError extends Error {\r\n\r\n    public readonly openDelimiterText: string;\r\n\r\n    constructor(openDelimiterText: string) {\r\n        super(`Close delimiter is missing from '${openDelimiterText}'.`);\r\n\r\n        this.openDelimiterText = openDelimiterText;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingCloseDelimiterError.prototype);\r\n    }\r\n}","export class MissingStartDelimiterError extends Error {\r\n\r\n    public readonly closeDelimiterText: string;\r\n\r\n    constructor(closeDelimiterText: string) {\r\n        super(`Open delimiter is missing from '${closeDelimiterText}'.`);\r\n\r\n        this.closeDelimiterText = closeDelimiterText;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingStartDelimiterError.prototype);\r\n    }\r\n}","export class UnclosedTagError extends Error {\r\n\r\n    public readonly tagName: string;\r\n\r\n    constructor(tagName: string) {\r\n        super(`Tag '${tagName}' is never closed.`);\r\n\r\n        this.tagName = tagName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnclosedTagError.prototype);\r\n    }\r\n}","export class UnidentifiedFileTypeError extends Error {\r\n    constructor() {\r\n        super(`The filetype for this file could not be identified, is this file corrupted?`);\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnidentifiedFileTypeError.prototype);\r\n    }\r\n}","export class UnknownContentTypeError extends Error {\r\n\r\n    public readonly tagRawText: string;\r\n    public readonly contentType: string;\r\n    public readonly path: string;\r\n\r\n    constructor(contentType: string, tagRawText: string, path: string) {\r\n        super(`Content type '${contentType}' does not have a registered plugin to handle it.`);\r\n\r\n        this.contentType = contentType;\r\n        this.tagRawText = tagRawText;\r\n        this.path = path;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnknownContentTypeError.prototype);\r\n    }\r\n}","export class UnopenedTagError extends Error {\r\n\r\n    public readonly tagName: string;\r\n\r\n    constructor(tagName: string) {\r\n        super(`Tag '${tagName}' is closed but was never opened.`);\r\n\r\n        this.tagName = tagName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnopenedTagError.prototype);\r\n    }\r\n}","export class UnsupportedFileTypeError extends Error {\r\n\r\n    public readonly fileType: string;\r\n\r\n    constructor(fileType: string) {\r\n        super(`Filetype \"${fileType}\" is not supported.`);\r\n\r\n        this.fileType = fileType;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnsupportedFileTypeError.prototype);\r\n    }\r\n}","export * from './compilation';\r\nexport * from './errors';\r\nexport * from './office';\r\nexport * from './plugins';\r\nexport * from './utils';\r\nexport * from './xml';\r\nexport * from './delimiters';\r\nexport * from './mimeType';\r\nexport * from './templateData';\r\nexport * from './templateHandler';\r\nexport * from './templateHandlerOptions';\r\n","import { UnsupportedFileTypeError } from './errors';\r\n\r\nexport enum MimeType {\r\n    Png = 'image/png',\r\n    Jpeg = 'image/jpeg',\r\n    Gif = 'image/gif',\r\n    Bmp = 'image/bmp',\r\n    Svg = 'image/svg+xml'\r\n}\r\n\r\nexport class MimeTypeHelper {\r\n\r\n    public static getDefaultExtension(mime: MimeType): string {\r\n        switch (mime) {\r\n            case MimeType.Png:\r\n                return 'png';\r\n            case MimeType.Jpeg:\r\n                return 'jpg';\r\n            case MimeType.Gif:\r\n                return 'gif';\r\n            case MimeType.Bmp:\r\n                return 'bmp';\r\n            case MimeType.Svg:\r\n                return 'svg';\r\n            default:\r\n                throw new UnsupportedFileTypeError(mime);\r\n        }\r\n    }\r\n\r\n    public static getOfficeRelType(mime: MimeType): string {\r\n        switch (mime) {\r\n            case MimeType.Png:\r\n            case MimeType.Jpeg:\r\n            case MimeType.Gif:\r\n            case MimeType.Bmp:\r\n            case MimeType.Svg:\r\n                return \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\";\r\n            default:\r\n                throw new UnsupportedFileTypeError(mime);\r\n        }\r\n    }\r\n}","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { XmlGeneralNode, XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * http://officeopenxml.com/anatomyofOOXML.php\r\n */\r\nexport class ContentTypesFile {\r\n\r\n    private static readonly contentTypesFilePath = '[Content_Types].xml';\r\n\r\n    private addedNew = false;\r\n\r\n    private root: XmlNode;\r\n\r\n    private contentTypes: IMap<boolean>;\r\n\r\n    constructor(\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n    }\r\n\r\n    public async ensureContentType(mime: MimeType): Promise<void> {\r\n\r\n        // parse the content types file\r\n        await this.parseContentTypesFile();\r\n\r\n        // already exists\r\n        if (this.contentTypes[mime])\r\n            return;\r\n\r\n        // add new\r\n        const extension = MimeTypeHelper.getDefaultExtension(mime);\r\n        const typeNode = XmlNode.createGeneralNode('Default');\r\n        typeNode.attributes = {\r\n            \"Extension\": extension,\r\n            \"ContentType\": mime\r\n        };\r\n        this.root.childNodes.push(typeNode);\r\n\r\n        // update state\r\n        this.addedNew = true;\r\n        this.contentTypes[mime] = true;\r\n    }\r\n\r\n    public async count(): Promise<number> {\r\n        await this.parseContentTypesFile();\r\n        return this.root.childNodes.filter(node => !XmlNode.isTextNode(node)).length;\r\n    }\r\n\r\n    /**\r\n     * Save the Content Types file back to the zip.  \r\n     * Called automatically by the holding `Docx` before exporting.\r\n     */\r\n    public async save(): Promise<void> {\r\n\r\n        // not change - no need to save\r\n        if (!this.addedNew)\r\n            return;\r\n\r\n        const xmlContent = this.xmlParser.serialize(this.root);\r\n        this.zip.setFile(ContentTypesFile.contentTypesFilePath, xmlContent);\r\n    }\r\n\r\n    private async parseContentTypesFile(): Promise<void> {\r\n        if (this.root)\r\n            return;\r\n\r\n        // parse the xml file\r\n        const contentTypesXml = await this.zip.getFile(ContentTypesFile.contentTypesFilePath).getContentText();\r\n        this.root = this.xmlParser.parse(contentTypesXml);\r\n\r\n        // build the content types lookup\r\n        this.contentTypes = {};\r\n        for (const node of this.root.childNodes) {\r\n\r\n            if (node.nodeName !== 'Default')\r\n                continue;\r\n\r\n            const genNode = (node as XmlGeneralNode);\r\n            const contentTypeAttribute = genNode.attributes['ContentType'];\r\n            if (!contentTypeAttribute)\r\n                continue;\r\n\r\n            this.contentTypes[contentTypeAttribute];\r\n        }\r\n    }\r\n}","import { MalformedFileError } from '../errors';\r\nimport { Binary } from '../utils';\r\nimport { XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\nimport { ContentTypesFile } from './contentTypesFile';\r\nimport { MediaFiles } from './mediaFiles';\r\nimport { Rels } from './rels';\r\n\r\n/**\r\n * Represents a single docx file.\r\n */\r\nexport class Docx {\r\n\r\n    public get documentPath(): string {\r\n\r\n        if (!this._documentPath) {\r\n\r\n            if (this.zip.isFileExist(\"word/document.xml\")) {\r\n                this._documentPath = \"word/document.xml\";\r\n            }\r\n\r\n            // https://github.com/open-xml-templating/docxtemplater/issues/366\r\n            else if (this.zip.isFileExist(\"word/document2.xml\")) {\r\n                this._documentPath = \"word/document2.xml\";\r\n            }\r\n        }\r\n\r\n        return this._documentPath;\r\n    }\r\n\r\n    public readonly rels: Rels;\r\n    public readonly mediaFiles: MediaFiles;\r\n    public readonly contentTypes: ContentTypesFile;\r\n\r\n    private _documentPath: string;\r\n    private _document: XmlNode;    \r\n\r\n    constructor(\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n        if (!this.documentPath)\r\n            throw new MalformedFileError('docx');\r\n\r\n        this.rels = new Rels(this.documentPath, zip, xmlParser);\r\n        this.mediaFiles = new MediaFiles(zip);\r\n        this.contentTypes = new ContentTypesFile(zip, xmlParser);\r\n    }\r\n\r\n    //\r\n    // public methods\r\n    //\r\n\r\n    /**\r\n     * The xml root of the main document file.\r\n     */\r\n    public async getDocument(): Promise<XmlNode> {\r\n        if (!this._document) {\r\n            const xml = await this.zip.getFile(this.documentPath).getContentText();\r\n            this._document = this.xmlParser.parse(xml);\r\n        }\r\n        return this._document;\r\n    }\r\n\r\n    /**\r\n     * Get the text content of the main document file.\r\n     */\r\n    public async getDocumentText(): Promise<string> {\r\n        const xmlDocument = await this.getDocument();\r\n\r\n        // ugly but good enough...\r\n        const xml = this.xmlParser.serialize(xmlDocument);\r\n        const domDocument = this.xmlParser.domParse(xml);\r\n\r\n        return domDocument.documentElement.textContent;\r\n    }    \r\n\r\n    public async export<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        await this.saveChanges();\r\n        return await this.zip.export(outputType);\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //        \r\n\r\n    private async saveChanges() {\r\n\r\n        // save main document\r\n        const document = await this.getDocument();\r\n        const xmlContent = this.xmlParser.serialize(document);\r\n        this.zip.setFile(this.documentPath, xmlContent);\r\n\r\n        // save other parts\r\n        await this.rels.save();\r\n        await this.contentTypes.save();\r\n    }\r\n}","import { XmlGeneralNode, XmlNode, XmlParser, XmlTextNode } from '../xml';\r\nimport { Zip } from '../zip';\r\nimport { Docx } from './docx';\r\n\r\nexport class DocxParser {\r\n\r\n    /*\r\n     * Word markup intro:\r\n     * \r\n     * In Word text nodes are contained in \"run\" nodes (which specifies text\r\n     * properties such as font and color). The \"run\" nodes in turn are\r\n     * contained in paragraph nodes which is the core unit of content.\r\n     * \r\n     * Example:\r\n     *\r\n     * <w:p>    <-- paragraph\r\n     *   <w:r>      <-- run\r\n     *     <w:rPr>      <-- run properties\r\n     *       <w:b/>     <-- bold\r\n     *     </w:rPr>\r\n     *     <w:t>This is text.</w:t>     <-- actual text\r\n     *   </w:r>\r\n     * </w:p> \r\n     *\r\n     * see: http://officeopenxml.com/WPcontentOverview.php\r\n     */\r\n\r\n    public static readonly PARAGRAPH_NODE = 'w:p';\r\n    public static readonly PARAGRAPH_PROPERTIES_NODE = 'w:pPr';\r\n    public static readonly RUN_NODE = 'w:r';\r\n    public static readonly RUN_PROPERTIES_NODE = 'w:rPr';\r\n    public static readonly TEXT_NODE = 'w:t';\r\n    public static readonly TABLE_ROW_NODE = 'w:tr';\r\n    public static readonly TABLE_CELL_NODE = 'w:tc';\r\n    public static readonly NUMBER_PROPERTIES_NODE = 'w:numPr';\r\n\r\n    //\r\n    // constructor\r\n    //\r\n\r\n    constructor(\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n    }\r\n\r\n    //\r\n    // parse document\r\n    //\r\n\r\n    public load(zip: Zip): Docx {\r\n        return new Docx(zip, this.xmlParser);\r\n    }\r\n\r\n    //\r\n    // content manipulation\r\n    //\r\n\r\n    /**\r\n     * Split the text node into two text nodes, each with it's own wrapping <w:t> node.\r\n     * Returns the newly created text node.\r\n     * \r\n     * @param textNode \r\n     * @param splitIndex \r\n     * @param addBefore Should the new node be added before or after the original node.\r\n     */\r\n    public splitTextNode(textNode: XmlTextNode, splitIndex: number, addBefore: boolean): XmlTextNode {\r\n\r\n        let firstXmlTextNode: XmlTextNode;\r\n        let secondXmlTextNode: XmlTextNode;\r\n\r\n        // split nodes\r\n        const wordTextNode = this.containingTextNode(textNode);\r\n        const newWordTextNode = XmlNode.cloneNode(wordTextNode, true);\r\n\r\n        // set space preserve to prevent display differences after splitting\r\n        // (otherwise if there was a space in the middle of the text node and it\r\n        // is now at the beginning or end of the text node it will be ignored)\r\n        this.setSpacePreserveAttribute(wordTextNode);\r\n        this.setSpacePreserveAttribute(newWordTextNode);\r\n\r\n        if (addBefore) {\r\n\r\n            // insert new node before existing one\r\n            XmlNode.insertBefore(newWordTextNode, wordTextNode);\r\n\r\n            firstXmlTextNode = XmlNode.lastTextChild(newWordTextNode);\r\n            secondXmlTextNode = textNode;\r\n\r\n        } else {\r\n\r\n            // insert new node after existing one\r\n            const curIndex = wordTextNode.parentNode.childNodes.indexOf(wordTextNode);\r\n            XmlNode.insertChild(wordTextNode.parentNode, newWordTextNode, curIndex + 1);\r\n\r\n            firstXmlTextNode = textNode;\r\n            secondXmlTextNode = XmlNode.lastTextChild(newWordTextNode);\r\n        }\r\n\r\n        // edit text\r\n        const firstText = firstXmlTextNode.textContent;\r\n        const secondText = secondXmlTextNode.textContent;\r\n        firstXmlTextNode.textContent = firstText.substring(0, splitIndex);\r\n        secondXmlTextNode.textContent = secondText.substring(splitIndex);\r\n\r\n        return (addBefore ? firstXmlTextNode : secondXmlTextNode);\r\n    }\r\n\r\n    /**\r\n     * Move all text between the 'from' and 'to' nodes to the 'from' node.\r\n     */\r\n    public joinTextNodesRange(from: XmlTextNode, to: XmlTextNode): void {\r\n\r\n        // find run nodes\r\n        const firstRunNode = this.containingRunNode(from);\r\n        const secondRunNode = this.containingRunNode(to);\r\n\r\n        const paragraphNode = firstRunNode.parentNode;\r\n        if (secondRunNode.parentNode !== paragraphNode)\r\n            throw new Error('Can not join text nodes from separate paragraphs.');\r\n\r\n        // find \"word text nodes\"\r\n        const firstWordTextNode = this.containingTextNode(from);\r\n        const secondWordTextNode = this.containingTextNode(to);\r\n        const totalText: string[] = [];\r\n\r\n        // iterate runs\r\n        let curRunNode = firstRunNode;\r\n        while (curRunNode) {\r\n\r\n            // iterate text nodes\r\n            let curWordTextNode: XmlNode;\r\n            if (curRunNode === firstRunNode) {\r\n                curWordTextNode = firstWordTextNode;\r\n            } else {\r\n                curWordTextNode = this.firstTextNodeChild(curRunNode);\r\n            }\r\n            while (curWordTextNode) {\r\n\r\n                if (curWordTextNode.nodeName !== DocxParser.TEXT_NODE)\r\n                    continue;\r\n\r\n                // move text to first node\r\n                const curXmlTextNode = XmlNode.lastTextChild(curWordTextNode);\r\n                totalText.push(curXmlTextNode.textContent);\r\n\r\n                // next text node\r\n                const textToRemove = curWordTextNode;\r\n                if (curWordTextNode === secondWordTextNode) {\r\n                    curWordTextNode = null;\r\n                } else {\r\n                    curWordTextNode = curWordTextNode.nextSibling;\r\n                }\r\n\r\n                // remove current text node\r\n                if (textToRemove !== firstWordTextNode) {\r\n                    XmlNode.remove(textToRemove);\r\n                }\r\n            }\r\n\r\n            // next run\r\n            const runToRemove = curRunNode;\r\n            if (curRunNode === secondRunNode) {\r\n                curRunNode = null;\r\n            } else {\r\n                curRunNode = curRunNode.nextSibling;\r\n            }\r\n\r\n            // remove current run\r\n            if (!runToRemove.childNodes || !runToRemove.childNodes.length) {\r\n                XmlNode.remove(runToRemove);\r\n            }\r\n        }\r\n\r\n        // set the text content\r\n        const firstXmlTextNode = XmlNode.lastTextChild(firstWordTextNode);\r\n        firstXmlTextNode.textContent = totalText.join('');\r\n    }\r\n\r\n    /**\r\n     * Take all runs from 'second' and move them to 'first'.\r\n     */\r\n    public joinParagraphs(first: XmlNode, second: XmlNode): void {\r\n        if (first === second)\r\n            return;\r\n\r\n        let childIndex = 0;\r\n        while (second.childNodes && childIndex < second.childNodes.length) {\r\n            const curChild = second.childNodes[childIndex];\r\n            if (curChild.nodeName === DocxParser.RUN_NODE) {\r\n                XmlNode.removeChild(second, childIndex);\r\n                XmlNode.appendChild(first, curChild);\r\n            } else {\r\n                childIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setSpacePreserveAttribute(node: XmlGeneralNode): void {\r\n        if (!node.attributes) {\r\n            node.attributes = {};\r\n        }\r\n        if (!node.attributes['xml:space']) {\r\n            node.attributes['xml:space'] = 'preserve';\r\n        }\r\n    }\r\n\r\n    //\r\n    // node queries\r\n    //\r\n\r\n    public isTextNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.TEXT_NODE;\r\n    }\r\n\r\n    public isTableCellNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.TABLE_CELL_NODE;\r\n    }\r\n\r\n    public isParagraphNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.PARAGRAPH_NODE;\r\n    }\r\n\r\n    public isListParagraph(paragraphNode: XmlNode): boolean {\r\n        const paragraphProperties = this.paragraphPropertiesNode(paragraphNode);\r\n        const listNumberProperties = XmlNode.findChildByName(paragraphProperties, DocxParser.NUMBER_PROPERTIES_NODE);\r\n        return !!listNumberProperties;\r\n    }\r\n\r\n    public paragraphPropertiesNode(paragraphNode: XmlNode): XmlNode {\r\n        if (!this.isParagraphNode(paragraphNode))\r\n            throw new Error(`Expected paragraph node but received a '${paragraphNode.nodeName}' node.`);\r\n\r\n        return XmlNode.findChildByName(paragraphNode, DocxParser.PARAGRAPH_PROPERTIES_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search for the first direct child **Word** text node (i.e. a <w:t> node).\r\n     */\r\n    public firstTextNodeChild(node: XmlNode): XmlNode {\r\n\r\n        if (!node)\r\n            return null;\r\n\r\n        if (node.nodeName !== DocxParser.RUN_NODE)\r\n            return null;\r\n\r\n        if (!node.childNodes)\r\n            return null;\r\n\r\n        for (const child of node.childNodes) {\r\n            if (child.nodeName === DocxParser.TEXT_NODE)\r\n                return child;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first **Word** text node (i.e. a <w:t> node).\r\n     */\r\n    public containingTextNode(node: XmlTextNode): XmlGeneralNode {\r\n\r\n        if (!node)\r\n            return null;\r\n\r\n        if (!XmlNode.isTextNode(node))\r\n            throw new Error(`'Invalid argument ${nameof(node)}. Expected a XmlTextNode.`);\r\n\r\n        return XmlNode.findParentByName(node, DocxParser.TEXT_NODE) as XmlGeneralNode;\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first run node.\r\n     */\r\n    public containingRunNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.RUN_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first paragraph node.\r\n     */\r\n    public containingParagraphNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.PARAGRAPH_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first \"table row\" node.\r\n     */\r\n    public containingTableRowNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.TABLE_ROW_NODE);\r\n    }\r\n}","export * from './docx';\r\nexport * from './docxParser';\r\n","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { Binary, Path, sha1 } from '../utils';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * Handles media files of the main document.\r\n */\r\nexport class MediaFiles {\r\n\r\n    private static readonly mediaDir = 'word/media';\r\n\r\n    private hashes: IMap<string>;\r\n    private readonly files = new Map<Binary, string>();\r\n    private nextFileId = 0;\r\n\r\n    constructor(private readonly zip: Zip) {\r\n    }\r\n\r\n    /**\r\n     * Returns the media file path.\r\n     */\r\n    public async add(mediaFile: Binary, mime: MimeType): Promise<string> {\r\n\r\n        // check if already added\r\n        if (this.files.has(mediaFile))\r\n            return this.files.get(mediaFile);\r\n\r\n        // hash existing media files\r\n        await this.hashMediaFiles();\r\n\r\n        // hash the new file  \r\n        // Note: Even though hashing the base64 string may seem inefficient\r\n        // (requires extra step in some cases) in practice it is significantly\r\n        // faster than hashing a 'binarystring'.\r\n        const base64 = await Binary.toBase64(mediaFile);\r\n        const hash = sha1(base64);\r\n\r\n        // check if file already exists\r\n        // note: this can be optimized by keeping both mapping by filename as well as by hash\r\n        let path = Object.keys(this.hashes).find(p => this.hashes[p] === hash);\r\n        if (path)\r\n            return path;\r\n\r\n        // generate unique media file name\r\n        const extension = MimeTypeHelper.getDefaultExtension(mime);\r\n        do {\r\n            this.nextFileId++;\r\n            path = `${MediaFiles.mediaDir}/media${this.nextFileId}.${extension}`;\r\n        } while (this.hashes[path]);\r\n\r\n        // add media to zip\r\n        await this.zip.setFile(path, mediaFile);\r\n\r\n        // add media to our lookups\r\n        this.hashes[path] = hash;\r\n        this.files.set(mediaFile, path);\r\n\r\n        // return\r\n        return path;\r\n    }\r\n\r\n    public async count(): Promise<number> {\r\n        await this.hashMediaFiles();\r\n        return Object.keys(this.hashes).length;\r\n    }\r\n\r\n    private async hashMediaFiles(): Promise<void> {\r\n        if (this.hashes)\r\n            return;\r\n\r\n        this.hashes = {};\r\n        for (const path of this.zip.listFiles()) {\r\n\r\n            if (!path.startsWith(MediaFiles.mediaDir))\r\n                continue;\r\n\r\n            const filename = Path.getFilename(path);\r\n            if (!filename)\r\n                continue;\r\n\r\n            const fileData = await this.zip.getFile(path).getContentBase64();\r\n            const fileHash = sha1(fileData);\r\n            this.hashes[filename] = fileHash;\r\n        }\r\n    }\r\n}","import { Path } from '../utils';\r\nimport { XmlGeneralNode, XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * Handles the relationship logic of a single docx \"part\".  \r\n * http://officeopenxml.com/anatomyofOOXML.php\r\n */\r\nexport class Rels {\r\n\r\n    private root: XmlNode;\r\n    private relIds: IMap<boolean>;\r\n    private relTargets: IMap<string>;\r\n    private nextRelId = 0;\r\n\r\n    private readonly partDir: string;\r\n    private readonly relsFilePath: string;\r\n\r\n    constructor(\r\n        partPath: string,\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n\r\n        this.partDir = Path.getDirectory(partPath);\r\n        const partFilename = Path.getFilename(partPath);\r\n        this.relsFilePath = `${this.partDir}/_rels/${partFilename}.rels`;\r\n    }\r\n\r\n    /**\r\n     * Returns the rel ID.\r\n     */\r\n    public async add(relTarget: string, relType: string, additionalAttributes?: IMap<string>): Promise<string> {\r\n\r\n        // if relTarget is an internal file it should be relative to the part dir\r\n        if (relTarget.startsWith(this.partDir)) {\r\n            relTarget = relTarget.substr(this.partDir.length + 1);\r\n        }\r\n\r\n        // parse rels file\r\n        await this.parseRelsFile();\r\n\r\n        // already exists?\r\n        const relTargetKey = this.getRelTargetKey(relType, relTarget);\r\n        let relId = this.relTargets[relTargetKey];\r\n        if (relId)\r\n            return relId;\r\n\r\n        // add rel node\r\n        relId = this.getNextRelId();\r\n        const relNode = XmlNode.createGeneralNode('Relationship');\r\n        relNode.attributes = Object.assign({\r\n            \"Id\": relId,\r\n            \"Type\": relType,\r\n            \"Target\": relTarget\r\n        }, additionalAttributes);\r\n        this.root.childNodes.push(relNode);\r\n\r\n        // update lookups\r\n        this.relIds[relId] = true;\r\n        this.relTargets[relTargetKey] = relId;\r\n\r\n        // return\r\n        return relId;\r\n    }\r\n\r\n    /**\r\n     * Save the rels file back to the zip.  \r\n     * Called automatically by the holding `Docx` before exporting.\r\n     */\r\n    public async save(): Promise<void> {\r\n\r\n        // not change - no need to save\r\n        if (!this.root)\r\n            return;\r\n\r\n        const xmlContent = this.xmlParser.serialize(this.root);\r\n        this.zip.setFile(this.relsFilePath, xmlContent);\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private getNextRelId(): string {\r\n\r\n        let relId: string;;\r\n        do {\r\n            this.nextRelId++;\r\n            relId = 'rId' + this.nextRelId;\r\n        } while (this.relIds[relId]);\r\n\r\n        return relId;\r\n    }\r\n\r\n    private async parseRelsFile(): Promise<void> {\r\n        if (this.root)\r\n            return;\r\n\r\n        // parse the xml file\r\n        let relsXml: string;\r\n        const relsFile = this.zip.getFile(this.relsFilePath);\r\n        if (relsFile) {\r\n            relsXml = await relsFile.getContentText();\r\n        } else {\r\n            relsXml = `<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\r\n                      </Relationships>`;\r\n        }\r\n        this.root = this.xmlParser.parse(relsXml);\r\n\r\n        // build lookups\r\n        this.relIds = {};\r\n        this.relTargets = {};\r\n        for (const rel of this.root.childNodes) {\r\n\r\n            const attributes = (rel as XmlGeneralNode).attributes;\r\n            if (!attributes)\r\n                continue;\r\n\r\n            // relIds lookup\r\n            const idAttr = attributes['Id'];\r\n            if (!idAttr)\r\n                continue;\r\n            this.relIds[idAttr] = true;\r\n\r\n            // rel target lookup\r\n            const typeAttr = attributes['Type'];\r\n            const targetAttr = attributes['Target'];\r\n            if (typeAttr && targetAttr) {\r\n                const relTargetKey = this.getRelTargetKey(typeAttr, targetAttr);\r\n                this.relTargets[relTargetKey] = idAttr;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getRelTargetKey(type: string, target: string): string {\r\n        return `${type} - ${target}`;\r\n    }\r\n}","import { ImagePlugin } from './imagePlugin';\r\nimport { LinkPlugin } from './linkPlugin';\r\nimport { LoopPlugin } from './loopPlugin';\r\nimport { RawXmlPlugin } from './rawXmlPlugin';\r\nimport { TemplatePlugin } from './templatePlugin';\r\nimport { TextPlugin } from './textPlugin';\r\n\r\nexport function createDefaultPlugins(): TemplatePlugin[] {\r\n    return [\r\n        new LoopPlugin(), \r\n        new RawXmlPlugin(),\r\n        new ImagePlugin(),\r\n        new LinkPlugin(),\r\n        new TextPlugin()\r\n    ];\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { MimeTypeHelper } from '../mimeType';\r\nimport { XmlGeneralNode, XmlNode } from '../xml';\r\nimport { ImageContent } from './imageContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\n/**\r\n * Apparently it is not that important for the ID to be unique...  \r\n * Word displays two images correctly even if they both have the same ID.\r\n * Further more, Word will assign each a unique ID upon saving (it assigns\r\n * consecutive integers starting with 1).  \r\n * \r\n * Note: The same principal applies to image names.\r\n *\r\n * Tested in Word v1908\r\n */\r\nlet nextImageId = 1;\r\n\r\nexport class ImagePlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = 'image';\r\n\r\n    public async simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const content = data.getScopeData() as ImageContent;\r\n        if (!content || !content.source) {\r\n            XmlNode.remove(wordTextNode);\r\n            return;\r\n        }\r\n\r\n        // add the image file into the archive\r\n        const mediaFilePath = await context.docx.mediaFiles.add(content.source, content.format);\r\n        const relType = MimeTypeHelper.getOfficeRelType(content.format);\r\n        const relId = await context.docx.rels.add(mediaFilePath, relType);\r\n        await context.docx.contentTypes.ensureContentType(content.format);\r\n\r\n        // create the xml markup\r\n        const imageId = nextImageId++;\r\n        const imageXml = this.createMarkup(imageId, relId, content.width, content.height);\r\n\r\n        XmlNode.insertAfter(imageXml, wordTextNode);\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n\r\n    private createMarkup(imageId: number, relId: string, width: number, height: number): XmlNode {\r\n\r\n        // http://officeopenxml.com/drwPicInline.php\r\n\r\n        //\r\n        // Performance note:  \r\n        //\r\n        // I've tried to improve the markup generation performance by parsing\r\n        // the string once and caching the result (and of course customizing it\r\n        // per image) but it made no change whatsoever (in both cases 1000 items\r\n        // loop takes around 8 seconds on my machine) so I'm sticking with this\r\n        // approach which I find to be more readable.\r\n        //\r\n\r\n        const name = `Picture ${imageId}`;\r\n        const markupText = `\r\n            <w:drawing>\r\n                <wp:inline distT=\"0\" distB=\"0\" distL=\"0\" distR=\"0\">\r\n                    <wp:extent cx=\"${this.pixelsToEmu(width)}\" cy=\"${this.pixelsToEmu(height)}\"/>\r\n                    <wp:effectExtent l=\"0\" t=\"0\" r=\"0\" b=\"0\"/>\r\n                    <wp:docPr id=\"${imageId}\" name=\"${name}\"/>\r\n                    <wp:cNvGraphicFramePr>\r\n                        <a:graphicFrameLocks xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" noChangeAspect=\"1\"/>\r\n                    </wp:cNvGraphicFramePr>\r\n                    <a:graphic xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">\r\n                        <a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/picture\">\r\n                            ${this.pictureMarkup(name, relId, width, height)}\r\n                        </a:graphicData>\r\n                    </a:graphic>\r\n                </wp:inline>\r\n            </w:drawing>\r\n        `;\r\n\r\n        const markupXml = this.utilities.xmlParser.parse(markupText) as XmlGeneralNode;\r\n        XmlNode.removeEmptyTextNodes(markupXml); // remove whitespace\r\n\r\n        return markupXml;\r\n    }\r\n\r\n    private pictureMarkup(name: string, relId: string, width: number, height: number) {\r\n\r\n        // http://officeopenxml.com/drwPic.php\r\n\r\n        // legend:\r\n        // nvPicPr - non-visual picture properties - id, name, etc.\r\n        // blipFill - binary large image (or) picture fill - image size, image fill, etc.\r\n        // spPr - shape properties - frame size, frame fill, etc.\r\n\r\n        return `\r\n            <pic:pic xmlns:pic=\"http://schemas.openxmlformats.org/drawingml/2006/picture\">\r\n                <pic:nvPicPr>\r\n                    <pic:cNvPr id=\"0\" name=\"${name}\"/>\r\n                    <pic:cNvPicPr>\r\n                        <a:picLocks noChangeAspect=\"1\" noChangeArrowheads=\"1\"/>\r\n                    </pic:cNvPicPr>\r\n                </pic:nvPicPr>\r\n                <pic:blipFill>\r\n                    <a:blip r:embed=\"${relId}\">\r\n                        <a:extLst>\r\n                            <a:ext uri=\"{28A0092B-C50C-407E-A947-70E740481C1C}\">\r\n                                <a14:useLocalDpi xmlns:a14=\"http://schemas.microsoft.com/office/drawing/2010/main\" val=\"0\"/>\r\n                            </a:ext>\r\n                        </a:extLst>\r\n                    </a:blip>\r\n                    <a:srcRect/>\r\n                    <a:stretch>\r\n                        <a:fillRect/>\r\n                    </a:stretch>\r\n                </pic:blipFill>\r\n                <pic:spPr bwMode=\"auto\">\r\n                    <a:xfrm>\r\n                        <a:off x=\"0\" y=\"0\"/>\r\n                        <a:ext cx=\"${this.pixelsToEmu(width)}\" cy=\"${this.pixelsToEmu(height)}\"/>\r\n                    </a:xfrm>\r\n                    <a:prstGeom prst=\"rect\">\r\n                        <a:avLst/>\r\n                    </a:prstGeom>\r\n                    <a:noFill/>\r\n                    <a:ln>\r\n                        <a:noFill/>\r\n                    </a:ln>\r\n                </pic:spPr>\r\n            </pic:pic>\r\n        `;\r\n    }\r\n\r\n    private pixelsToEmu(pixels: number): number {\r\n\r\n        // https://stackoverflow.com/questions/20194403/openxml-distance-size-units\r\n        // https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-units#other-units-of-measurement\r\n        // https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML\r\n        // http://www.java2s.com/Code/CSharp/2D-Graphics/ConvertpixelstoEMUEMUtopixels.htm\r\n\r\n        return Math.round(pixels * 9525);\r\n    }\r\n}","export * from './defaultPlugins';\r\nexport * from './imageContent';\r\nexport * from './imagePlugin';\r\nexport * from './linkContent';\r\nexport * from './linkPlugin';\r\nexport * from './loopPlugin';\r\nexport * from './pluginContent';\r\nexport * from './rawXmlContent';\r\nexport * from './rawXmlPlugin';\r\nexport * from './templatePlugin';\r\nexport * from './textPlugin';\r\n","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlNode } from '../xml';\r\nimport { LinkContent } from './linkContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport class LinkPlugin extends TemplatePlugin {\r\n\r\n    private static readonly linkRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';\r\n\r\n    public readonly contentType = 'link';\r\n\r\n    public async simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const content = data.getScopeData() as LinkContent;\r\n        if (!content || !content.target) {\r\n            XmlNode.remove(wordTextNode);\r\n            return;\r\n        }\r\n\r\n        // add rel\r\n        const linkAttributes = { TargetMode: 'External' };\r\n        const relId = await context.docx.rels.add(content.target, LinkPlugin.linkRelType, linkAttributes);\r\n\r\n        // generate markup\r\n        const wordRunNode = this.utilities.docxParser.containingRunNode(wordTextNode);\r\n        const linkMarkup = this.generateMarkup(content, relId, wordRunNode);\r\n\r\n        // add to document\r\n        this.insertHyperlinkNode(linkMarkup, wordRunNode);\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n\r\n    private generateMarkup(content: LinkContent, relId: string, wordRunNode: XmlNode) {\r\n\r\n        // http://officeopenxml.com/WPhyperlink.php\r\n\r\n        const markupText = `\r\n            <w:hyperlink r:id=\"${relId}\" w:history=\"1\">\r\n                <w:r>\r\n                    <w:t>${content.text || content.target}</w:t>\r\n                </w:r>\r\n            </w:hyperlink>\r\n        `;\r\n        const markupXml = this.utilities.xmlParser.parse(markupText);\r\n        XmlNode.removeEmptyTextNodes(markupXml); // remove whitespace\r\n\r\n        // copy props from original run node (preserve style)        \r\n        const runProps = wordRunNode.childNodes.find(node => node.nodeName === DocxParser.RUN_PROPERTIES_NODE);\r\n        if (runProps) {\r\n            const linkRunProps = XmlNode.cloneNode(runProps, true);\r\n            markupXml.childNodes[0].childNodes.unshift(linkRunProps);\r\n        }\r\n\r\n        return markupXml;\r\n    }\r\n\r\n    private insertHyperlinkNode(linkMarkup: XmlNode, wordRunNode: XmlNode) {\r\n        \r\n        const textNodesInRun = wordRunNode.childNodes.filter(node => node.nodeName === DocxParser.TEXT_NODE);\r\n        if (textNodesInRun.length > 1) {\r\n            // will this ever happen?\r\n            throw new Error(\r\n                'Attempt to insert link to run node with multiple text nodes - not implemented... ' + \r\n                'If you encounter this error please open an issue at https://github.com/alonrbar/easy-template-x/issues'\r\n            );\r\n        }\r\n\r\n        XmlNode.insertAfter(linkMarkup, wordRunNode);\r\n    }\r\n}","export * from './iLoopStrategy';\r\nexport * from './loopListStrategy';\r\nexport * from './loopParagraphStrategy';\r\nexport * from './loopTableStrategy';\r\n","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopListStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        const containingParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        return this.utilities.docxParser.isListParagraph(containingParagraph);\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        const firstParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        const lastParagraph = this.utilities.docxParser.containingParagraphNode(closeTag.xmlTextNode);\r\n        const paragraphsToRepeat = XmlNode.siblingsInRange(firstParagraph, lastParagraph);\r\n\r\n        // remove the loop tags\r\n        XmlNode.remove(openTag.xmlTextNode);\r\n        XmlNode.remove(closeTag.xmlTextNode);\r\n\r\n        return {\r\n            firstNode: firstParagraph,\r\n            nodesToRepeat: paragraphsToRepeat,\r\n            lastNode: lastParagraph\r\n        };\r\n    }\r\n\r\n    public mergeBack(paragraphGroups: XmlNode[][], firstParagraph: XmlNode, lastParagraphs: XmlNode): void {\r\n\r\n        for (const curParagraphsGroup of paragraphGroups) {\r\n            for (const paragraph of curParagraphsGroup) {\r\n                XmlNode.insertBefore(paragraph, lastParagraphs);\r\n            }\r\n        }\r\n\r\n        // remove the old paragraphs\r\n        XmlNode.remove(firstParagraph);\r\n        if (firstParagraph !== lastParagraphs) {\r\n            XmlNode.remove(lastParagraphs);\r\n        }\r\n    }\r\n}","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopParagraphStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        return true;\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        // gather some info\r\n        let firstParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        let lastParagraph = this.utilities.docxParser.containingParagraphNode(closeTag.xmlTextNode);\r\n        const areSame = (firstParagraph === lastParagraph);\r\n        const parent = firstParagraph.parentNode;\r\n        const firstParagraphIndex = parent.childNodes.indexOf(firstParagraph);\r\n        const lastParagraphIndex = areSame ? firstParagraphIndex : parent.childNodes.indexOf(lastParagraph);\r\n\r\n        // split first paragraphs\r\n        let splitResult = XmlNode.splitByChild(firstParagraph, openTag.xmlTextNode, true);\r\n        firstParagraph = splitResult[0];\r\n        const firstParagraphSplit = splitResult[1];\r\n        if (areSame)\r\n            lastParagraph = firstParagraphSplit;\r\n\r\n        // split last paragraph\r\n        splitResult = XmlNode.splitByChild(lastParagraph, closeTag.xmlTextNode, true);\r\n        const lastParagraphSplit = splitResult[0];\r\n        lastParagraph = splitResult[1];\r\n\r\n        // fix references\r\n        XmlNode.removeChild(parent, firstParagraphIndex + 1);\r\n        if (!areSame)\r\n            XmlNode.removeChild(parent, lastParagraphIndex);\r\n        firstParagraphSplit.parentNode = null;\r\n        lastParagraphSplit.parentNode = null;\r\n\r\n        // extract all paragraphs in between\r\n        let middleParagraphs: XmlNode[];\r\n        if (areSame) {\r\n            this.utilities.docxParser.joinParagraphs(firstParagraphSplit, lastParagraphSplit);\r\n            middleParagraphs = [firstParagraphSplit];\r\n        } else {\r\n            const inBetween = XmlNode.removeSiblings(firstParagraph, lastParagraph);\r\n            middleParagraphs = [firstParagraphSplit].concat(inBetween).concat(lastParagraphSplit);\r\n        }\r\n\r\n        return {\r\n            firstNode: firstParagraph,\r\n            nodesToRepeat: middleParagraphs,\r\n            lastNode: lastParagraph\r\n        };\r\n    }\r\n\r\n    public mergeBack(middleParagraphs: XmlNode[][], firstParagraph: XmlNode, lastParagraph: XmlNode): void {\r\n\r\n        let mergeTo = firstParagraph;\r\n        for (const curParagraphsGroup of middleParagraphs) {\r\n\r\n            // merge first paragraphs\r\n            this.utilities.docxParser.joinParagraphs(mergeTo, curParagraphsGroup[0]);\r\n\r\n            // add middle and last paragraphs to the original document\r\n            for (let i = 1; i < curParagraphsGroup.length; i++) {\r\n                XmlNode.insertBefore(curParagraphsGroup[i], lastParagraph);\r\n                mergeTo = curParagraphsGroup[i];\r\n            }\r\n        }\r\n\r\n        // merge last paragraph\r\n        this.utilities.docxParser.joinParagraphs(mergeTo, lastParagraph);\r\n\r\n        // remove the old last paragraph (was merged into the new one)\r\n        XmlNode.remove(lastParagraph);\r\n    }\r\n}\r\n","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopTableStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        const containingParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        if (!containingParagraph.parentNode)\r\n            return false;\r\n        return this.utilities.docxParser.isTableCellNode(containingParagraph.parentNode);\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        const firstRow = this.utilities.docxParser.containingTableRowNode(openTag.xmlTextNode);\r\n        const lastRow = this.utilities.docxParser.containingTableRowNode(closeTag.xmlTextNode);\r\n        const rowsToRepeat = XmlNode.siblingsInRange(firstRow, lastRow);\r\n\r\n        // remove the loop tags\r\n        XmlNode.remove(openTag.xmlTextNode);\r\n        XmlNode.remove(closeTag.xmlTextNode);\r\n\r\n        return {\r\n            firstNode: firstRow,\r\n            nodesToRepeat: rowsToRepeat,\r\n            lastNode: lastRow\r\n        };\r\n    }\r\n\r\n    public mergeBack(rowGroups: XmlNode[][], firstRow: XmlNode, lastRow: XmlNode): void {\r\n\r\n        for (const curRowsGroup of rowGroups) {\r\n            for (const row of curRowsGroup) {\r\n                XmlNode.insertBefore(row, lastRow);\r\n            }\r\n        }\r\n\r\n        // remove the old rows\r\n        XmlNode.remove(firstRow);\r\n        if (firstRow !== lastRow) {\r\n            XmlNode.remove(lastRow);\r\n        }\r\n    }\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { TemplateData } from '../templateData';\r\nimport { last } from '../utils';\r\nimport { XmlNode } from '../xml';\r\nimport { ILoopStrategy, LoopListStrategy, LoopParagraphStrategy, LoopTableStrategy } from './loop';\r\nimport { PluginUtilities, TemplatePlugin } from './templatePlugin';\r\n\r\nexport const LOOP_CONTENT_TYPE = 'loop';\r\n\r\nexport class LoopPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = LOOP_CONTENT_TYPE;\r\n\r\n    private readonly loopStrategies: ILoopStrategy[] = [\r\n        new LoopTableStrategy(),\r\n        new LoopListStrategy(),\r\n        new LoopParagraphStrategy() // the default strategy\r\n    ];\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n        this.loopStrategies.forEach(strategy => strategy.setUtilities(utilities));\r\n    }    \r\n\r\n    public async containerTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        let value = data.getScopeData() as TemplateData[];\r\n\r\n        if (!value || !Array.isArray(value) || !value.length)\r\n            value = [];\r\n\r\n        // vars\r\n        const openTag = tags[0];\r\n        const closeTag = last(tags);\r\n\r\n        // select the suitable strategy\r\n        const loopStrategy = this.loopStrategies.find(strategy => strategy.isApplicable(openTag, closeTag));\r\n        if (!loopStrategy)\r\n            throw new Error(`No loop strategy found for tag '${openTag.rawText}'.`);\r\n\r\n        // prepare to loop\r\n        const { firstNode, nodesToRepeat, lastNode } = loopStrategy.splitBefore(openTag, closeTag);\r\n\r\n        // repeat (loop) the content\r\n        const repeatedNodes = this.repeat(nodesToRepeat, value.length);\r\n\r\n        // recursive compilation \r\n        // (this step can be optimized in the future if we'll keep track of the\r\n        // path to each token and use that to create new tokens instead of\r\n        // search through the text again)\r\n        const compiledNodes = await this.compile(repeatedNodes, data, context);\r\n\r\n        // merge back to the document\r\n        loopStrategy.mergeBack(compiledNodes, firstNode, lastNode);\r\n    }\r\n\r\n    private repeat(nodes: XmlNode[], times: number): XmlNode[][] {\r\n        if (!nodes.length || !times)\r\n            return [];\r\n\r\n        const allResults: XmlNode[][] = [];\r\n\r\n        for (let i = 0; i < times; i++) {\r\n            const curResult = nodes.map(node => XmlNode.cloneNode(node, true));\r\n            allResults.push(curResult);\r\n        }\r\n\r\n        return allResults;\r\n    }\r\n\r\n    private async compile(nodeGroups: XmlNode[][], data: ScopeData, context: TemplateContext): Promise<XmlNode[][]> {\r\n        const compiledNodeGroups: XmlNode[][] = [];\r\n\r\n        // compile each node group with it's relevant data\r\n        for (let i = 0; i < nodeGroups.length; i++) {\r\n\r\n            // create dummy root node\r\n            const curNodes = nodeGroups[i];\r\n            const dummyRootNode = XmlNode.createGeneralNode('dummyRootNode');\r\n            curNodes.forEach(node => XmlNode.appendChild(dummyRootNode, node));\r\n\r\n            // compile the new root\r\n            data.path.push(i);\r\n            await this.utilities.compiler.compile(dummyRootNode, data, context);\r\n            data.path.pop();\r\n\r\n            // disconnect from dummy root\r\n            const curResult: XmlNode[] = [];\r\n            while (dummyRootNode.childNodes && dummyRootNode.childNodes.length) {\r\n                const child = XmlNode.removeChild(dummyRootNode, 0);\r\n                curResult.push(child);\r\n            }\r\n            compiledNodeGroups.push(curResult);\r\n        }\r\n\r\n        return compiledNodeGroups;\r\n    }\r\n}","\r\nexport interface PluginContent {\r\n    _type: string;\r\n}\r\n\r\nexport const PluginContent = {\r\n    isPluginContent(content: any): content is PluginContent {\r\n        return !!content && typeof content._type === 'string';\r\n    }\r\n};","import { ScopeData, Tag } from '../compilation';\r\nimport { XmlNode } from '../xml';\r\nimport { RawXmlContent } from './rawXmlContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport class RawXmlPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = 'rawXml';\r\n\r\n    /**\r\n     * Replace the current <w:t> node with the specified xml markup.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData): void {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const value = data.getScopeData() as RawXmlContent;\r\n        if (value && typeof value.xml === 'string') {\r\n            const newNode = this.utilities.xmlParser.parse(value.xml);\r\n            XmlNode.insertBefore(newNode, wordTextNode);\r\n        }\r\n\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n}","import { ScopeData, Tag, TemplateCompiler, TemplateContext } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlParser } from '../xml';\r\n\r\nexport interface PluginUtilities {\r\n    compiler: TemplateCompiler;\r\n    docxParser: DocxParser;\r\n    xmlParser: XmlParser;\r\n}\r\n\r\n/* eslint-disable @typescript-eslint/member-ordering */\r\n\r\nexport abstract class TemplatePlugin {\r\n\r\n    /**\r\n     * The content type this plugin handles.\r\n     */\r\n    public abstract get contentType(): string;\r\n\r\n    protected utilities: PluginUtilities;\r\n\r\n    /**\r\n     * Called by the TemplateHandler at runtime.\r\n     */\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    /**\r\n     * This method is called for each self-closing tag.\r\n     * It should implement the specific document manipulation required by the tag.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): void | Promise<void> {\r\n        // noop\r\n    }\r\n\r\n    /**\r\n     * This method is called for each container tag. It should implement the\r\n     * specific document manipulation required by the tag.\r\n     *\r\n     * @param tags All tags between the opening tag and closing tag (inclusive,\r\n     * i.e. tags[0] is the opening tag and the last item in the tags array is\r\n     * the closing tag).\r\n     */\r\n    public containerTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): void | Promise<void> {\r\n        // noop\r\n    }\r\n}","import { ScopeData, Tag } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlNode, XmlTextNode } from '../xml';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport const TEXT_CONTENT_TYPE = 'text';\r\n\r\nexport class TextPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = TEXT_CONTENT_TYPE;\r\n\r\n    /**\r\n     * Replace the node text content with the specified value.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData): void {\r\n\r\n        const value = data.getScopeData();\r\n        const stringValue = (value === null || value === undefined) ? '' : value.toString();\r\n        const lines = stringValue.split('\\n');\r\n\r\n        if (lines.length < 2) {\r\n            this.replaceSingleLine(tag.xmlTextNode, lines.length ? lines[0] : '');\r\n        } else {\r\n            this.replaceMultiLine(tag.xmlTextNode, lines);\r\n        }\r\n    }\r\n\r\n    private replaceSingleLine(textNode: XmlTextNode, text: string) {\r\n\r\n        // set text\r\n        textNode.textContent = text;\r\n\r\n        // make sure leading and trailing whitespace are preserved\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(textNode);\r\n        this.utilities.docxParser.setSpacePreserveAttribute(wordTextNode);\r\n    }\r\n\r\n    private replaceMultiLine(textNode: XmlTextNode, lines: string[]) {\r\n\r\n        const runNode = this.utilities.docxParser.containingRunNode(textNode);\r\n\r\n        // first line\r\n        textNode.textContent = lines[0];\r\n\r\n        // other lines\r\n        for (let i = 1; i < lines.length; i++) {\r\n\r\n            // add line break\r\n            const lineBreak = this.getLineBreak();\r\n            XmlNode.appendChild(runNode, lineBreak);\r\n\r\n            // add text\r\n            const lineNode = this.createWordTextNode(lines[i]);\r\n            XmlNode.appendChild(runNode, lineNode);\r\n        }\r\n    }\r\n\r\n    private getLineBreak(): XmlNode {\r\n        return XmlNode.createGeneralNode('w:br');\r\n    }\r\n\r\n    private createWordTextNode(text: string): XmlNode {\r\n        const wordTextNode = XmlNode.createGeneralNode(DocxParser.TEXT_NODE);\r\n\r\n        wordTextNode.attributes = {};\r\n        this.utilities.docxParser.setSpacePreserveAttribute(wordTextNode);\r\n\r\n        wordTextNode.childNodes = [\r\n            XmlNode.createTextNode(text)\r\n        ];\r\n\r\n        return wordTextNode;\r\n    }\r\n}","import { DelimiterSearcher, ScopeData, Tag, TagParser, TemplateCompiler, TemplateContext } from './compilation';\r\nimport { MalformedFileError } from './errors';\r\nimport { Docx, DocxParser } from './office';\r\nimport { TemplateHandlerOptions } from './templateHandlerOptions';\r\nimport { Binary } from './utils';\r\nimport { XmlNode, XmlParser } from './xml';\r\nimport { Zip } from './zip';\r\n\r\nexport class TemplateHandler {\r\n\r\n    /**\r\n     * Version number of the `easy-template-x` library.\r\n     */\r\n    public readonly version = (typeof EASY_VERSION !== 'undefined' ? EASY_VERSION : 'null');\r\n\r\n    private readonly xmlParser = new XmlParser();\r\n    private readonly docxParser: DocxParser;\r\n    private readonly compiler: TemplateCompiler;\r\n\r\n    private readonly options: TemplateHandlerOptions;\r\n\r\n    constructor(options?: TemplateHandlerOptions) {\r\n        this.options = new TemplateHandlerOptions(options);\r\n\r\n        //\r\n        // this is the library's composition root\r\n        //\r\n\r\n        this.docxParser = new DocxParser(this.xmlParser);\r\n\r\n        const delimiterSearcher = new DelimiterSearcher(this.docxParser);\r\n        delimiterSearcher.startDelimiter = this.options.delimiters.tagStart;\r\n        delimiterSearcher.endDelimiter = this.options.delimiters.tagEnd;\r\n        delimiterSearcher.maxXmlDepth = this.options.maxXmlDepth;\r\n\r\n        const tagParser = new TagParser(this.docxParser, this.options.delimiters);\r\n\r\n        this.compiler = new TemplateCompiler(\r\n            delimiterSearcher,\r\n            tagParser,\r\n            this.options.plugins,\r\n            this.options.defaultContentType,\r\n            this.options.containerContentType\r\n        );\r\n\r\n        this.options.plugins.forEach(plugin => {\r\n            plugin.setUtilities({\r\n                xmlParser: this.xmlParser,\r\n                docxParser: this.docxParser,\r\n                compiler: this.compiler\r\n            });\r\n        });\r\n    }\r\n\r\n    public async process<T extends Binary>(templateFile: T, data: any): Promise<T> {\r\n\r\n        // load the docx file\r\n        const docx = await this.loadDocx(templateFile);\r\n        const document = await docx.getDocument();\r\n\r\n        // process content (do replacements)        \r\n        const scopeData = new ScopeData(data);\r\n        const context: TemplateContext = {\r\n            docx\r\n        };\r\n        await this.compiler.compile(document, scopeData, context);\r\n\r\n        // export the result\r\n        return docx.export(templateFile.constructor as Constructor<T>);\r\n    }\r\n\r\n    public async parseTags(templateFile: Binary): Promise<Tag[]> {\r\n        const docx = await this.loadDocx(templateFile);\r\n        const document = await docx.getDocument();\r\n        return this.compiler.parseTags(document);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of the main document file.\r\n     */\r\n    public async getText(docxFile: Binary): Promise<string> {\r\n        const docx = await this.loadDocx(docxFile);\r\n        const text = await docx.getDocumentText();\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Get the xml tree of the main document file.\r\n     */\r\n    public async getXml(docxFile: Binary): Promise<XmlNode> {\r\n        const docx = await this.loadDocx(docxFile);\r\n        const document = await docx.getDocument();\r\n        return document;\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private async loadDocx(file: Binary): Promise<Docx> {\r\n\r\n        // load the zip file\r\n        let zip: Zip;\r\n        try {\r\n            zip = await Zip.load(file);\r\n        } catch {\r\n            throw new MalformedFileError('docx');\r\n        }\r\n\r\n        // load the docx file\r\n        const docx = this.docxParser.load(zip);\r\n        return docx;\r\n    }\r\n}","import { Delimiters } from './delimiters';\r\nimport { createDefaultPlugins, LOOP_CONTENT_TYPE, TemplatePlugin, TEXT_CONTENT_TYPE } from './plugins';\r\n\r\nexport class TemplateHandlerOptions {\r\n\r\n    public plugins?: TemplatePlugin[] = createDefaultPlugins();\r\n\r\n    public defaultContentType = TEXT_CONTENT_TYPE;\r\n\r\n    public containerContentType = LOOP_CONTENT_TYPE;\r\n\r\n    public delimiters?= new Delimiters();\r\n\r\n    public maxXmlDepth? = 20;\r\n\r\n    constructor(initial?: Partial<TemplateHandlerOptions>) {\r\n        Object.assign(this, initial);\r\n\r\n        if (initial) {\r\n            this.delimiters = new Delimiters(initial.delimiters);\r\n        }\r\n\r\n        if (!this.plugins.length) {\r\n            throw new Error('Plugins list can not be empty');\r\n        }\r\n    }\r\n}","\r\nexport type ItemMapper<TIn, TOut = string> = (item: TIn, index: number) => TOut;\r\n\r\nexport function pushMany<T>(destArray: T[], items: T[]): void {\r\n    Array.prototype.push.apply(destArray, items);\r\n}\r\n\r\nexport function first<T>(array: T[]): T {\r\n    if (!array.length)\r\n        return undefined;\r\n    return array[0];\r\n}\r\n\r\nexport function last<T>(array: T[]): T {\r\n    if (!array.length)\r\n        return undefined;\r\n    return array[array.length - 1];\r\n}\r\n\r\nexport function toDictionary<TIn, TOut = TIn>(array: TIn[], keySelector: ItemMapper<TIn>, valueSelector?: ItemMapper<TIn, TOut>): IMap<TOut> {\r\n    if (!array.length)\r\n        return {};\r\n\r\n    const res: IMap<any> = {};\r\n    array.forEach((item, index) => {\r\n        const key = keySelector(item, index);\r\n        const value = (valueSelector ? valueSelector(item, index) : item);\r\n        if (res[key])\r\n            throw new Error(`Key '${key}' already exists in the dictionary.`);\r\n        res[key] = value;\r\n    });\r\n    return res;\r\n};","export class Base64 {\r\n\r\n    public static encode(str: string): string {\r\n        \r\n        // browser\r\n        if (typeof btoa !== 'undefined') \r\n            return btoa(str);\r\n\r\n        // node\r\n        // https://stackoverflow.com/questions/23097928/node-js-btoa-is-not-defined-error#38446960\r\n        return new Buffer(str, 'binary').toString('base64');\r\n    }\r\n}","import { Base64 } from './base64';\r\nimport { inheritsFrom } from './types';\r\n\r\nexport type Binary = Blob | Buffer | ArrayBuffer;\r\n\r\nexport const Binary = {\r\n\r\n    //\r\n    // type detection\r\n    //\r\n\r\n    isBlob(binary: any): binary is Blob {\r\n        return this.isBlobConstructor(binary.constructor);\r\n    },\r\n\r\n    isArrayBuffer(binary: any): binary is ArrayBuffer {\r\n        return this.isArrayBufferConstructor(binary.constructor);\r\n    },\r\n\r\n    isBuffer(binary: any): binary is Buffer {\r\n        return this.isBufferConstructor(binary.constructor);\r\n    },\r\n\r\n    isBlobConstructor(binaryType: Constructor<any>): binaryType is Constructor<Blob> {\r\n        return (typeof Blob !== 'undefined' && inheritsFrom(binaryType, Blob));\r\n    },\r\n\r\n    isArrayBufferConstructor(binaryType: Constructor<any>): binaryType is Constructor<ArrayBuffer> {\r\n        return (typeof ArrayBuffer !== 'undefined' && inheritsFrom(binaryType, ArrayBuffer));\r\n    },\r\n\r\n    isBufferConstructor(binaryType: Constructor<any>): binaryType is Constructor<Buffer> {\r\n        return (typeof Buffer !== 'undefined' && inheritsFrom(binaryType, Buffer));\r\n    },\r\n\r\n    //\r\n    // utilities\r\n    //\r\n\r\n    toBase64(binary: Binary): Promise<string> {\r\n\r\n        if (this.isBlob(binary)) {\r\n            return new Promise(resolve => {\r\n                const fileReader = new FileReader();\r\n                fileReader.onload = function () {\r\n                    const base64 = Base64.encode(this.result as string);\r\n                    resolve(base64);\r\n                };\r\n                fileReader.readAsBinaryString(binary);\r\n            });\r\n        }\r\n\r\n        if (this.isBuffer(binary)) {\r\n            return Promise.resolve(binary.toString('base64'));\r\n        }\r\n\r\n        if (this.isArrayBuffer(binary)) {\r\n            // https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string#42334410\r\n            const binaryStr = new Uint8Array(binary).reduce((str, byte) => str + String.fromCharCode(byte), '');\r\n            const base64 = Base64.encode(binaryStr);\r\n            return Promise.resolve(base64);\r\n        }\r\n\r\n        throw new Error(`Binary type '${(binary as any).constructor.name}' is not supported.`);\r\n    }\r\n};\r\n\r\n","export * from './array';\r\nexport * from './base64';\r\nexport * from './binary';\r\nexport * from './path';\r\nexport * from './sha1';\r\nexport * from './types';\r\n","export class Path {\r\n\r\n    public static getFilename(path: string): string {\r\n        const lastSlashIndex = path.lastIndexOf('/');\r\n        return path.substr(lastSlashIndex + 1);\r\n    }\r\n\r\n    public static getDirectory(path: string): string {\r\n        const lastSlashIndex = path.lastIndexOf('/');\r\n        return path.substring(0, lastSlashIndex);\r\n    }\r\n}","/**\r\n * Secure Hash Algorithm (SHA1)\r\n * \r\n * Taken from here: http://www.webtoolkit.info/javascript-sha1.html\r\n * \r\n * Recommended here: https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript#6122732\r\n */\r\nexport function sha1(msg: string) {\r\n\r\n    msg = utf8Encode(msg);\r\n    const msgLength = msg.length;\r\n\r\n    let i, j;\r\n\r\n    const wordArray = [];\r\n    for (i = 0; i < msgLength - 3; i += 4) {\r\n        j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 |\r\n            msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);\r\n        wordArray.push(j);\r\n    }\r\n\r\n    switch (msgLength % 4) {\r\n        case 0:\r\n            i = 0x080000000;\r\n            break;\r\n        case 1:\r\n            i = msg.charCodeAt(msgLength - 1) << 24 | 0x0800000;\r\n            break;\r\n        case 2:\r\n            i = msg.charCodeAt(msgLength - 2) << 24 | msg.charCodeAt(msgLength - 1) << 16 | 0x08000;\r\n            break;\r\n        case 3:\r\n            i = msg.charCodeAt(msgLength - 3) << 24 | msg.charCodeAt(msgLength - 2) << 16 | msg.charCodeAt(msgLength - 1) << 8 | 0x80;\r\n            break;\r\n    }\r\n    wordArray.push(i);\r\n\r\n    while ((wordArray.length % 16) != 14) {\r\n        wordArray.push(0);\r\n    }\r\n\r\n    wordArray.push(msgLength >>> 29);\r\n    wordArray.push((msgLength << 3) & 0x0ffffffff);\r\n\r\n    const w = new Array(80);\r\n    let H0 = 0x67452301;\r\n    let H1 = 0xEFCDAB89;\r\n    let H2 = 0x98BADCFE;\r\n    let H3 = 0x10325476;\r\n    let H4 = 0xC3D2E1F0;\r\n    let A, B, C, D, E;\r\n    let temp;\r\n    for (let blockStart = 0; blockStart < wordArray.length; blockStart += 16) {\r\n\r\n        for (i = 0; i < 16; i++) {\r\n            w[i] = wordArray[blockStart + i];\r\n        }\r\n        for (i = 16; i <= 79; i++) {\r\n            w[i] = rotateLeft(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);\r\n        }\r\n        A = H0;\r\n        B = H1;\r\n        C = H2;\r\n        D = H3;\r\n        E = H4;\r\n        for (i = 0; i <= 19; i++) {\r\n            temp = (rotateLeft(A, 5) + ((B & C) | (~B & D)) + E + w[i] + 0x5A827999) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 20; i <= 39; i++) {\r\n            temp = (rotateLeft(A, 5) + (B ^ C ^ D) + E + w[i] + 0x6ED9EBA1) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 40; i <= 59; i++) {\r\n            temp = (rotateLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + w[i] + 0x8F1BBCDC) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 60; i <= 79; i++) {\r\n            temp = (rotateLeft(A, 5) + (B ^ C ^ D) + E + w[i] + 0xCA62C1D6) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        H0 = (H0 + A) & 0x0ffffffff;\r\n        H1 = (H1 + B) & 0x0ffffffff;\r\n        H2 = (H2 + C) & 0x0ffffffff;\r\n        H3 = (H3 + D) & 0x0ffffffff;\r\n        H4 = (H4 + E) & 0x0ffffffff;\r\n    }\r\n    temp = cvtHex(H0) + cvtHex(H1) + cvtHex(H2) + cvtHex(H3) + cvtHex(H4);\r\n    return temp.toLowerCase();\r\n}\r\n\r\nfunction rotateLeft(n: any, s: any) {\r\n    const t4 = (n << s) | (n >>> (32 - s));\r\n    return t4;\r\n}\r\n\r\nfunction cvtHex(val: any) {\r\n    let str = \"\";\r\n    for (let i = 7; i >= 0; i--) {\r\n        const v = (val >>> (i * 4)) & 0x0f;\r\n        str += v.toString(16);\r\n    }\r\n    return str;\r\n}\r\n\r\nfunction utf8Encode(str: string) {\r\n    str = str.replace(/\\r\\n/g, \"\\n\");\r\n    let utfStr = \"\";\r\n    for (let n = 0; n < str.length; n++) {\r\n        const c = str.charCodeAt(n);\r\n        if (c < 128) {\r\n            utfStr += String.fromCharCode(c);\r\n\r\n        } else if ((c > 127) && (c < 2048)) {\r\n            utfStr += String.fromCharCode((c >> 6) | 192);\r\n            utfStr += String.fromCharCode((c & 63) | 128);\r\n\r\n        } else {\r\n            utfStr += String.fromCharCode((c >> 12) | 224);\r\n            utfStr += String.fromCharCode(((c >> 6) & 63) | 128);\r\n            utfStr += String.fromCharCode((c & 63) | 128);\r\n        }\r\n    }\r\n    return utfStr;\r\n}\r\n","\r\nexport function inheritsFrom(derived: Constructor<any>, base: Constructor<any>): boolean {\r\n    // https://stackoverflow.com/questions/14486110/how-to-check-if-a-javascript-class-inherits-another-without-creating-an-obj\r\n    return derived === base || derived.prototype instanceof base;\r\n}\r\n\r\nexport function isPromiseLike<T>(candidate: any): candidate is PromiseLike<T> {\r\n    return !!candidate && typeof candidate === 'object' && typeof candidate.then === 'function';\r\n}","export * from './xmlDepthTracker';\r\nexport * from './xmlNode';\r\nexport * from './xmlParser';\r\n","import { MaxXmlDepthError } from '../errors';\r\n\r\nexport class XmlDepthTracker {\r\n    \r\n    private depth = 0;\r\n\r\n    constructor(private readonly maxDepth: number) { }\r\n\r\n    public increment(): void {\r\n        this.depth++;\r\n        if (this.depth > this.maxDepth) {\r\n            throw new MaxXmlDepthError(this.maxDepth);\r\n        }\r\n    }\r\n\r\n    public decrement(): void {\r\n        this.depth--;\r\n    }\r\n}","import { MissingArgumentError } from '../errors';\r\nimport { last } from '../utils';\r\n\r\nexport enum XmlNodeType {\r\n    Text = \"Text\",\r\n    General = \"General\"\r\n}\r\n\r\nexport type XmlNode = XmlTextNode | XmlGeneralNode;\r\n\r\nexport interface XmlNodeBase {\r\n    nodeType: XmlNodeType;\r\n    nodeName: string;\r\n    parentNode?: XmlNode;\r\n    childNodes?: XmlNode[];\r\n    nextSibling?: XmlNode;\r\n}\r\n\r\nexport const TEXT_NODE_NAME = '#text'; // see: https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName\r\n\r\nexport interface XmlTextNode extends XmlNodeBase {\r\n    nodeType: XmlNodeType.Text;\r\n    nodeName: typeof TEXT_NODE_NAME;\r\n    textContent: string;\r\n}\r\n\r\nexport interface XmlGeneralNode extends XmlNodeBase {\r\n    nodeType: XmlNodeType.General;\r\n    attributes?: IMap<string>;\r\n}\r\n\r\nexport const XmlNode = {\r\n\r\n    //\r\n    // factories\r\n    //\r\n\r\n    createTextNode(text?: string): XmlTextNode {\r\n        return {\r\n            nodeType: XmlNodeType.Text,\r\n            nodeName: TEXT_NODE_NAME,\r\n            textContent: text\r\n        };\r\n    },\r\n\r\n    createGeneralNode(name: string): XmlGeneralNode {\r\n        return {\r\n            nodeType: XmlNodeType.General,\r\n            nodeName: name\r\n        };\r\n    },\r\n\r\n    //\r\n    // serialization\r\n    //\r\n\r\n    /**\r\n     * Encode string to make it safe to use inside xml tags.\r\n     * \r\n     * https://stackoverflow.com/questions/7918868/how-to-escape-xml-entities-in-javascript\r\n     */\r\n    encodeValue(str: string): string {\r\n        if (str === null || str === undefined)\r\n            throw new MissingArgumentError(nameof(str));\r\n        if (typeof str !== 'string')\r\n            throw new TypeError(`Expected a string, got '${(str as any).constructor.name}'.`);\r\n\r\n        return str.replace(/[<>&'\"]/g, c => {\r\n            switch (c) {\r\n                case '<': return '&lt;';\r\n                case '>': return '&gt;';\r\n                case '&': return '&amp;';\r\n                case '\\'': return '&apos;';\r\n                case '\"': return '&quot;';\r\n            }\r\n            return '';\r\n        });\r\n    },\r\n\r\n    serialize(node: XmlNode): string {\r\n        if (this.isTextNode(node))\r\n            return this.encodeValue(node.textContent || '');\r\n\r\n        // attributes\r\n        let attributes = '';\r\n        if (node.attributes) {\r\n            const attributeNames = Object.keys(node.attributes);\r\n            if (attributeNames.length) {\r\n                attributes = ' ' + attributeNames\r\n                    .map(name => `${name}=\"${node.attributes[name]}\"`)\r\n                    .join(' ');\r\n            }\r\n        }\r\n\r\n        // open tag\r\n        const hasChildren = (node.childNodes || []).length > 0;\r\n        const suffix = hasChildren ? '' : '/';\r\n        const openTag = `<${node.nodeName}${attributes}${suffix}>`;\r\n\r\n        let xml: string;\r\n\r\n        if (hasChildren) {\r\n\r\n            // child nodes\r\n            const childrenXml = node.childNodes\r\n                .map(child => this.serialize(child))\r\n                .join('');\r\n\r\n            // close tag\r\n            const closeTag = `</${node.nodeName}>`;\r\n\r\n            xml = openTag + childrenXml + closeTag;\r\n        } else {\r\n            xml = openTag;\r\n        }\r\n\r\n        return xml;\r\n    },\r\n\r\n    /**\r\n     * The conversion is always deep.\r\n     */\r\n    fromDomNode(domNode: Node): XmlNode {\r\n        let xmlNode: XmlNode;\r\n\r\n        // basic properties\r\n        if (domNode.nodeType === domNode.TEXT_NODE) {\r\n\r\n            xmlNode = this.createTextNode(domNode.textContent);\r\n\r\n        } else {\r\n\r\n            xmlNode = this.createGeneralNode(domNode.nodeName);\r\n\r\n            // attributes\r\n            if (domNode.nodeType === domNode.ELEMENT_NODE) {\r\n                const attributes = (domNode as Element).attributes;\r\n                if (attributes) {\r\n                    (xmlNode as XmlGeneralNode).attributes = {};\r\n                    for (let i = 0; i < attributes.length; i++) {\r\n                        const curAttribute = attributes.item(i);\r\n                        (xmlNode as XmlGeneralNode).attributes[curAttribute.name] = curAttribute.value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // children\r\n        if (domNode.childNodes) {\r\n            xmlNode.childNodes = [];\r\n            let prevChild: XmlNode;\r\n            for (let i = 0; i < domNode.childNodes.length; i++) {\r\n\r\n                // clone child\r\n                const domChild = domNode.childNodes.item(i);\r\n                const curChild = this.fromDomNode(domChild);\r\n\r\n                // set references                \r\n                xmlNode.childNodes.push(curChild);\r\n                curChild.parentNode = xmlNode;\r\n                if (prevChild) {\r\n                    prevChild.nextSibling = curChild;\r\n                }\r\n                prevChild = curChild;\r\n            }\r\n        }\r\n\r\n        return xmlNode as XmlNode;\r\n    },\r\n\r\n    //\r\n    // core functions\r\n    //\r\n\r\n    isTextNode(node: XmlNode): node is XmlTextNode {\r\n        if (node.nodeType === XmlNodeType.Text || node.nodeName === TEXT_NODE_NAME) {\r\n            if (!(node.nodeType === XmlNodeType.Text && node.nodeName === TEXT_NODE_NAME)) {\r\n                throw new Error(`Invalid text node. Type: '${node.nodeType}', Name: '${node.nodeName}'.`);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    cloneNode<T extends XmlNode>(node: T, deep: boolean): T {\r\n        if (!node)\r\n            throw new MissingArgumentError(nameof(node));\r\n\r\n        if (!deep) {\r\n            const clone = Object.assign({}, node);\r\n            clone.parentNode = null;\r\n            clone.childNodes = (node.childNodes ? [] : null);\r\n            clone.nextSibling = null;\r\n            return clone;\r\n        } else {\r\n            const clone = cloneNodeDeep(node);\r\n            clone.parentNode = null;\r\n            return clone;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Insert the node as a new sibling, before the original node.\r\n     *\r\n     * * **Note**: It is more efficient to use the insertChild function if you\r\n     *   already know the relevant index.\r\n     */\r\n    insertBefore(newNode: XmlNode, referenceNode: XmlNode): void {\r\n        if (!newNode)\r\n            throw new MissingArgumentError(nameof(newNode));\r\n        if (!referenceNode)\r\n            throw new MissingArgumentError(nameof(referenceNode));\r\n\r\n        if (!referenceNode.parentNode)\r\n            throw new Error(`'${nameof(referenceNode)}' has no parent`);\r\n\r\n        const childNodes = referenceNode.parentNode.childNodes;\r\n        const beforeNodeIndex = childNodes.indexOf(referenceNode);\r\n        XmlNode.insertChild(referenceNode.parentNode, newNode, beforeNodeIndex);\r\n    },\r\n\r\n    /**\r\n     * Insert the node as a new sibling, after the original node.\r\n     *\r\n     * * **Note**: It is more efficient to use the insertChild function if you\r\n     *   already know the relevant index.\r\n     */\r\n    insertAfter(newNode: XmlNode, referenceNode: XmlNode): void {\r\n        if (!newNode)\r\n            throw new MissingArgumentError(nameof(newNode));\r\n        if (!referenceNode)\r\n            throw new MissingArgumentError(nameof(referenceNode));\r\n\r\n        if (!referenceNode.parentNode)\r\n            throw new Error(`'${nameof(referenceNode)}' has no parent`);\r\n\r\n        const childNodes = referenceNode.parentNode.childNodes;\r\n        const referenceNodeIndex = childNodes.indexOf(referenceNode);\r\n        XmlNode.insertChild(referenceNode.parentNode, newNode, referenceNodeIndex + 1);\r\n    },\r\n\r\n    insertChild(parent: XmlNode, child: XmlNode, childIndex: number): void {\r\n        if (!parent)\r\n            throw new MissingArgumentError(nameof(parent));\r\n        if (XmlNode.isTextNode(parent))\r\n            throw new Error('Appending children to text nodes is forbidden');\r\n        if (!child)\r\n            throw new MissingArgumentError(nameof(child));\r\n\r\n        if (!parent.childNodes)\r\n            parent.childNodes = [];\r\n\r\n        // revert to append\r\n        if (childIndex === parent.childNodes.length) {\r\n            XmlNode.appendChild(parent, child);\r\n            return;\r\n        }\r\n\r\n        if (childIndex > parent.childNodes.length)\r\n            throw new RangeError(`Child index ${childIndex} is out of range. Parent has only ${parent.childNodes.length} child nodes.`);\r\n\r\n        // update references\r\n        child.parentNode = parent;\r\n\r\n        const childAfter = parent.childNodes[childIndex];\r\n        child.nextSibling = childAfter;\r\n\r\n        if (childIndex > 0) {\r\n            const childBefore = parent.childNodes[childIndex - 1];\r\n            childBefore.nextSibling = child;\r\n        }\r\n\r\n        // append\r\n        parent.childNodes.splice(childIndex, 0, child);\r\n    },\r\n\r\n    appendChild(parent: XmlNode, child: XmlNode): void {\r\n        if (!parent)\r\n            throw new MissingArgumentError(nameof(parent));\r\n        if (XmlNode.isTextNode(parent))\r\n            throw new Error('Appending children to text nodes is forbidden');\r\n        if (!child)\r\n            throw new MissingArgumentError(nameof(child));\r\n\r\n        if (!parent.childNodes)\r\n            parent.childNodes = [];\r\n\r\n        // update references\r\n        if (parent.childNodes.length) {\r\n            const currentLastChild = parent.childNodes[parent.childNodes.length - 1];\r\n            currentLastChild.nextSibling = child;\r\n        }\r\n        child.nextSibling = null;\r\n        child.parentNode = parent;\r\n\r\n        // append\r\n        parent.childNodes.push(child);\r\n    },\r\n\r\n    /**\r\n     * Removes the node from it's parent.\r\n     * \r\n     * * **Note**: It is more efficient to call removeChild(parent, childIndex).\r\n     */\r\n    remove(node: XmlNode): void {\r\n        if (!node)\r\n            throw new MissingArgumentError(nameof(node));\r\n\r\n        if (!node.parentNode)\r\n            throw new Error('Node has no parent');\r\n\r\n        removeChild(node.parentNode, node);\r\n    },\r\n\r\n    removeChild,\r\n\r\n    //\r\n    // utility functions\r\n    //    \r\n\r\n    /**\r\n     * Gets the last direct child text node if it exists. Otherwise creates a\r\n     * new text node, appends it to 'node' and return the newly created text\r\n     * node.\r\n     *\r\n     * The function also makes sure the returned text node has a valid string\r\n     * value.\r\n     */\r\n    lastTextChild(node: XmlNode): XmlTextNode {\r\n        if (XmlNode.isTextNode(node)) {\r\n            return node;\r\n        }\r\n\r\n        // existing text nodes\r\n        if (node.childNodes) {\r\n            const allTextNodes = node.childNodes.filter(child => XmlNode.isTextNode(child)) as XmlTextNode[];\r\n            if (allTextNodes.length) {\r\n                const lastTextNode = last(allTextNodes);\r\n                if (!lastTextNode.textContent)\r\n                    lastTextNode.textContent = '';\r\n                return lastTextNode;\r\n            }\r\n        }\r\n\r\n        // create new text node\r\n        const newTextNode: XmlTextNode = {\r\n            nodeType: XmlNodeType.Text,\r\n            nodeName: TEXT_NODE_NAME,\r\n            textContent: ''\r\n        };\r\n\r\n        XmlNode.appendChild(node, newTextNode);\r\n        return newTextNode;\r\n    },\r\n\r\n    /**\r\n     * Remove sibling nodes between 'from' and 'to' excluding both.\r\n     * Return the removed nodes.\r\n     */\r\n    removeSiblings(from: XmlNode, to: XmlNode): XmlNode[] {\r\n        if (from === to)\r\n            return [];\r\n\r\n        const removed: XmlNode[] = [];\r\n        let lastRemoved: XmlNode;\r\n        from = from.nextSibling;\r\n        while (from !== to) {\r\n            const removeMe = from;\r\n            from = from.nextSibling;\r\n\r\n            XmlNode.remove(removeMe);\r\n            removed.push(removeMe);\r\n\r\n            if (lastRemoved)\r\n                lastRemoved.nextSibling = removeMe;\r\n            lastRemoved = removeMe;\r\n        }\r\n\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Split the original node into two sibling nodes.\r\n     * Returns both nodes.\r\n     *\r\n     * @param root The node to split\r\n     * @param markerNode The node that marks the split position.      \r\n     */\r\n    splitByChild(root: XmlNode, markerNode: XmlNode, removeMarkerNode: boolean): [XmlNode, XmlNode] {\r\n\r\n        // find the split path\r\n        const path = getDescendantPath(root, markerNode);\r\n\r\n        // split\r\n        const split = XmlNode.cloneNode(root, false);\r\n        const childIndex = path[0] + 1;\r\n        while (childIndex < root.childNodes.length) {\r\n            const curChild = root.childNodes[childIndex];\r\n            XmlNode.remove(curChild);\r\n            XmlNode.appendChild(split, curChild);\r\n        }\r\n\r\n        if (root.parentNode) {\r\n            XmlNode.insertAfter(split, root);\r\n        }\r\n\r\n        // remove marker node\r\n        if (removeMarkerNode && root.childNodes.length) {\r\n            XmlNode.removeChild(root, root.childNodes.length - 1);\r\n        }\r\n\r\n        return [root, split];\r\n    },\r\n\r\n    findParent(node: XmlNode, predicate: (node: XmlNode) => boolean): XmlNode {\r\n        if (!node)\r\n            return null;\r\n\r\n        while (node.parentNode) {\r\n\r\n            if (predicate(node))\r\n                return node;\r\n\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    findParentByName(node: XmlNode, nodeName: string): XmlNode {\r\n        return XmlNode.findParent(node, n => n.nodeName === nodeName);\r\n    },\r\n\r\n    findChildByName(node: XmlNode, childName: string): XmlNode {\r\n        if (!node)\r\n            return null;\r\n        return (node.childNodes || []).find(child => child.nodeName === childName);\r\n    },\r\n\r\n    /**\r\n     * Returns all siblings between 'firstNode' and 'lastNode' inclusive.\r\n     */\r\n    siblingsInRange(firstNode: XmlNode, lastNode: XmlNode): XmlNode[] {\r\n        if (!firstNode)\r\n            throw new MissingArgumentError(nameof(firstNode));\r\n        if (!lastNode)\r\n            throw new MissingArgumentError(nameof(lastNode));\r\n\r\n        const range: XmlNode[] = [];\r\n        let curNode = firstNode;\r\n        while (curNode && curNode !== lastNode) {\r\n            range.push(curNode);\r\n            curNode = curNode.nextSibling;\r\n        }\r\n\r\n        if (!curNode)\r\n            throw new Error('Nodes are not siblings.');\r\n\r\n        range.push(lastNode);\r\n        return range;\r\n    },\r\n\r\n    /**\r\n     * Recursively removes text nodes leaving only \"general nodes\".\r\n     */\r\n    removeEmptyTextNodes(node: XmlNode): void {\r\n        recursiveRemoveEmptyTextNodes(node);\r\n    },\r\n};\r\n\r\n//\r\n// overloaded functions\r\n//\r\n\r\n/**\r\n * Remove a child node from it's parent. Returns the removed child.\r\n * \r\n * * **Note:** Prefer calling with explicit index.\r\n */\r\nfunction removeChild(parent: XmlNode, child: XmlNode): XmlNode;\r\n/**\r\n * Remove a child node from it's parent. Returns the removed child.\r\n */\r\nfunction removeChild(parent: XmlNode, childIndex: number): XmlNode;\r\nfunction removeChild(parent: XmlNode, childOrIndex: XmlNode | number): XmlNode {\r\n    if (!parent)\r\n        throw new MissingArgumentError(nameof(parent));\r\n    if (childOrIndex === null || childOrIndex === undefined)\r\n        throw new MissingArgumentError(nameof(childOrIndex));\r\n\r\n    if (!parent.childNodes || !parent.childNodes.length)\r\n        throw new Error('Parent node has node children');\r\n\r\n    // get child index\r\n    let childIndex: number;\r\n    if (typeof childOrIndex === 'number') {\r\n        childIndex = childOrIndex;\r\n    } else {\r\n        childIndex = parent.childNodes.indexOf(childOrIndex);\r\n        if (childIndex === -1)\r\n            throw new Error('Specified child node is not a child of the specified parent');\r\n    }\r\n\r\n    if (childIndex >= parent.childNodes.length)\r\n        throw new RangeError(`Child index ${childIndex} is out of range. Parent has only ${parent.childNodes.length} child nodes.`);\r\n\r\n    // update references\r\n    const child = parent.childNodes[childIndex];\r\n    if (childIndex > 0) {\r\n        const beforeChild = parent.childNodes[childIndex - 1];\r\n        beforeChild.nextSibling = child.nextSibling;\r\n    }\r\n    child.parentNode = null;\r\n    child.nextSibling = null;\r\n\r\n    // remove and return\r\n    return parent.childNodes.splice(childIndex, 1)[0];\r\n}\r\n\r\n//\r\n// private functions\r\n//\r\n\r\nfunction cloneNodeDeep<T extends XmlNode>(original: T): T {\r\n\r\n    const clone: XmlNode = ({} as any);\r\n\r\n    // basic properties\r\n    clone.nodeType = original.nodeType;\r\n    clone.nodeName = original.nodeName;\r\n    if (XmlNode.isTextNode(original)) {\r\n        (clone as XmlTextNode).textContent = original.textContent;\r\n    } else {\r\n        const attributes = (original as XmlGeneralNode).attributes;\r\n        if (attributes) {\r\n            (clone as XmlGeneralNode).attributes = Object.assign({}, attributes);\r\n        }\r\n    }\r\n\r\n    // children\r\n    if (original.childNodes) {\r\n        clone.childNodes = [];\r\n        let prevChildClone: XmlNode;\r\n        for (const child of original.childNodes) {\r\n\r\n            // clone child\r\n            const childClone = cloneNodeDeep(child);\r\n\r\n            // set references                \r\n            clone.childNodes.push(childClone);\r\n            childClone.parentNode = clone;\r\n            if (prevChildClone) {\r\n                prevChildClone.nextSibling = childClone;\r\n            }\r\n            prevChildClone = childClone;\r\n        }\r\n    }\r\n\r\n    return clone as T;\r\n}\r\n\r\nfunction getDescendantPath(root: XmlNode, descendant: XmlNode): number[] {\r\n    const path: number[] = [];\r\n\r\n    let node = descendant;\r\n    while (node !== root) {\r\n        const parent = node.parentNode;\r\n        if (!parent)\r\n            throw new Error(`Argument ${nameof(descendant)} is not a descendant of ${nameof(root)}`);\r\n\r\n        const curChildIndex = parent.childNodes.indexOf(node);\r\n        path.push(curChildIndex);\r\n\r\n        node = parent;\r\n    }\r\n\r\n    return path.reverse();\r\n}\r\n\r\nfunction recursiveRemoveEmptyTextNodes(node: XmlNode): XmlNode {\r\n\r\n    if (!node.childNodes)\r\n        return node;\r\n\r\n    const oldChildren = node.childNodes;\r\n    node.childNodes = [];\r\n    for (const child of oldChildren) {\r\n        if (XmlNode.isTextNode(child)) {\r\n\r\n            // https://stackoverflow.com/questions/1921688/filtering-whitespace-only-strings-in-javascript#1921694\r\n            if (child.textContent && child.textContent.match(/\\S/)) {\r\n                node.childNodes.push(child);\r\n            }\r\n            \r\n            continue;\r\n        }\r\n        const strippedChild = recursiveRemoveEmptyTextNodes(child);\r\n        node.childNodes.push(strippedChild);\r\n    }\r\n\r\n    return node;\r\n}","import * as xmldom from 'xmldom';\r\nimport { MissingArgumentError } from '../errors';\r\nimport { XmlNode } from './xmlNode';\r\n\r\nexport class XmlParser {\r\n\r\n    private static xmlHeader = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>';\r\n    /**\r\n     * We always use the DOMParser from 'xmldom', even in the browser since it\r\n     * handles xml namespaces more forgivingly (required mainly by the\r\n     * RawXmlPlugin).\r\n     */\r\n    private static readonly parser = new xmldom.DOMParser();\r\n\r\n    public parse(str: string): XmlNode {\r\n        const doc = this.domParse(str);\r\n        return XmlNode.fromDomNode(doc.documentElement);\r\n    }\r\n\r\n    public domParse(str: string): Document {\r\n        if (str === null || str === undefined)\r\n            throw new MissingArgumentError(nameof(str));\r\n\r\n        return XmlParser.parser.parseFromString(str, \"text/xml\");\r\n    }\r\n\r\n    public serialize(xmlNode: XmlNode): string {\r\n        return XmlParser.xmlHeader + XmlNode.serialize(xmlNode);\r\n    }    \r\n}\r\n","export * from './zip';\r\nexport * from './zipObject';\r\n","import * as JSZip from 'jszip';\r\nimport { MissingArgumentError } from '../errors';\r\nimport { Binary } from '../utils';\r\n\r\nexport class JsZipHelper {\r\n\r\n    public static toJsZipOutputType(binary: Binary): JSZip.OutputType;\r\n    public static toJsZipOutputType(binaryType: Constructor<Binary>): JSZip.OutputType;\r\n    public static toJsZipOutputType(binaryOrType: Binary | Constructor<Binary>): JSZip.OutputType {\r\n\r\n        if (!binaryOrType)\r\n            throw new MissingArgumentError(nameof(binaryOrType));\r\n\r\n        let binaryType: Constructor<Binary>;\r\n        if (typeof binaryOrType === 'function') {\r\n            binaryType = binaryOrType as Constructor<Binary>;\r\n        } else {\r\n            binaryType = binaryOrType.constructor as Constructor<Binary>;\r\n        }\r\n\r\n        if (Binary.isBlobConstructor(binaryType))\r\n            return 'blob';\r\n        if (Binary.isArrayBufferConstructor(binaryType))\r\n            return 'arraybuffer';\r\n        if (Binary.isBufferConstructor(binaryType))\r\n            return 'nodebuffer';\r\n\r\n        throw new Error(`Binary type '${binaryType.name}' is not supported.`);\r\n    };\r\n}","import * as JSZip from 'jszip';\r\nimport { Binary } from '../utils';\r\nimport { JsZipHelper } from './jsZipHelper';\r\nimport { ZipObject } from './zipObject';\r\n\r\nexport class Zip {\r\n\r\n    public static async load(file: Binary): Promise<Zip> {\r\n        const zip = await JSZip.loadAsync(file);\r\n        return new Zip(zip);\r\n    }\r\n\r\n    private constructor(private readonly zip: JSZip) {\r\n    }\r\n\r\n    public getFile(path: string): ZipObject {\r\n        return new ZipObject(this.zip.files[path]);\r\n    }\r\n\r\n    public setFile(path: string, content: string | Binary): void {\r\n        this.zip.file(path, content);\r\n    }\r\n\r\n    public isFileExist(path: string): boolean {\r\n        return !!this.zip.files[path];\r\n    }\r\n\r\n    public listFiles(): string[] {\r\n        return Object.keys(this.zip.files);\r\n    }\r\n\r\n    public async export<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        const zipOutputType: JSZip.OutputType = JsZipHelper.toJsZipOutputType(outputType);\r\n        const output = await this.zip.generateAsync({\r\n            type: zipOutputType,\r\n            compression: \"DEFLATE\",\r\n            compressionOptions: {\r\n                level: 6 // between 1 (best speed) and 9 (best compression)\r\n            }\r\n        });\r\n        return output as T;\r\n    }\r\n}","import * as JSZip from 'jszip';\r\nimport { Binary } from '../utils';\r\nimport { JsZipHelper } from './jsZipHelper';\r\n\r\nexport class ZipObject {\r\n\r\n    public get name(): string {\r\n        return this.zipObject.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this.zipObject.name = value;\r\n    }\r\n\r\n    public get isDirectory(): boolean {\r\n        return this.zipObject.dir;\r\n    }\r\n\r\n    constructor(private readonly zipObject: JSZip.JSZipObject) { }\r\n\r\n    public getContentText(): Promise<string> {\r\n        return this.zipObject.async('text');\r\n    }\r\n    \r\n    public getContentBase64(): Promise<string> {\r\n        return this.zipObject.async('binarystring');\r\n    }\r\n\r\n    public getContentBinary<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        const zipOutputType: JSZip.OutputType = JsZipHelper.toJsZipOutputType(outputType);\r\n        return this.zipObject.async(zipOutputType) as any;\r\n    }\r\n}","module.exports = require(\"base64-js\");","module.exports = require(\"ieee754\");","module.exports = require(\"isarray\");","module.exports = require(\"jszip\");","module.exports = require(\"lodash.get\");","module.exports = require(\"xmldom\");"],"sourceRoot":""}