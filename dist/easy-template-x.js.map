{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\templatePlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\mimeType.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\tag.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\base64.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\types.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlNode.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\imagePlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\linkPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\docx.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loopPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\rawXmlPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\textPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\jsZipHelper.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\zipObject.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\delimiters.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\templateHandlerOptions.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\delimiterSearcher.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\malformedFileError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\maxXmlDepthError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingArgumentError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingCloseDelimiterError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingStartDelimiterError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unclosedTagError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unidentifiedFileTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unknownContentTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unopenedTagError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unsupportedFileTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\array.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\binary.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\path.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\sha1.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlDepthTracker.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlParser.ts","external \"xmldom\"","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\scopeData.ts","external \"lodash.get\"","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\tagParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\templateCompiler.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\defaultPlugins.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\contentTypesFile.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\mediaFiles.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\rels.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\docxParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopListStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopParagraphStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopTableStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\pluginContent.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\zip.ts","external \"jszip\"","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\templateHandler.ts"],"names":["root","factory","exports","module","define","amd","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","_xmlDepthTracker","keys","forEach","_xmlNode","_xmlParser","_malformedFileError","_maxXmlDepthError","_missingArgumentError","_missingCloseDelimiterError","_missingStartDelimiterError","_unclosedTagError","_unidentifiedFileTypeError","_unknownContentTypeError","_unopenedTagError","_unsupportedFileTypeError","_array","_base","_binary","_path","_sha","_types","[object Object]","_defineProperty","setUtilities","utilities","simpleTagReplacements","tag","data","context","containerTagReplacements","tags","_errors","MimeType","mime","Png","Jpeg","Gif","Bmp","Svg","UnsupportedFileTypeError","_docx","_docxParser","TagDisposition","_defaultPlugins","_imageContent","_imagePlugin","_linkContent","_linkPlugin","_loopPlugin","_pluginContent","_rawXmlContent","_rawXmlPlugin","_templatePlugin","_textPlugin","_delimiterMark","_delimiterSearcher","_scopeData","_tag","_tagParser","_templateCompiler","_templateContext","str","btoa","Buffer","toString","derived","base","candidate","then","_utils","XmlNodeType","XmlNode","createTextNode","text","nodeType","Text","nodeName","textContent","createGeneralNode","General","encodeValue","MissingArgumentError","TypeError","constructor","replace","serialize","node","isTextNode","attributes","attributeNames","length","map","join","hasChildren","childNodes","suffix","openTag","xml","child","fromDomNode","domNode","xmlNode","TEXT_NODE","ELEMENT_NODE","curAttribute","item","prevChild","domChild","curChild","push","parentNode","nextSibling","Error","cloneNode","deep","clone","cloneNodeDeep","original","assign","prevChildClone","childClone","insertBefore","newNode","referenceNode","beforeNodeIndex","indexOf","insertChild","insertAfter","referenceNodeIndex","parent","childIndex","appendChild","RangeError","childAfter","splice","remove","removeChild","lastTextChild","allTextNodes","filter","lastTextNode","last","newTextNode","removeSiblings","from","to","removed","lastRemoved","removeMe","splitByChild","markerNode","removeMarkerNode","path","descendant","curChildIndex","reverse","getDescendantPath","split","findParent","predicate","findParentByName","findChildByName","childName","find","siblingsInRange","firstNode","lastNode","range","curNode","removeEmptyTextNodes","recursiveRemoveEmptyTextNodes","oldChildren","match","strippedChild","childOrIndex","_mimeType","_xml","nextImageId","TemplatePlugin","args","super","wordTextNode","docxParser","containingTextNode","xmlTextNode","content","getScopeData","source","mediaFilePath","docx","mediaFiles","add","format","relType","MimeTypeHelper","getOfficeRelType","relId","rels","contentTypes","ensureContentType","imageId","imageXml","createMarkup","width","height","markupText","pixelsToEmu","pictureMarkup","markupXml","xmlParser","parse","pixels","Math","round","_office","LinkPlugin","target","linkRelType","TargetMode","wordRunNode","containingRunNode","linkMarkup","generateMarkup","insertHyperlinkNode","runProps","DocxParser","RUN_PROPERTIES_NODE","linkRunProps","unshift","tagRunNode","tagTextNode","textNodesInRun","runBeforeTag","_contentTypesFile","_mediaFiles","_rels","documentPath","_documentPath","zip","isFileExist","MalformedFileError","Rels","MediaFiles","ContentTypesFile","_document","getFile","getContentText","xmlDocument","getDocument","domParse","documentElement","outputType","saveChanges","export","document","xmlContent","setFile","save","_loop","LOOP_CONTENT_TYPE","LoopTableStrategy","LoopListStrategy","LoopParagraphStrategy","loopStrategies","strategy","Array","isArray","closeTag","loopStrategy","isApplicable","rawText","nodesToRepeat","splitBefore","repeatedNodes","repeat","compiledNodes","compile","mergeBack","nodes","times","allResults","curResult","nodeGroups","compiledNodeGroups","curNodes","dummyRootNode","compiler","pop","TEXT_CONTENT_TYPE","lines","replaceSingleLine","replaceMultiLine","textNode","setSpacePreserveAttribute","runNode","lineBreak","getLineBreak","lineNode","createWordTextNode","_zip","_zipObject","binaryOrType","binaryType","Binary","isBlobConstructor","isArrayBufferConstructor","isBufferConstructor","_jsZipHelper","zipObject","isDirectory","dir","async","getContentBase64","getContentBinary","zipOutputType","JsZipHelper","toJsZipOutputType","initial","encodeAndValidate","containerTagOpen","containerTagClose","trim","_delimiters","_plugins","createDefaultPlugins","Delimiters","delimiters","plugins","_compilation","_templateData","_templateHandler","_templateHandlerOptions","MatchState","reset","delimiterIndex","openNodes","firstMatchIndex","findDelimiters","depth","XmlDepthTracker","maxXmlDepth","lookForOpenDelimiter","isParagraphNode","shouldSearchNode","findNextNode","textIndex","delimiterPattern","startDelimiter","endDelimiter","first","joinTextNodesRange","delimiterMark","createDelimiterMark","increment","decrement","isOpenDelimiter","index","isOpen","expectedFileType","setPrototypeOf","MaxXmlDepthError","maxDepth","argName","MissingCloseDelimiterError","openDelimiterText","MissingStartDelimiterError","closeDelimiterText","UnclosedTagError","tagName","UnidentifiedFileTypeError","UnknownContentTypeError","contentType","tagRawText","UnopenedTagError","fileType","destArray","items","apply","array","keySelector","valueSelector","res","isBlob","binary","isArrayBuffer","isBuffer","Blob","inheritsFrom","ArrayBuffer","toBase64","Promise","resolve","fileReader","FileReader","onload","base64","Base64","encode","result","readAsBinaryString","binaryStr","Uint8Array","reduce","byte","String","fromCharCode","lastSlashIndex","lastIndexOf","substr","substring","rotateLeft","cvtHex","val","msg","msgLength","utfStr","charCodeAt","utf8Encode","j","wordArray","w","A","B","C","D","E","temp","H0","H1","H2","H3","H4","blockStart","toLowerCase","xmldom","XmlParser","doc","parser","parseFromString","xmlHeader","DOMParser","require","getProp","allData","lastKey","curPath","slice","undefined","curScopePath","concat","docParser","tagRegex","RegExp","tagStart","tagEnd","openedTag","openedDelimiter","delimiter","closeTagText","openTagText","normalizeTagNodes","processTag","openDelimiter","closeDelimiter","closeDelimiterIndex","allDelimiters","startTextNode","endTextNode","sameNode","splitTextNode","updated","curDelimiter","tagContent","exec","startsWith","disposition","Open","Close","SelfClosed","delimiterSearcher","tagParser","defaultContentType","containerContentType","pluginsLookup","toDictionary","parseTags","doTagReplacements","tagIndex","detectContentType","plugin","job","isPromiseLike","closingTagIndex","findCloseTagIndex","scopeTags","scopeData","PluginContent","isPluginContent","_type","fromIndex","LoopPlugin","RawXmlPlugin","ImagePlugin","TextPlugin","parseContentTypesFile","extension","getDefaultExtension","typeNode","Extension","ContentType","addedNew","contentTypesFilePath","contentTypesXml","contentTypeAttribute","Map","mediaFile","files","has","hashMediaFiles","hash","sha1","hashes","nextFileId","mediaDir","set","listFiles","filename","Path","getFilename","fileData","fileHash","partPath","partDir","getDirectory","partFilename","relsFilePath","relTarget","additionalAttributes","parseRelsFile","relTargetKey","getRelTargetKey","relTargets","getNextRelId","relNode","Id","Type","Target","relIds","nextRelId","relsXml","relsFile","rel","idAttr","typeAttr","targetAttr","type","load","Docx","splitIndex","addBefore","firstXmlTextNode","secondXmlTextNode","newWordTextNode","curIndex","firstText","secondText","firstRunNode","secondRunNode","paragraphNode","firstWordTextNode","secondWordTextNode","totalText","curRunNode","curWordTextNode","firstTextNodeChild","curXmlTextNode","textToRemove","runToRemove","joinParagraphs","second","RUN_NODE","isTableCellNode","TABLE_CELL_NODE","PARAGRAPH_NODE","isListParagraph","paragraphProperties","paragraphPropertiesNode","NUMBER_PROPERTIES_NODE","PARAGRAPH_PROPERTIES_NODE","containingParagraphNode","containingTableRowNode","TABLE_ROW_NODE","_iLoopStrategy","_loopListStrategy","_loopParagraphStrategy","_loopTableStrategy","containingParagraph","firstParagraph","lastParagraph","paragraphsToRepeat","paragraphGroups","lastParagraphs","curParagraphsGroup","paragraph","areSame","firstParagraphIndex","lastParagraphIndex","splitResult","firstParagraphSplit","lastParagraphSplit","middleParagraphs","inBetween","mergeTo","firstRow","lastRow","rowsToRepeat","rowGroups","curRowsGroup","row","JSZip","Zip","file","loadAsync","ZipObject","generateAsync","compression","compressionOptions","level","options","EASY_VERSION","TemplateHandlerOptions","DelimiterSearcher","TagParser","TemplateCompiler","templateFile","loadDocx","ScopeData","docxFile","getDocumentText","_unused"],"mappings":"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","file":"easy-template-x.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"easy-template-x\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"easy-template-x\"] = factory();\n\telse\n\t\troot[\"easy-template-x\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 23);\n","export * from './xmlDepthTracker';\r\nexport * from './xmlNode';\r\nexport * from './xmlParser';\r\n","export * from './malformedFileError';\r\nexport * from './maxXmlDepthError';\r\nexport * from './missingArgumentError';\r\nexport * from './missingCloseDelimiterError';\r\nexport * from './missingStartDelimiterError';\r\nexport * from './unclosedTagError';\r\nexport * from './unidentifiedFileTypeError';\r\nexport * from './unknownContentTypeError';\r\nexport * from './unopenedTagError';\r\nexport * from './unsupportedFileTypeError';\r\n","export * from './array';\r\nexport * from './base64';\r\nexport * from './binary';\r\nexport * from './path';\r\nexport * from './sha1';\r\nexport * from './types';\r\n","import { ScopeData, Tag, TemplateCompiler, TemplateContext } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlParser } from '../xml';\r\n\r\nexport interface PluginUtilities {\r\n    compiler: TemplateCompiler;\r\n    docxParser: DocxParser;\r\n    xmlParser: XmlParser;\r\n}\r\n\r\n/* eslint-disable @typescript-eslint/member-ordering */\r\n\r\nexport abstract class TemplatePlugin {\r\n\r\n    /**\r\n     * The content type this plugin handles.\r\n     */\r\n    public abstract readonly contentType: string;\r\n\r\n    protected utilities: PluginUtilities;\r\n\r\n    /**\r\n     * Called by the TemplateHandler at runtime.\r\n     */\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    /**\r\n     * This method is called for each self-closing tag.\r\n     * It should implement the specific document manipulation required by the tag.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): void | Promise<void> {\r\n        // noop\r\n    }\r\n\r\n    /**\r\n     * This method is called for each container tag. It should implement the\r\n     * specific document manipulation required by the tag.\r\n     *\r\n     * @param tags All tags between the opening tag and closing tag (inclusive,\r\n     * i.e. tags[0] is the opening tag and the last item in the tags array is\r\n     * the closing tag).\r\n     */\r\n    public containerTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): void | Promise<void> {\r\n        // noop\r\n    }\r\n}","import { UnsupportedFileTypeError } from './errors';\r\n\r\nexport enum MimeType {\r\n    Png = 'image/png',\r\n    Jpeg = 'image/jpeg',\r\n    Gif = 'image/gif',\r\n    Bmp = 'image/bmp',\r\n    Svg = 'image/svg+xml'\r\n}\r\n\r\nexport class MimeTypeHelper {\r\n\r\n    public static getDefaultExtension(mime: MimeType): string {\r\n        switch (mime) {\r\n            case MimeType.Png:\r\n                return 'png';\r\n            case MimeType.Jpeg:\r\n                return 'jpg';\r\n            case MimeType.Gif:\r\n                return 'gif';\r\n            case MimeType.Bmp:\r\n                return 'bmp';\r\n            case MimeType.Svg:\r\n                return 'svg';\r\n            default:\r\n                throw new UnsupportedFileTypeError(mime);\r\n        }\r\n    }\r\n\r\n    public static getOfficeRelType(mime: MimeType): string {\r\n        switch (mime) {\r\n            case MimeType.Png:\r\n            case MimeType.Jpeg:\r\n            case MimeType.Gif:\r\n            case MimeType.Bmp:\r\n            case MimeType.Svg:\r\n                return \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\";\r\n            default:\r\n                throw new UnsupportedFileTypeError(mime);\r\n        }\r\n    }\r\n}","export * from './docx';\r\nexport * from './docxParser';\r\n","import { XmlTextNode } from '../xml';\r\n\r\nexport enum TagDisposition {\r\n    Open = \"Open\",\r\n    Close = \"Close\",\r\n    SelfClosed = \"SelfClosed\"\r\n}\r\n\r\nexport interface Tag {    \r\n    name: string;\r\n    /**\r\n     * The full tag text, for instance: \"{#my-tag}\".\r\n     */\r\n    rawText: string;\r\n    disposition: TagDisposition;\r\n    xmlTextNode: XmlTextNode;\r\n}","export * from './defaultPlugins';\r\nexport * from './imageContent';\r\nexport * from './imagePlugin';\r\nexport * from './linkContent';\r\nexport * from './linkPlugin';\r\nexport * from './loopPlugin';\r\nexport * from './pluginContent';\r\nexport * from './rawXmlContent';\r\nexport * from './rawXmlPlugin';\r\nexport * from './templatePlugin';\r\nexport * from './textPlugin';\r\n","export * from './delimiterMark';\r\nexport * from './delimiterSearcher';\r\nexport * from './scopeData';\r\nexport * from './tag';\r\nexport * from './tagParser';\r\nexport * from './templateCompiler';\r\nexport * from './templateContext';\r\n","export class Base64 {\r\n\r\n    public static encode(str: string): string {\r\n        \r\n        // browser\r\n        if (typeof btoa !== 'undefined') \r\n            return btoa(str);\r\n\r\n        // node\r\n        // https://stackoverflow.com/questions/23097928/node-js-btoa-is-not-defined-error#38446960\r\n        return new Buffer(str, 'binary').toString('base64');\r\n    }\r\n}","\r\nexport function inheritsFrom(derived: Constructor<any>, base: Constructor<any>): boolean {\r\n    // https://stackoverflow.com/questions/14486110/how-to-check-if-a-javascript-class-inherits-another-without-creating-an-obj\r\n    return derived === base || derived.prototype instanceof base;\r\n}\r\n\r\nexport function isPromiseLike<T>(candidate: any): candidate is PromiseLike<T> {\r\n    return !!candidate && typeof candidate === 'object' && typeof candidate.then === 'function';\r\n}","import { MissingArgumentError } from '../errors';\r\nimport { last } from '../utils';\r\n\r\nexport enum XmlNodeType {\r\n    Text = \"Text\",\r\n    General = \"General\"\r\n}\r\n\r\nexport type XmlNode = XmlTextNode | XmlGeneralNode;\r\n\r\nexport interface XmlNodeBase {\r\n    nodeType: XmlNodeType;\r\n    nodeName: string;\r\n    parentNode?: XmlNode;\r\n    childNodes?: XmlNode[];\r\n    nextSibling?: XmlNode;\r\n}\r\n\r\nexport const TEXT_NODE_NAME = '#text'; // see: https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName\r\n\r\nexport interface XmlTextNode extends XmlNodeBase {\r\n    nodeType: XmlNodeType.Text;\r\n    nodeName: typeof TEXT_NODE_NAME;\r\n    textContent: string;\r\n}\r\n\r\nexport interface XmlGeneralNode extends XmlNodeBase {\r\n    nodeType: XmlNodeType.General;\r\n    attributes?: IMap<string>;\r\n}\r\n\r\nexport const XmlNode = {\r\n\r\n    //\r\n    // factories\r\n    //\r\n\r\n    createTextNode(text?: string): XmlTextNode {\r\n        return {\r\n            nodeType: XmlNodeType.Text,\r\n            nodeName: TEXT_NODE_NAME,\r\n            textContent: text\r\n        };\r\n    },\r\n\r\n    createGeneralNode(name: string): XmlGeneralNode {\r\n        return {\r\n            nodeType: XmlNodeType.General,\r\n            nodeName: name\r\n        };\r\n    },\r\n\r\n    //\r\n    // serialization\r\n    //\r\n\r\n    /**\r\n     * Encode string to make it safe to use inside xml tags.\r\n     * \r\n     * https://stackoverflow.com/questions/7918868/how-to-escape-xml-entities-in-javascript\r\n     */\r\n    encodeValue(str: string): string {\r\n        if (str === null || str === undefined)\r\n            throw new MissingArgumentError(nameof(str));\r\n        if (typeof str !== 'string')\r\n            throw new TypeError(`Expected a string, got '${(str as any).constructor.name}'.`);\r\n\r\n        return str.replace(/[<>&'\"]/g, c => {\r\n            switch (c) {\r\n                case '<': return '&lt;';\r\n                case '>': return '&gt;';\r\n                case '&': return '&amp;';\r\n                case '\\'': return '&apos;';\r\n                case '\"': return '&quot;';\r\n            }\r\n            return '';\r\n        });\r\n    },\r\n\r\n    serialize(node: XmlNode): string {\r\n        if (this.isTextNode(node))\r\n            return this.encodeValue(node.textContent || '');\r\n\r\n        // attributes\r\n        let attributes = '';\r\n        if (node.attributes) {\r\n            const attributeNames = Object.keys(node.attributes);\r\n            if (attributeNames.length) {\r\n                attributes = ' ' + attributeNames\r\n                    .map(name => `${name}=\"${node.attributes[name]}\"`)\r\n                    .join(' ');\r\n            }\r\n        }\r\n\r\n        // open tag\r\n        const hasChildren = (node.childNodes || []).length > 0;\r\n        const suffix = hasChildren ? '' : '/';\r\n        const openTag = `<${node.nodeName}${attributes}${suffix}>`;\r\n\r\n        let xml: string;\r\n\r\n        if (hasChildren) {\r\n\r\n            // child nodes\r\n            const childrenXml = node.childNodes\r\n                .map(child => this.serialize(child))\r\n                .join('');\r\n\r\n            // close tag\r\n            const closeTag = `</${node.nodeName}>`;\r\n\r\n            xml = openTag + childrenXml + closeTag;\r\n        } else {\r\n            xml = openTag;\r\n        }\r\n\r\n        return xml;\r\n    },\r\n\r\n    /**\r\n     * The conversion is always deep.\r\n     */\r\n    fromDomNode(domNode: Node): XmlNode {\r\n        let xmlNode: XmlNode;\r\n\r\n        // basic properties\r\n        if (domNode.nodeType === domNode.TEXT_NODE) {\r\n\r\n            xmlNode = this.createTextNode(domNode.textContent);\r\n\r\n        } else {\r\n\r\n            xmlNode = this.createGeneralNode(domNode.nodeName);\r\n\r\n            // attributes\r\n            if (domNode.nodeType === domNode.ELEMENT_NODE) {\r\n                const attributes = (domNode as Element).attributes;\r\n                if (attributes) {\r\n                    (xmlNode as XmlGeneralNode).attributes = {};\r\n                    for (let i = 0; i < attributes.length; i++) {\r\n                        const curAttribute = attributes.item(i);\r\n                        (xmlNode as XmlGeneralNode).attributes[curAttribute.name] = curAttribute.value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // children\r\n        if (domNode.childNodes) {\r\n            xmlNode.childNodes = [];\r\n            let prevChild: XmlNode;\r\n            for (let i = 0; i < domNode.childNodes.length; i++) {\r\n\r\n                // clone child\r\n                const domChild = domNode.childNodes.item(i);\r\n                const curChild = this.fromDomNode(domChild);\r\n\r\n                // set references                \r\n                xmlNode.childNodes.push(curChild);\r\n                curChild.parentNode = xmlNode;\r\n                if (prevChild) {\r\n                    prevChild.nextSibling = curChild;\r\n                }\r\n                prevChild = curChild;\r\n            }\r\n        }\r\n\r\n        return xmlNode as XmlNode;\r\n    },\r\n\r\n    //\r\n    // core functions\r\n    //\r\n\r\n    isTextNode(node: XmlNode): node is XmlTextNode {\r\n        if (node.nodeType === XmlNodeType.Text || node.nodeName === TEXT_NODE_NAME) {\r\n            if (!(node.nodeType === XmlNodeType.Text && node.nodeName === TEXT_NODE_NAME)) {\r\n                throw new Error(`Invalid text node. Type: '${node.nodeType}', Name: '${node.nodeName}'.`);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    cloneNode<T extends XmlNode>(node: T, deep: boolean): T {\r\n        if (!node)\r\n            throw new MissingArgumentError(nameof(node));\r\n\r\n        if (!deep) {\r\n            const clone = Object.assign({}, node);\r\n            clone.parentNode = null;\r\n            clone.childNodes = (node.childNodes ? [] : null);\r\n            clone.nextSibling = null;\r\n            return clone;\r\n        } else {\r\n            const clone = cloneNodeDeep(node);\r\n            clone.parentNode = null;\r\n            return clone;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Insert the node as a new sibling, before the original node.\r\n     *\r\n     * * **Note**: It is more efficient to use the insertChild function if you\r\n     *   already know the relevant index.\r\n     */\r\n    insertBefore(newNode: XmlNode, referenceNode: XmlNode): void {\r\n        if (!newNode)\r\n            throw new MissingArgumentError(nameof(newNode));\r\n        if (!referenceNode)\r\n            throw new MissingArgumentError(nameof(referenceNode));\r\n\r\n        if (!referenceNode.parentNode)\r\n            throw new Error(`'${nameof(referenceNode)}' has no parent`);\r\n\r\n        const childNodes = referenceNode.parentNode.childNodes;\r\n        const beforeNodeIndex = childNodes.indexOf(referenceNode);\r\n        XmlNode.insertChild(referenceNode.parentNode, newNode, beforeNodeIndex);\r\n    },\r\n\r\n    /**\r\n     * Insert the node as a new sibling, after the original node.\r\n     *\r\n     * * **Note**: It is more efficient to use the insertChild function if you\r\n     *   already know the relevant index.\r\n     */\r\n    insertAfter(newNode: XmlNode, referenceNode: XmlNode): void {\r\n        if (!newNode)\r\n            throw new MissingArgumentError(nameof(newNode));\r\n        if (!referenceNode)\r\n            throw new MissingArgumentError(nameof(referenceNode));\r\n\r\n        if (!referenceNode.parentNode)\r\n            throw new Error(`'${nameof(referenceNode)}' has no parent`);\r\n\r\n        const childNodes = referenceNode.parentNode.childNodes;\r\n        const referenceNodeIndex = childNodes.indexOf(referenceNode);\r\n        XmlNode.insertChild(referenceNode.parentNode, newNode, referenceNodeIndex + 1);\r\n    },\r\n\r\n    insertChild(parent: XmlNode, child: XmlNode, childIndex: number): void {\r\n        if (!parent)\r\n            throw new MissingArgumentError(nameof(parent));\r\n        if (XmlNode.isTextNode(parent))\r\n            throw new Error('Appending children to text nodes is forbidden');\r\n        if (!child)\r\n            throw new MissingArgumentError(nameof(child));\r\n\r\n        if (!parent.childNodes)\r\n            parent.childNodes = [];\r\n\r\n        // revert to append\r\n        if (childIndex === parent.childNodes.length) {\r\n            XmlNode.appendChild(parent, child);\r\n            return;\r\n        }\r\n\r\n        if (childIndex > parent.childNodes.length)\r\n            throw new RangeError(`Child index ${childIndex} is out of range. Parent has only ${parent.childNodes.length} child nodes.`);\r\n\r\n        // update references\r\n        child.parentNode = parent;\r\n\r\n        const childAfter = parent.childNodes[childIndex];\r\n        child.nextSibling = childAfter;\r\n\r\n        if (childIndex > 0) {\r\n            const childBefore = parent.childNodes[childIndex - 1];\r\n            childBefore.nextSibling = child;\r\n        }\r\n\r\n        // append\r\n        parent.childNodes.splice(childIndex, 0, child);\r\n    },\r\n\r\n    appendChild(parent: XmlNode, child: XmlNode): void {\r\n        if (!parent)\r\n            throw new MissingArgumentError(nameof(parent));\r\n        if (XmlNode.isTextNode(parent))\r\n            throw new Error('Appending children to text nodes is forbidden');\r\n        if (!child)\r\n            throw new MissingArgumentError(nameof(child));\r\n\r\n        if (!parent.childNodes)\r\n            parent.childNodes = [];\r\n\r\n        // update references\r\n        if (parent.childNodes.length) {\r\n            const currentLastChild = parent.childNodes[parent.childNodes.length - 1];\r\n            currentLastChild.nextSibling = child;\r\n        }\r\n        child.nextSibling = null;\r\n        child.parentNode = parent;\r\n\r\n        // append\r\n        parent.childNodes.push(child);\r\n    },\r\n\r\n    /**\r\n     * Removes the node from it's parent.\r\n     * \r\n     * * **Note**: It is more efficient to call removeChild(parent, childIndex).\r\n     */\r\n    remove(node: XmlNode): void {\r\n        if (!node)\r\n            throw new MissingArgumentError(nameof(node));\r\n\r\n        if (!node.parentNode)\r\n            throw new Error('Node has no parent');\r\n\r\n        removeChild(node.parentNode, node);\r\n    },\r\n\r\n    removeChild,\r\n\r\n    //\r\n    // utility functions\r\n    //    \r\n\r\n    /**\r\n     * Gets the last direct child text node if it exists. Otherwise creates a\r\n     * new text node, appends it to 'node' and return the newly created text\r\n     * node.\r\n     *\r\n     * The function also makes sure the returned text node has a valid string\r\n     * value.\r\n     */\r\n    lastTextChild(node: XmlNode): XmlTextNode {\r\n        if (XmlNode.isTextNode(node)) {\r\n            return node;\r\n        }\r\n\r\n        // existing text nodes\r\n        if (node.childNodes) {\r\n            const allTextNodes = node.childNodes.filter(child => XmlNode.isTextNode(child)) as XmlTextNode[];\r\n            if (allTextNodes.length) {\r\n                const lastTextNode = last(allTextNodes);\r\n                if (!lastTextNode.textContent)\r\n                    lastTextNode.textContent = '';\r\n                return lastTextNode;\r\n            }\r\n        }\r\n\r\n        // create new text node\r\n        const newTextNode: XmlTextNode = {\r\n            nodeType: XmlNodeType.Text,\r\n            nodeName: TEXT_NODE_NAME,\r\n            textContent: ''\r\n        };\r\n\r\n        XmlNode.appendChild(node, newTextNode);\r\n        return newTextNode;\r\n    },\r\n\r\n    /**\r\n     * Remove sibling nodes between 'from' and 'to' excluding both.\r\n     * Return the removed nodes.\r\n     */\r\n    removeSiblings(from: XmlNode, to: XmlNode): XmlNode[] {\r\n        if (from === to)\r\n            return [];\r\n\r\n        const removed: XmlNode[] = [];\r\n        let lastRemoved: XmlNode;\r\n        from = from.nextSibling;\r\n        while (from !== to) {\r\n            const removeMe = from;\r\n            from = from.nextSibling;\r\n\r\n            XmlNode.remove(removeMe);\r\n            removed.push(removeMe);\r\n\r\n            if (lastRemoved)\r\n                lastRemoved.nextSibling = removeMe;\r\n            lastRemoved = removeMe;\r\n        }\r\n\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Split the original node into two sibling nodes.\r\n     * Returns both nodes.\r\n     *\r\n     * @param root The node to split\r\n     * @param markerNode The node that marks the split position.      \r\n     */\r\n    splitByChild(root: XmlNode, markerNode: XmlNode, removeMarkerNode: boolean): [XmlNode, XmlNode] {\r\n\r\n        // find the split path\r\n        const path = getDescendantPath(root, markerNode);\r\n\r\n        // split\r\n        const split = XmlNode.cloneNode(root, false);\r\n        const childIndex = path[0] + 1;\r\n        while (childIndex < root.childNodes.length) {\r\n            const curChild = root.childNodes[childIndex];\r\n            XmlNode.remove(curChild);\r\n            XmlNode.appendChild(split, curChild);\r\n        }\r\n\r\n        if (root.parentNode) {\r\n            XmlNode.insertAfter(split, root);\r\n        }\r\n\r\n        // remove marker node\r\n        if (removeMarkerNode && root.childNodes.length) {\r\n            XmlNode.removeChild(root, root.childNodes.length - 1);\r\n        }\r\n\r\n        return [root, split];\r\n    },\r\n\r\n    findParent(node: XmlNode, predicate: (node: XmlNode) => boolean): XmlNode {\r\n        if (!node)\r\n            return null;\r\n\r\n        while (node.parentNode) {\r\n\r\n            if (predicate(node))\r\n                return node;\r\n\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    findParentByName(node: XmlNode, nodeName: string): XmlNode {\r\n        return XmlNode.findParent(node, n => n.nodeName === nodeName);\r\n    },\r\n\r\n    findChildByName(node: XmlNode, childName: string): XmlNode {\r\n        if (!node)\r\n            return null;\r\n        return (node.childNodes || []).find(child => child.nodeName === childName);\r\n    },\r\n\r\n    /**\r\n     * Returns all siblings between 'firstNode' and 'lastNode' inclusive.\r\n     */\r\n    siblingsInRange(firstNode: XmlNode, lastNode: XmlNode): XmlNode[] {\r\n        if (!firstNode)\r\n            throw new MissingArgumentError(nameof(firstNode));\r\n        if (!lastNode)\r\n            throw new MissingArgumentError(nameof(lastNode));\r\n\r\n        const range: XmlNode[] = [];\r\n        let curNode = firstNode;\r\n        while (curNode && curNode !== lastNode) {\r\n            range.push(curNode);\r\n            curNode = curNode.nextSibling;\r\n        }\r\n\r\n        if (!curNode)\r\n            throw new Error('Nodes are not siblings.');\r\n\r\n        range.push(lastNode);\r\n        return range;\r\n    },\r\n\r\n    /**\r\n     * Recursively removes text nodes leaving only \"general nodes\".\r\n     */\r\n    removeEmptyTextNodes(node: XmlNode): void {\r\n        recursiveRemoveEmptyTextNodes(node);\r\n    },\r\n};\r\n\r\n//\r\n// overloaded functions\r\n//\r\n\r\n/**\r\n * Remove a child node from it's parent. Returns the removed child.\r\n * \r\n * * **Note:** Prefer calling with explicit index.\r\n */\r\nfunction removeChild(parent: XmlNode, child: XmlNode): XmlNode;\r\n/**\r\n * Remove a child node from it's parent. Returns the removed child.\r\n */\r\nfunction removeChild(parent: XmlNode, childIndex: number): XmlNode;\r\nfunction removeChild(parent: XmlNode, childOrIndex: XmlNode | number): XmlNode {\r\n    if (!parent)\r\n        throw new MissingArgumentError(nameof(parent));\r\n    if (childOrIndex === null || childOrIndex === undefined)\r\n        throw new MissingArgumentError(nameof(childOrIndex));\r\n\r\n    if (!parent.childNodes || !parent.childNodes.length)\r\n        throw new Error('Parent node has node children');\r\n\r\n    // get child index\r\n    let childIndex: number;\r\n    if (typeof childOrIndex === 'number') {\r\n        childIndex = childOrIndex;\r\n    } else {\r\n        childIndex = parent.childNodes.indexOf(childOrIndex);\r\n        if (childIndex === -1)\r\n            throw new Error('Specified child node is not a child of the specified parent');\r\n    }\r\n\r\n    if (childIndex >= parent.childNodes.length)\r\n        throw new RangeError(`Child index ${childIndex} is out of range. Parent has only ${parent.childNodes.length} child nodes.`);\r\n\r\n    // update references\r\n    const child = parent.childNodes[childIndex];\r\n    if (childIndex > 0) {\r\n        const beforeChild = parent.childNodes[childIndex - 1];\r\n        beforeChild.nextSibling = child.nextSibling;\r\n    }\r\n    child.parentNode = null;\r\n    child.nextSibling = null;\r\n\r\n    // remove and return\r\n    return parent.childNodes.splice(childIndex, 1)[0];\r\n}\r\n\r\n//\r\n// private functions\r\n//\r\n\r\nfunction cloneNodeDeep<T extends XmlNode>(original: T): T {\r\n\r\n    const clone: XmlNode = ({} as any);\r\n\r\n    // basic properties\r\n    clone.nodeType = original.nodeType;\r\n    clone.nodeName = original.nodeName;\r\n    if (XmlNode.isTextNode(original)) {\r\n        (clone as XmlTextNode).textContent = original.textContent;\r\n    } else {\r\n        const attributes = (original as XmlGeneralNode).attributes;\r\n        if (attributes) {\r\n            (clone as XmlGeneralNode).attributes = Object.assign({}, attributes);\r\n        }\r\n    }\r\n\r\n    // children\r\n    if (original.childNodes) {\r\n        clone.childNodes = [];\r\n        let prevChildClone: XmlNode;\r\n        for (const child of original.childNodes) {\r\n\r\n            // clone child\r\n            const childClone = cloneNodeDeep(child);\r\n\r\n            // set references                \r\n            clone.childNodes.push(childClone);\r\n            childClone.parentNode = clone;\r\n            if (prevChildClone) {\r\n                prevChildClone.nextSibling = childClone;\r\n            }\r\n            prevChildClone = childClone;\r\n        }\r\n    }\r\n\r\n    return clone as T;\r\n}\r\n\r\nfunction getDescendantPath(root: XmlNode, descendant: XmlNode): number[] {\r\n    const path: number[] = [];\r\n\r\n    let node = descendant;\r\n    while (node !== root) {\r\n        const parent = node.parentNode;\r\n        if (!parent)\r\n            throw new Error(`Argument ${nameof(descendant)} is not a descendant of ${nameof(root)}`);\r\n\r\n        const curChildIndex = parent.childNodes.indexOf(node);\r\n        path.push(curChildIndex);\r\n\r\n        node = parent;\r\n    }\r\n\r\n    return path.reverse();\r\n}\r\n\r\nfunction recursiveRemoveEmptyTextNodes(node: XmlNode): XmlNode {\r\n\r\n    if (!node.childNodes)\r\n        return node;\r\n\r\n    const oldChildren = node.childNodes;\r\n    node.childNodes = [];\r\n    for (const child of oldChildren) {\r\n        if (XmlNode.isTextNode(child)) {\r\n\r\n            // https://stackoverflow.com/questions/1921688/filtering-whitespace-only-strings-in-javascript#1921694\r\n            if (child.textContent && child.textContent.match(/\\S/)) {\r\n                node.childNodes.push(child);\r\n            }\r\n            \r\n            continue;\r\n        }\r\n        const strippedChild = recursiveRemoveEmptyTextNodes(child);\r\n        node.childNodes.push(strippedChild);\r\n    }\r\n\r\n    return node;\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { MimeTypeHelper } from '../mimeType';\r\nimport { XmlGeneralNode, XmlNode } from '../xml';\r\nimport { ImageContent } from './imageContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\n/**\r\n * Apparently it is not that important for the ID to be unique...  \r\n * Word displays two images correctly even if they both have the same ID.\r\n * Further more, Word will assign each a unique ID upon saving (it assigns\r\n * consecutive integers starting with 1).  \r\n * \r\n * Note: The same principal applies to image names.\r\n *\r\n * Tested in Word v1908\r\n */\r\nlet nextImageId = 1;\r\n\r\nexport class ImagePlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = 'image';\r\n\r\n    public async simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const content = data.getScopeData<ImageContent>();\r\n        if (!content || !content.source) {\r\n            XmlNode.remove(wordTextNode);\r\n            return;\r\n        }\r\n\r\n        // add the image file into the archive\r\n        const mediaFilePath = await context.docx.mediaFiles.add(content.source, content.format);\r\n        const relType = MimeTypeHelper.getOfficeRelType(content.format);\r\n        const relId = await context.docx.rels.add(mediaFilePath, relType);\r\n        await context.docx.contentTypes.ensureContentType(content.format);\r\n\r\n        // create the xml markup\r\n        const imageId = nextImageId++;\r\n        const imageXml = this.createMarkup(imageId, relId, content.width, content.height);\r\n\r\n        XmlNode.insertAfter(imageXml, wordTextNode);\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n\r\n    private createMarkup(imageId: number, relId: string, width: number, height: number): XmlNode {\r\n\r\n        // http://officeopenxml.com/drwPicInline.php\r\n\r\n        //\r\n        // Performance note:  \r\n        //\r\n        // I've tried to improve the markup generation performance by parsing\r\n        // the string once and caching the result (and of course customizing it\r\n        // per image) but it made no change whatsoever (in both cases 1000 items\r\n        // loop takes around 8 seconds on my machine) so I'm sticking with this\r\n        // approach which I find to be more readable.\r\n        //\r\n\r\n        const name = `Picture ${imageId}`;\r\n        const markupText = `\r\n            <w:drawing>\r\n                <wp:inline distT=\"0\" distB=\"0\" distL=\"0\" distR=\"0\">\r\n                    <wp:extent cx=\"${this.pixelsToEmu(width)}\" cy=\"${this.pixelsToEmu(height)}\"/>\r\n                    <wp:effectExtent l=\"0\" t=\"0\" r=\"0\" b=\"0\"/>\r\n                    <wp:docPr id=\"${imageId}\" name=\"${name}\"/>\r\n                    <wp:cNvGraphicFramePr>\r\n                        <a:graphicFrameLocks xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" noChangeAspect=\"1\"/>\r\n                    </wp:cNvGraphicFramePr>\r\n                    <a:graphic xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">\r\n                        <a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/picture\">\r\n                            ${this.pictureMarkup(name, relId, width, height)}\r\n                        </a:graphicData>\r\n                    </a:graphic>\r\n                </wp:inline>\r\n            </w:drawing>\r\n        `;\r\n\r\n        const markupXml = this.utilities.xmlParser.parse(markupText) as XmlGeneralNode;\r\n        XmlNode.removeEmptyTextNodes(markupXml); // remove whitespace\r\n\r\n        return markupXml;\r\n    }\r\n\r\n    private pictureMarkup(name: string, relId: string, width: number, height: number) {\r\n\r\n        // http://officeopenxml.com/drwPic.php\r\n\r\n        // legend:\r\n        // nvPicPr - non-visual picture properties - id, name, etc.\r\n        // blipFill - binary large image (or) picture fill - image size, image fill, etc.\r\n        // spPr - shape properties - frame size, frame fill, etc.\r\n\r\n        return `\r\n            <pic:pic xmlns:pic=\"http://schemas.openxmlformats.org/drawingml/2006/picture\">\r\n                <pic:nvPicPr>\r\n                    <pic:cNvPr id=\"0\" name=\"${name}\"/>\r\n                    <pic:cNvPicPr>\r\n                        <a:picLocks noChangeAspect=\"1\" noChangeArrowheads=\"1\"/>\r\n                    </pic:cNvPicPr>\r\n                </pic:nvPicPr>\r\n                <pic:blipFill>\r\n                    <a:blip r:embed=\"${relId}\">\r\n                        <a:extLst>\r\n                            <a:ext uri=\"{28A0092B-C50C-407E-A947-70E740481C1C}\">\r\n                                <a14:useLocalDpi xmlns:a14=\"http://schemas.microsoft.com/office/drawing/2010/main\" val=\"0\"/>\r\n                            </a:ext>\r\n                        </a:extLst>\r\n                    </a:blip>\r\n                    <a:srcRect/>\r\n                    <a:stretch>\r\n                        <a:fillRect/>\r\n                    </a:stretch>\r\n                </pic:blipFill>\r\n                <pic:spPr bwMode=\"auto\">\r\n                    <a:xfrm>\r\n                        <a:off x=\"0\" y=\"0\"/>\r\n                        <a:ext cx=\"${this.pixelsToEmu(width)}\" cy=\"${this.pixelsToEmu(height)}\"/>\r\n                    </a:xfrm>\r\n                    <a:prstGeom prst=\"rect\">\r\n                        <a:avLst/>\r\n                    </a:prstGeom>\r\n                    <a:noFill/>\r\n                    <a:ln>\r\n                        <a:noFill/>\r\n                    </a:ln>\r\n                </pic:spPr>\r\n            </pic:pic>\r\n        `;\r\n    }\r\n\r\n    private pixelsToEmu(pixels: number): number {\r\n\r\n        // https://stackoverflow.com/questions/20194403/openxml-distance-size-units\r\n        // https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-units#other-units-of-measurement\r\n        // https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML\r\n        // http://www.java2s.com/Code/CSharp/2D-Graphics/ConvertpixelstoEMUEMUtopixels.htm\r\n\r\n        return Math.round(pixels * 9525);\r\n    }\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlNode } from '../xml';\r\nimport { LinkContent } from './linkContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport class LinkPlugin extends TemplatePlugin {\r\n\r\n    private static readonly linkRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';\r\n\r\n    public readonly contentType = 'link';\r\n\r\n    public async simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const content = data.getScopeData<LinkContent>();\r\n        if (!content || !content.target) {\r\n            XmlNode.remove(wordTextNode);\r\n            return;\r\n        }\r\n\r\n        // add rel\r\n        const linkAttributes = { TargetMode: 'External' };\r\n        const relId = await context.docx.rels.add(content.target, LinkPlugin.linkRelType, linkAttributes);\r\n\r\n        // generate markup\r\n        const wordRunNode = this.utilities.docxParser.containingRunNode(wordTextNode);\r\n        const linkMarkup = this.generateMarkup(content, relId, wordRunNode);\r\n\r\n        // add to document\r\n        this.insertHyperlinkNode(linkMarkup, wordRunNode, wordTextNode);\r\n    }\r\n\r\n    private generateMarkup(content: LinkContent, relId: string, wordRunNode: XmlNode) {\r\n\r\n        // http://officeopenxml.com/WPhyperlink.php\r\n\r\n        const markupText = `\r\n            <w:hyperlink r:id=\"${relId}\" w:history=\"1\">\r\n                <w:r>\r\n                    <w:t>${content.text || content.target}</w:t>\r\n                </w:r>\r\n            </w:hyperlink>\r\n        `;\r\n        const markupXml = this.utilities.xmlParser.parse(markupText);\r\n        XmlNode.removeEmptyTextNodes(markupXml); // remove whitespace\r\n\r\n        // copy props from original run node (preserve style)        \r\n        const runProps = wordRunNode.childNodes.find(node => node.nodeName === DocxParser.RUN_PROPERTIES_NODE);\r\n        if (runProps) {\r\n            const linkRunProps = XmlNode.cloneNode(runProps, true);\r\n            markupXml.childNodes[0].childNodes.unshift(linkRunProps);\r\n        }\r\n\r\n        return markupXml;\r\n    }\r\n\r\n    private insertHyperlinkNode(linkMarkup: XmlNode, tagRunNode: XmlNode, tagTextNode: XmlNode) {\r\n\r\n        // Links are inserted at the 'run' level.  \r\n        // Therefor we isolate the link tag to it's own run (it is already\r\n        // isolated to it's own text node), insert the link markup and remove\r\n        // the run.\r\n        let textNodesInRun = tagRunNode.childNodes.filter(node => node.nodeName === DocxParser.TEXT_NODE);\r\n        if (textNodesInRun.length > 1) {\r\n            \r\n            const [runBeforeTag] = XmlNode.splitByChild(tagRunNode, tagTextNode, true);\r\n            textNodesInRun = runBeforeTag.childNodes.filter(node => node.nodeName === DocxParser.TEXT_NODE);\r\n\r\n            XmlNode.insertAfter(linkMarkup, runBeforeTag);\r\n            if (textNodesInRun.length === 0) {\r\n                XmlNode.remove(runBeforeTag);\r\n            }\r\n        }\r\n\r\n        // already isolated\r\n        else {\r\n            XmlNode.insertAfter(linkMarkup, tagRunNode);\r\n            XmlNode.remove(tagRunNode);\r\n        }\r\n    }\r\n}","import { MalformedFileError } from '../errors';\r\nimport { Binary } from '../utils';\r\nimport { XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\nimport { ContentTypesFile } from './contentTypesFile';\r\nimport { MediaFiles } from './mediaFiles';\r\nimport { Rels } from './rels';\r\n\r\n/**\r\n * Represents a single docx file.\r\n */\r\nexport class Docx {\r\n\r\n    public get documentPath(): string {\r\n\r\n        if (!this._documentPath) {\r\n\r\n            if (this.zip.isFileExist(\"word/document.xml\")) {\r\n                this._documentPath = \"word/document.xml\";\r\n            }\r\n\r\n            // https://github.com/open-xml-templating/docxtemplater/issues/366\r\n            else if (this.zip.isFileExist(\"word/document2.xml\")) {\r\n                this._documentPath = \"word/document2.xml\";\r\n            }\r\n        }\r\n\r\n        return this._documentPath;\r\n    }\r\n\r\n    public readonly rels: Rels;\r\n    public readonly mediaFiles: MediaFiles;\r\n    public readonly contentTypes: ContentTypesFile;\r\n\r\n    private _documentPath: string;\r\n    private _document: XmlNode;    \r\n\r\n    constructor(\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n        if (!this.documentPath)\r\n            throw new MalformedFileError('docx');\r\n\r\n        this.rels = new Rels(this.documentPath, zip, xmlParser);\r\n        this.mediaFiles = new MediaFiles(zip);\r\n        this.contentTypes = new ContentTypesFile(zip, xmlParser);\r\n    }\r\n\r\n    //\r\n    // public methods\r\n    //\r\n\r\n    /**\r\n     * The xml root of the main document file.\r\n     */\r\n    public async getDocument(): Promise<XmlNode> {\r\n        if (!this._document) {\r\n            const xml = await this.zip.getFile(this.documentPath).getContentText();\r\n            this._document = this.xmlParser.parse(xml);\r\n        }\r\n        return this._document;\r\n    }\r\n\r\n    /**\r\n     * Get the text content of the main document file.\r\n     */\r\n    public async getDocumentText(): Promise<string> {\r\n        const xmlDocument = await this.getDocument();\r\n\r\n        // ugly but good enough...\r\n        const xml = this.xmlParser.serialize(xmlDocument);\r\n        const domDocument = this.xmlParser.domParse(xml);\r\n\r\n        return domDocument.documentElement.textContent;\r\n    }    \r\n\r\n    public async export<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        await this.saveChanges();\r\n        return await this.zip.export(outputType);\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //        \r\n\r\n    private async saveChanges() {\r\n\r\n        // save main document\r\n        const document = await this.getDocument();\r\n        const xmlContent = this.xmlParser.serialize(document);\r\n        this.zip.setFile(this.documentPath, xmlContent);\r\n\r\n        // save other parts\r\n        await this.rels.save();\r\n        await this.contentTypes.save();\r\n    }\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { TemplateData } from '../templateData';\r\nimport { last } from '../utils';\r\nimport { XmlNode } from '../xml';\r\nimport { ILoopStrategy, LoopListStrategy, LoopParagraphStrategy, LoopTableStrategy } from './loop';\r\nimport { PluginUtilities, TemplatePlugin } from './templatePlugin';\r\n\r\nexport const LOOP_CONTENT_TYPE = 'loop';\r\n\r\nexport class LoopPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = LOOP_CONTENT_TYPE;\r\n\r\n    private readonly loopStrategies: ILoopStrategy[] = [\r\n        new LoopTableStrategy(),\r\n        new LoopListStrategy(),\r\n        new LoopParagraphStrategy() // the default strategy\r\n    ];\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n        this.loopStrategies.forEach(strategy => strategy.setUtilities(utilities));\r\n    }    \r\n\r\n    public async containerTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        let value = data.getScopeData<TemplateData[]>();\r\n\r\n        if (!value || !Array.isArray(value) || !value.length)\r\n            value = [];\r\n\r\n        // vars\r\n        const openTag = tags[0];\r\n        const closeTag = last(tags);\r\n\r\n        // select the suitable strategy\r\n        const loopStrategy = this.loopStrategies.find(strategy => strategy.isApplicable(openTag, closeTag));\r\n        if (!loopStrategy)\r\n            throw new Error(`No loop strategy found for tag '${openTag.rawText}'.`);\r\n\r\n        // prepare to loop\r\n        const { firstNode, nodesToRepeat, lastNode } = loopStrategy.splitBefore(openTag, closeTag);\r\n\r\n        // repeat (loop) the content\r\n        const repeatedNodes = this.repeat(nodesToRepeat, value.length);\r\n\r\n        // recursive compilation \r\n        // (this step can be optimized in the future if we'll keep track of the\r\n        // path to each token and use that to create new tokens instead of\r\n        // search through the text again)\r\n        const compiledNodes = await this.compile(repeatedNodes, data, context);\r\n\r\n        // merge back to the document\r\n        loopStrategy.mergeBack(compiledNodes, firstNode, lastNode);\r\n    }\r\n\r\n    private repeat(nodes: XmlNode[], times: number): XmlNode[][] {\r\n        if (!nodes.length || !times)\r\n            return [];\r\n\r\n        const allResults: XmlNode[][] = [];\r\n\r\n        for (let i = 0; i < times; i++) {\r\n            const curResult = nodes.map(node => XmlNode.cloneNode(node, true));\r\n            allResults.push(curResult);\r\n        }\r\n\r\n        return allResults;\r\n    }\r\n\r\n    private async compile(nodeGroups: XmlNode[][], data: ScopeData, context: TemplateContext): Promise<XmlNode[][]> {\r\n        const compiledNodeGroups: XmlNode[][] = [];\r\n\r\n        // compile each node group with it's relevant data\r\n        for (let i = 0; i < nodeGroups.length; i++) {\r\n\r\n            // create dummy root node\r\n            const curNodes = nodeGroups[i];\r\n            const dummyRootNode = XmlNode.createGeneralNode('dummyRootNode');\r\n            curNodes.forEach(node => XmlNode.appendChild(dummyRootNode, node));\r\n\r\n            // compile the new root\r\n            data.path.push(i);\r\n            await this.utilities.compiler.compile(dummyRootNode, data, context);\r\n            data.path.pop();\r\n\r\n            // disconnect from dummy root\r\n            const curResult: XmlNode[] = [];\r\n            while (dummyRootNode.childNodes && dummyRootNode.childNodes.length) {\r\n                const child = XmlNode.removeChild(dummyRootNode, 0);\r\n                curResult.push(child);\r\n            }\r\n            compiledNodeGroups.push(curResult);\r\n        }\r\n\r\n        return compiledNodeGroups;\r\n    }\r\n}","import { ScopeData, Tag } from '../compilation';\r\nimport { XmlNode } from '../xml';\r\nimport { RawXmlContent } from './rawXmlContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport class RawXmlPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = 'rawXml';\r\n\r\n    /**\r\n     * Replace the current <w:t> node with the specified xml markup.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData): void {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const value = data.getScopeData<RawXmlContent>();\r\n        if (value && typeof value.xml === 'string') {\r\n            const newNode = this.utilities.xmlParser.parse(value.xml);\r\n            XmlNode.insertBefore(newNode, wordTextNode);\r\n        }\r\n\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n}","import { ScopeData, Tag } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlNode, XmlTextNode } from '../xml';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport const TEXT_CONTENT_TYPE = 'text';\r\n\r\nexport class TextPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = TEXT_CONTENT_TYPE;\r\n\r\n    /**\r\n     * Replace the node text content with the specified value.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData): void {\r\n\r\n        const value = data.getScopeData();\r\n        const stringValue = (value === null || value === undefined) ? '' : value.toString();\r\n        const lines = stringValue.split('\\n');\r\n\r\n        if (lines.length < 2) {\r\n            this.replaceSingleLine(tag.xmlTextNode, lines.length ? lines[0] : '');\r\n        } else {\r\n            this.replaceMultiLine(tag.xmlTextNode, lines);\r\n        }\r\n    }\r\n\r\n    private replaceSingleLine(textNode: XmlTextNode, text: string) {\r\n\r\n        // set text\r\n        textNode.textContent = text;\r\n\r\n        // make sure leading and trailing whitespace are preserved\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(textNode);\r\n        this.utilities.docxParser.setSpacePreserveAttribute(wordTextNode);\r\n    }\r\n\r\n    private replaceMultiLine(textNode: XmlTextNode, lines: string[]) {\r\n\r\n        const runNode = this.utilities.docxParser.containingRunNode(textNode);\r\n\r\n        // first line\r\n        textNode.textContent = lines[0];\r\n\r\n        // other lines\r\n        for (let i = 1; i < lines.length; i++) {\r\n\r\n            // add line break\r\n            const lineBreak = this.getLineBreak();\r\n            XmlNode.appendChild(runNode, lineBreak);\r\n\r\n            // add text\r\n            const lineNode = this.createWordTextNode(lines[i]);\r\n            XmlNode.appendChild(runNode, lineNode);\r\n        }\r\n    }\r\n\r\n    private getLineBreak(): XmlNode {\r\n        return XmlNode.createGeneralNode('w:br');\r\n    }\r\n\r\n    private createWordTextNode(text: string): XmlNode {\r\n        const wordTextNode = XmlNode.createGeneralNode(DocxParser.TEXT_NODE);\r\n\r\n        wordTextNode.attributes = {};\r\n        this.utilities.docxParser.setSpacePreserveAttribute(wordTextNode);\r\n\r\n        wordTextNode.childNodes = [\r\n            XmlNode.createTextNode(text)\r\n        ];\r\n\r\n        return wordTextNode;\r\n    }\r\n}","export * from './zip';\r\nexport * from './zipObject';\r\n","import * as JSZip from 'jszip';\r\nimport { MissingArgumentError } from '../errors';\r\nimport { Binary } from '../utils';\r\n\r\nexport class JsZipHelper {\r\n\r\n    public static toJsZipOutputType(binary: Binary): JSZip.OutputType;\r\n    public static toJsZipOutputType(binaryType: Constructor<Binary>): JSZip.OutputType;\r\n    public static toJsZipOutputType(binaryOrType: Binary | Constructor<Binary>): JSZip.OutputType {\r\n\r\n        if (!binaryOrType)\r\n            throw new MissingArgumentError(nameof(binaryOrType));\r\n\r\n        let binaryType: Constructor<Binary>;\r\n        if (typeof binaryOrType === 'function') {\r\n            binaryType = binaryOrType as Constructor<Binary>;\r\n        } else {\r\n            binaryType = binaryOrType.constructor as Constructor<Binary>;\r\n        }\r\n\r\n        if (Binary.isBlobConstructor(binaryType))\r\n            return 'blob';\r\n        if (Binary.isArrayBufferConstructor(binaryType))\r\n            return 'arraybuffer';\r\n        if (Binary.isBufferConstructor(binaryType))\r\n            return 'nodebuffer';\r\n\r\n        throw new Error(`Binary type '${binaryType.name}' is not supported.`);\r\n    };\r\n}","import * as JSZip from 'jszip';\r\nimport { Binary } from '../utils';\r\nimport { JsZipHelper } from './jsZipHelper';\r\n\r\nexport class ZipObject {\r\n\r\n    public get name(): string {\r\n        return this.zipObject.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this.zipObject.name = value;\r\n    }\r\n\r\n    public get isDirectory(): boolean {\r\n        return this.zipObject.dir;\r\n    }\r\n\r\n    constructor(private readonly zipObject: JSZip.JSZipObject) { }\r\n\r\n    public getContentText(): Promise<string> {\r\n        return this.zipObject.async('text');\r\n    }\r\n    \r\n    public getContentBase64(): Promise<string> {\r\n        return this.zipObject.async('binarystring');\r\n    }\r\n\r\n    public getContentBinary<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        const zipOutputType: JSZip.OutputType = JsZipHelper.toJsZipOutputType(outputType);\r\n        return this.zipObject.async(zipOutputType) as any;\r\n    }\r\n}","\r\nexport class Delimiters {\r\n\r\n    public tagStart = \"{\";\r\n    public tagEnd = \"}\";\r\n    public containerTagOpen = \"#\";\r\n    public containerTagClose = \"/\";\r\n\r\n    constructor(initial?: Partial<Delimiters>) {\r\n        Object.assign(this, initial);\r\n\r\n        this.encodeAndValidate();\r\n\r\n        if (this.containerTagOpen === this.containerTagClose)\r\n            throw new Error(`${nameof(this.containerTagOpen)} can not be equal to ${nameof(this.containerTagClose)}`);\r\n    }\r\n\r\n    private encodeAndValidate() {\r\n        const keys: (keyof Delimiters)[] = ['tagStart', 'tagEnd', 'containerTagOpen', 'containerTagClose'];\r\n        for (const key of keys) {\r\n\r\n            const value = this[key];\r\n            if (!value)\r\n                throw new Error(`${key} can not be empty.`);\r\n\r\n            if (value !== value.trim())\r\n                throw new Error(`${key} can not contain leading or trailing whitespace.`);\r\n        }\r\n    }\r\n}","import { Delimiters } from './delimiters';\r\nimport { createDefaultPlugins, LOOP_CONTENT_TYPE, TemplatePlugin, TEXT_CONTENT_TYPE } from './plugins';\r\n\r\nexport class TemplateHandlerOptions {\r\n\r\n    public plugins?: TemplatePlugin[] = createDefaultPlugins();\r\n\r\n    public defaultContentType?= TEXT_CONTENT_TYPE;\r\n\r\n    public containerContentType?= LOOP_CONTENT_TYPE;\r\n\r\n    public delimiters?: Partial<Delimiters> = new Delimiters();\r\n\r\n    public maxXmlDepth?= 20;\r\n\r\n    constructor(initial?: Partial<TemplateHandlerOptions>) {\r\n        Object.assign(this, initial);\r\n\r\n        if (initial) {\r\n            this.delimiters = new Delimiters(initial.delimiters);\r\n        }\r\n\r\n        if (!this.plugins.length) {\r\n            throw new Error('Plugins list can not be empty');\r\n        }\r\n    }\r\n}","export * from './compilation';\r\nexport * from './errors';\r\nexport * from './office';\r\nexport * from './plugins';\r\nexport * from './utils';\r\nexport * from './xml';\r\nexport * from './zip';\r\nexport * from './delimiters';\r\nexport * from './mimeType';\r\nexport * from './templateData';\r\nexport * from './templateHandler';\r\nexport * from './templateHandlerOptions';\r\n","import { MissingArgumentError } from '../errors';\r\nimport { DocxParser } from '../office';\r\nimport { first, last } from '../utils';\r\nimport { XmlDepthTracker, XmlNode, XmlTextNode } from '../xml';\r\nimport { DelimiterMark } from './delimiterMark';\r\n\r\nclass MatchState {\r\n\r\n    public delimiterIndex = 0;\r\n    public openNodes: XmlTextNode[] = [];\r\n    public firstMatchIndex = -1;\r\n\r\n    public reset() {\r\n        this.delimiterIndex = 0;\r\n        this.openNodes = [];\r\n        this.firstMatchIndex = -1;\r\n    }\r\n}\r\n\r\nexport class DelimiterSearcher {\r\n\r\n    public maxXmlDepth = 20;\r\n    public startDelimiter = \"{\";\r\n    public endDelimiter = \"}\";\r\n\r\n    constructor(private readonly docxParser: DocxParser) {\r\n        if (!docxParser)\r\n            throw new MissingArgumentError(nameof(docxParser));\r\n    }\r\n\r\n    public findDelimiters(node: XmlNode): DelimiterMark[] {\r\n\r\n        //\r\n        // Performance note: \r\n        //\r\n        // The search efficiency is o(m*n) where n is the text size and m is the\r\n        // delimiter length. We could use a variation of the KMP algorithm here\r\n        // to reduce it to o(m+n) but since our m is expected to be small\r\n        // (delimiters defaults to 2 characters and even on custom inputs are\r\n        // not expected to be much longer) it does not worth the extra\r\n        // complexity and effort.\r\n        //\r\n\r\n        const delimiters: DelimiterMark[] = [];\r\n        const match = new MatchState();\r\n        const depth = new XmlDepthTracker(this.maxXmlDepth);\r\n        let lookForOpenDelimiter = true;\r\n\r\n        while (node) {\r\n\r\n            // reset state on paragraph transition\r\n            if (this.docxParser.isParagraphNode(node)) {\r\n                match.reset();\r\n            }\r\n\r\n            // skip irrelevant nodes\r\n            if (!this.shouldSearchNode(node)) {\r\n                node = this.findNextNode(node, depth);\r\n                continue;\r\n            }\r\n\r\n            // search delimiters in text nodes\r\n            match.openNodes.push(node);\r\n            let textIndex = 0;\r\n            while (textIndex < node.textContent.length) {\r\n\r\n                const delimiterPattern = lookForOpenDelimiter ? this.startDelimiter : this.endDelimiter;\r\n\r\n                // char match\r\n                const char = node.textContent[textIndex];\r\n                if (char === delimiterPattern[match.delimiterIndex]) {\r\n\r\n                    // first match\r\n                    if (match.firstMatchIndex === -1) {\r\n                        match.firstMatchIndex = textIndex;\r\n                    }\r\n\r\n                    // full delimiter match\r\n                    if (match.delimiterIndex === delimiterPattern.length - 1) {\r\n\r\n                        // move all delimiters characters to the same text node\r\n                        if (match.openNodes.length > 1) {\r\n                            \r\n                            const firstNode = first(match.openNodes);\r\n                            const lastNode = last(match.openNodes);\r\n                            this.docxParser.joinTextNodesRange(firstNode, lastNode);\r\n                            \r\n                            textIndex += (firstNode.textContent.length - node.textContent.length);\r\n                            node = firstNode;\r\n                        }\r\n\r\n                        // store delimiter\r\n                        const delimiterMark = this.createDelimiterMark(match, lookForOpenDelimiter);\r\n                        delimiters.push(delimiterMark);\r\n\r\n                        // update state\r\n                        lookForOpenDelimiter = !lookForOpenDelimiter;\r\n                        match.reset();\r\n                        if (textIndex < node.textContent.length - 1) {\r\n                            match.openNodes.push(node);\r\n                        }\r\n\r\n                    } else {\r\n                        match.delimiterIndex++;\r\n                    }\r\n                }\r\n\r\n                // no match\r\n                else {\r\n\r\n                    //\r\n                    // go back to first open node\r\n                    //\r\n                    // Required for cases where the text has repeating\r\n                    // characters that are the same as a delimiter prefix.  \r\n                    // For instance:  \r\n                    // Delimiter is '{!' and template text contains the string '{{!'\r\n                    //\r\n                    if (match.firstMatchIndex !== -1) {\r\n                        node = first(match.openNodes);\r\n                        textIndex = match.firstMatchIndex;\r\n                    }\r\n\r\n                    // update state\r\n                    match.reset();\r\n                    if (textIndex < node.textContent.length - 1) {\r\n                        match.openNodes.push(node);\r\n                    }\r\n                }\r\n\r\n                textIndex++;\r\n            }\r\n\r\n            node = this.findNextNode(node, depth);\r\n        }\r\n\r\n        return delimiters;\r\n    }\r\n\r\n    private shouldSearchNode(node: XmlNode): node is XmlTextNode {\r\n\r\n        if (!XmlNode.isTextNode(node))\r\n            return false;\r\n        if (!node.textContent)\r\n            return false;\r\n        if (!node.parentNode)\r\n            return false;\r\n        if (!this.docxParser.isTextNode(node.parentNode))\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    private findNextNode(node: XmlNode, depth: XmlDepthTracker): XmlNode {\r\n\r\n        // children\r\n        if (node.childNodes && node.childNodes.length) {\r\n            depth.increment();\r\n            return node.childNodes[0];\r\n        }\r\n\r\n        // siblings\r\n        if (node.nextSibling)\r\n            return node.nextSibling;\r\n\r\n        // parent sibling\r\n        while (node.parentNode) {\r\n\r\n            if (node.parentNode.nextSibling) {\r\n                depth.decrement();\r\n                return node.parentNode.nextSibling;\r\n            }\r\n\r\n            // go up\r\n            depth.decrement();\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private createDelimiterMark(match: MatchState, isOpenDelimiter: boolean): DelimiterMark {\r\n        return {\r\n            index: match.firstMatchIndex,\r\n            isOpen: isOpenDelimiter,\r\n            xmlTextNode: match.openNodes[0]\r\n        };\r\n    }\r\n}","export class MalformedFileError extends Error {\r\n\r\n    public readonly expectedFileType: string;\r\n\r\n    constructor(expectedFileType: string) {\r\n        super(`Malformed file detected. Make sure the file is a valid ${expectedFileType} file.`);\r\n\r\n        this.expectedFileType = expectedFileType;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MalformedFileError.prototype);\r\n    }\r\n}","export class MaxXmlDepthError extends Error {\r\n\r\n    public readonly maxDepth: number;\r\n\r\n    constructor(maxDepth: number) {\r\n        super(`XML maximum depth reached (max depth: ${maxDepth}).`);\r\n\r\n        this.maxDepth = maxDepth;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MaxXmlDepthError.prototype);\r\n    }\r\n}","export class MissingArgumentError extends Error {\r\n\r\n    public readonly argName: string;\r\n\r\n    constructor(argName: string) {\r\n        super(`Argument '${argName}' is missing.`);\r\n\r\n        this.argName = argName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingArgumentError.prototype);\r\n    }\r\n}","export class MissingCloseDelimiterError extends Error {\r\n\r\n    public readonly openDelimiterText: string;\r\n\r\n    constructor(openDelimiterText: string) {\r\n        super(`Close delimiter is missing from '${openDelimiterText}'.`);\r\n\r\n        this.openDelimiterText = openDelimiterText;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingCloseDelimiterError.prototype);\r\n    }\r\n}","export class MissingStartDelimiterError extends Error {\r\n\r\n    public readonly closeDelimiterText: string;\r\n\r\n    constructor(closeDelimiterText: string) {\r\n        super(`Open delimiter is missing from '${closeDelimiterText}'.`);\r\n\r\n        this.closeDelimiterText = closeDelimiterText;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingStartDelimiterError.prototype);\r\n    }\r\n}","export class UnclosedTagError extends Error {\r\n\r\n    public readonly tagName: string;\r\n\r\n    constructor(tagName: string) {\r\n        super(`Tag '${tagName}' is never closed.`);\r\n\r\n        this.tagName = tagName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnclosedTagError.prototype);\r\n    }\r\n}","export class UnidentifiedFileTypeError extends Error {\r\n    constructor() {\r\n        super(`The filetype for this file could not be identified, is this file corrupted?`);\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnidentifiedFileTypeError.prototype);\r\n    }\r\n}","export class UnknownContentTypeError extends Error {\r\n\r\n    public readonly tagRawText: string;\r\n    public readonly contentType: string;\r\n    public readonly path: string;\r\n\r\n    constructor(contentType: string, tagRawText: string, path: string) {\r\n        super(`Content type '${contentType}' does not have a registered plugin to handle it.`);\r\n\r\n        this.contentType = contentType;\r\n        this.tagRawText = tagRawText;\r\n        this.path = path;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnknownContentTypeError.prototype);\r\n    }\r\n}","export class UnopenedTagError extends Error {\r\n\r\n    public readonly tagName: string;\r\n\r\n    constructor(tagName: string) {\r\n        super(`Tag '${tagName}' is closed but was never opened.`);\r\n\r\n        this.tagName = tagName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnopenedTagError.prototype);\r\n    }\r\n}","export class UnsupportedFileTypeError extends Error {\r\n\r\n    public readonly fileType: string;\r\n\r\n    constructor(fileType: string) {\r\n        super(`Filetype \"${fileType}\" is not supported.`);\r\n\r\n        this.fileType = fileType;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnsupportedFileTypeError.prototype);\r\n    }\r\n}","\r\nexport type ItemMapper<TIn, TOut = string> = (item: TIn, index: number) => TOut;\r\n\r\nexport function pushMany<T>(destArray: T[], items: T[]): void {\r\n    Array.prototype.push.apply(destArray, items);\r\n}\r\n\r\nexport function first<T>(array: T[]): T {\r\n    if (!array.length)\r\n        return undefined;\r\n    return array[0];\r\n}\r\n\r\nexport function last<T>(array: T[]): T {\r\n    if (!array.length)\r\n        return undefined;\r\n    return array[array.length - 1];\r\n}\r\n\r\nexport function toDictionary<TIn, TOut = TIn>(array: TIn[], keySelector: ItemMapper<TIn>, valueSelector?: ItemMapper<TIn, TOut>): IMap<TOut> {\r\n    if (!array.length)\r\n        return {};\r\n\r\n    const res: IMap<any> = {};\r\n    array.forEach((item, index) => {\r\n        const key = keySelector(item, index);\r\n        const value = (valueSelector ? valueSelector(item, index) : item);\r\n        if (res[key])\r\n            throw new Error(`Key '${key}' already exists in the dictionary.`);\r\n        res[key] = value;\r\n    });\r\n    return res;\r\n};","import { Base64 } from './base64';\r\nimport { inheritsFrom } from './types';\r\n\r\nexport type Binary = Blob | Buffer | ArrayBuffer;\r\n\r\nexport const Binary = {\r\n\r\n    //\r\n    // type detection\r\n    //\r\n\r\n    isBlob(binary: any): binary is Blob {\r\n        return this.isBlobConstructor(binary.constructor);\r\n    },\r\n\r\n    isArrayBuffer(binary: any): binary is ArrayBuffer {\r\n        return this.isArrayBufferConstructor(binary.constructor);\r\n    },\r\n\r\n    isBuffer(binary: any): binary is Buffer {\r\n        return this.isBufferConstructor(binary.constructor);\r\n    },\r\n\r\n    isBlobConstructor(binaryType: Constructor<any>): binaryType is Constructor<Blob> {\r\n        return (typeof Blob !== 'undefined' && inheritsFrom(binaryType, Blob));\r\n    },\r\n\r\n    isArrayBufferConstructor(binaryType: Constructor<any>): binaryType is Constructor<ArrayBuffer> {\r\n        return (typeof ArrayBuffer !== 'undefined' && inheritsFrom(binaryType, ArrayBuffer));\r\n    },\r\n\r\n    isBufferConstructor(binaryType: Constructor<any>): binaryType is Constructor<Buffer> {\r\n        return (typeof Buffer !== 'undefined' && inheritsFrom(binaryType, Buffer));\r\n    },\r\n\r\n    //\r\n    // utilities\r\n    //\r\n\r\n    toBase64(binary: Binary): Promise<string> {\r\n\r\n        if (this.isBlob(binary)) {\r\n            return new Promise(resolve => {\r\n                const fileReader = new FileReader();\r\n                fileReader.onload = function () {\r\n                    const base64 = Base64.encode(this.result as string);\r\n                    resolve(base64);\r\n                };\r\n                fileReader.readAsBinaryString(binary);\r\n            });\r\n        }\r\n\r\n        if (this.isBuffer(binary)) {\r\n            return Promise.resolve(binary.toString('base64'));\r\n        }\r\n\r\n        if (this.isArrayBuffer(binary)) {\r\n            // https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string#42334410\r\n            const binaryStr = new Uint8Array(binary).reduce((str, byte) => str + String.fromCharCode(byte), '');\r\n            const base64 = Base64.encode(binaryStr);\r\n            return Promise.resolve(base64);\r\n        }\r\n\r\n        throw new Error(`Binary type '${(binary as any).constructor.name}' is not supported.`);\r\n    }\r\n};\r\n\r\n","export class Path {\r\n\r\n    public static getFilename(path: string): string {\r\n        const lastSlashIndex = path.lastIndexOf('/');\r\n        return path.substr(lastSlashIndex + 1);\r\n    }\r\n\r\n    public static getDirectory(path: string): string {\r\n        const lastSlashIndex = path.lastIndexOf('/');\r\n        return path.substring(0, lastSlashIndex);\r\n    }\r\n}","/**\r\n * Secure Hash Algorithm (SHA1)\r\n * \r\n * Taken from here: http://www.webtoolkit.info/javascript-sha1.html\r\n * \r\n * Recommended here: https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript#6122732\r\n */\r\nexport function sha1(msg: string) {\r\n\r\n    msg = utf8Encode(msg);\r\n    const msgLength = msg.length;\r\n\r\n    let i, j;\r\n\r\n    const wordArray = [];\r\n    for (i = 0; i < msgLength - 3; i += 4) {\r\n        j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 |\r\n            msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);\r\n        wordArray.push(j);\r\n    }\r\n\r\n    switch (msgLength % 4) {\r\n        case 0:\r\n            i = 0x080000000;\r\n            break;\r\n        case 1:\r\n            i = msg.charCodeAt(msgLength - 1) << 24 | 0x0800000;\r\n            break;\r\n        case 2:\r\n            i = msg.charCodeAt(msgLength - 2) << 24 | msg.charCodeAt(msgLength - 1) << 16 | 0x08000;\r\n            break;\r\n        case 3:\r\n            i = msg.charCodeAt(msgLength - 3) << 24 | msg.charCodeAt(msgLength - 2) << 16 | msg.charCodeAt(msgLength - 1) << 8 | 0x80;\r\n            break;\r\n    }\r\n    wordArray.push(i);\r\n\r\n    while ((wordArray.length % 16) != 14) {\r\n        wordArray.push(0);\r\n    }\r\n\r\n    wordArray.push(msgLength >>> 29);\r\n    wordArray.push((msgLength << 3) & 0x0ffffffff);\r\n\r\n    const w = new Array(80);\r\n    let H0 = 0x67452301;\r\n    let H1 = 0xEFCDAB89;\r\n    let H2 = 0x98BADCFE;\r\n    let H3 = 0x10325476;\r\n    let H4 = 0xC3D2E1F0;\r\n    let A, B, C, D, E;\r\n    let temp;\r\n    for (let blockStart = 0; blockStart < wordArray.length; blockStart += 16) {\r\n\r\n        for (i = 0; i < 16; i++) {\r\n            w[i] = wordArray[blockStart + i];\r\n        }\r\n        for (i = 16; i <= 79; i++) {\r\n            w[i] = rotateLeft(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);\r\n        }\r\n        A = H0;\r\n        B = H1;\r\n        C = H2;\r\n        D = H3;\r\n        E = H4;\r\n        for (i = 0; i <= 19; i++) {\r\n            temp = (rotateLeft(A, 5) + ((B & C) | (~B & D)) + E + w[i] + 0x5A827999) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 20; i <= 39; i++) {\r\n            temp = (rotateLeft(A, 5) + (B ^ C ^ D) + E + w[i] + 0x6ED9EBA1) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 40; i <= 59; i++) {\r\n            temp = (rotateLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + w[i] + 0x8F1BBCDC) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 60; i <= 79; i++) {\r\n            temp = (rotateLeft(A, 5) + (B ^ C ^ D) + E + w[i] + 0xCA62C1D6) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        H0 = (H0 + A) & 0x0ffffffff;\r\n        H1 = (H1 + B) & 0x0ffffffff;\r\n        H2 = (H2 + C) & 0x0ffffffff;\r\n        H3 = (H3 + D) & 0x0ffffffff;\r\n        H4 = (H4 + E) & 0x0ffffffff;\r\n    }\r\n    temp = cvtHex(H0) + cvtHex(H1) + cvtHex(H2) + cvtHex(H3) + cvtHex(H4);\r\n    return temp.toLowerCase();\r\n}\r\n\r\nfunction rotateLeft(n: any, s: any) {\r\n    const t4 = (n << s) | (n >>> (32 - s));\r\n    return t4;\r\n}\r\n\r\nfunction cvtHex(val: any) {\r\n    let str = \"\";\r\n    for (let i = 7; i >= 0; i--) {\r\n        const v = (val >>> (i * 4)) & 0x0f;\r\n        str += v.toString(16);\r\n    }\r\n    return str;\r\n}\r\n\r\nfunction utf8Encode(str: string) {\r\n    str = str.replace(/\\r\\n/g, \"\\n\");\r\n    let utfStr = \"\";\r\n    for (let n = 0; n < str.length; n++) {\r\n        const c = str.charCodeAt(n);\r\n        if (c < 128) {\r\n            utfStr += String.fromCharCode(c);\r\n\r\n        } else if ((c > 127) && (c < 2048)) {\r\n            utfStr += String.fromCharCode((c >> 6) | 192);\r\n            utfStr += String.fromCharCode((c & 63) | 128);\r\n\r\n        } else {\r\n            utfStr += String.fromCharCode((c >> 12) | 224);\r\n            utfStr += String.fromCharCode(((c >> 6) & 63) | 128);\r\n            utfStr += String.fromCharCode((c & 63) | 128);\r\n        }\r\n    }\r\n    return utfStr;\r\n}\r\n","import { MaxXmlDepthError } from '../errors';\r\n\r\nexport class XmlDepthTracker {\r\n    \r\n    private depth = 0;\r\n\r\n    constructor(private readonly maxDepth: number) { }\r\n\r\n    public increment(): void {\r\n        this.depth++;\r\n        if (this.depth > this.maxDepth) {\r\n            throw new MaxXmlDepthError(this.maxDepth);\r\n        }\r\n    }\r\n\r\n    public decrement(): void {\r\n        this.depth--;\r\n    }\r\n}","import * as xmldom from 'xmldom';\r\nimport { MissingArgumentError } from '../errors';\r\nimport { XmlNode } from './xmlNode';\r\n\r\nexport class XmlParser {\r\n\r\n    private static xmlHeader = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>';\r\n    /**\r\n     * We always use the DOMParser from 'xmldom', even in the browser since it\r\n     * handles xml namespaces more forgivingly (required mainly by the\r\n     * RawXmlPlugin).\r\n     */\r\n    private static readonly parser = new xmldom.DOMParser();\r\n\r\n    public parse(str: string): XmlNode {\r\n        const doc = this.domParse(str);\r\n        return XmlNode.fromDomNode(doc.documentElement);\r\n    }\r\n\r\n    public domParse(str: string): Document {\r\n        if (str === null || str === undefined)\r\n            throw new MissingArgumentError(nameof(str));\r\n\r\n        return XmlParser.parser.parseFromString(str, \"text/xml\");\r\n    }\r\n\r\n    public serialize(xmlNode: XmlNode): string {\r\n        return XmlParser.xmlHeader + XmlNode.serialize(xmlNode);\r\n    }    \r\n}\r\n","module.exports = require(\"xmldom\");","import { TemplateContent, TemplateData } from \"../templateData\";\r\nimport { last } from \"../utils\";\r\n\r\nconst getProp = require(\"lodash.get\");\r\n\r\nexport class ScopeData {\r\n    public readonly path: (string | number)[] = [];\r\n    public readonly allData: TemplateData;\r\n\r\n    constructor(data: TemplateData) {\r\n        this.allData = data;\r\n    }\r\n\r\n    public getScopeData<T extends TemplateContent | TemplateData[]>(): T{\r\n        const lastKey = last(this.path);\r\n\r\n        let result: any;\r\n        let curPath = this.path.slice();\r\n\r\n        while (result === undefined && curPath.length) {\r\n            const curScopePath = curPath.slice(0, curPath.length - 1);\r\n            result = getProp(this.allData, curScopePath.concat(lastKey));\r\n            curPath = curScopePath;\r\n        }\r\n        return result;\r\n    }\r\n}\r\n","module.exports = require(\"lodash.get\");","import { Delimiters } from '../delimiters';\r\nimport { MissingArgumentError, MissingCloseDelimiterError, MissingStartDelimiterError } from '../errors';\r\nimport { DocxParser } from '../office';\r\nimport { DelimiterMark } from './delimiterMark';\r\nimport { Tag, TagDisposition } from './tag';\r\n\r\nexport class TagParser {\r\n\r\n    private readonly tagRegex: RegExp;\r\n\r\n    constructor(\r\n        private readonly docParser: DocxParser,\r\n        private readonly delimiters: Delimiters\r\n    ) {\r\n        if (!docParser)\r\n            throw new MissingArgumentError(nameof(docParser));\r\n        if (!delimiters)\r\n            throw new MissingArgumentError(nameof(delimiters));\r\n\r\n        // TODO: regex escape\r\n        this.tagRegex = new RegExp(`^[${delimiters.tagStart}](.*?)[${delimiters.tagEnd}]`, 'mi');\r\n    }\r\n\r\n    public parse(delimiters: DelimiterMark[]): Tag[] {\r\n        const tags: Tag[] = [];\r\n\r\n        let openedTag: Partial<Tag>;\r\n        let openedDelimiter: DelimiterMark;\r\n        for (let i = 0; i < delimiters.length; i++) {\r\n            const delimiter = delimiters[i];\r\n\r\n            // close before open\r\n            if (!openedTag && !delimiter.isOpen) {\r\n                const closeTagText = delimiter.xmlTextNode.textContent;\r\n                throw new MissingStartDelimiterError(closeTagText);\r\n            }\r\n\r\n            // open before close\r\n            if (openedTag && delimiter.isOpen) {\r\n                const openTagText = openedDelimiter.xmlTextNode.textContent;\r\n                throw new MissingCloseDelimiterError(openTagText);\r\n            }\r\n\r\n            // valid open\r\n            if (!openedTag && delimiter.isOpen) {\r\n                openedTag = {};\r\n                openedDelimiter = delimiter;\r\n            }\r\n\r\n            // valid close\r\n            if (openedTag && !delimiter.isOpen) {\r\n\r\n                // normalize the underlying xml structure\r\n                // (make sure the tag's node only includes the tag's text)\r\n                this.normalizeTagNodes(openedDelimiter, delimiter, i, delimiters);\r\n                openedTag.xmlTextNode = openedDelimiter.xmlTextNode;\r\n\r\n                // extract tag info from tag's text\r\n                this.processTag(openedTag as Tag);\r\n                tags.push(openedTag as Tag);\r\n                openedTag = null;\r\n                openedDelimiter = null;\r\n            }\r\n        }\r\n\r\n        return tags;\r\n    }\r\n\r\n    /**\r\n     * Consolidate all tag's text into a single text node.\r\n     * \r\n     * Example: \r\n     * \r\n     * Text node before: \"some text {some tag} some more text\" \r\n     * Text nodes after: [ \"some text \", \"{some tag}\", \" some more text\" ]\r\n     */\r\n    private normalizeTagNodes(\r\n        openDelimiter: DelimiterMark,\r\n        closeDelimiter: DelimiterMark,\r\n        closeDelimiterIndex: number,\r\n        allDelimiters: DelimiterMark[]\r\n    ): void {\r\n\r\n        let startTextNode = openDelimiter.xmlTextNode;\r\n        let endTextNode = closeDelimiter.xmlTextNode;\r\n        const sameNode = (startTextNode === endTextNode);\r\n\r\n        // trim start\r\n        if (openDelimiter.index > 0) {\r\n            this.docParser.splitTextNode(startTextNode, openDelimiter.index, true);\r\n            if (sameNode) {\r\n                closeDelimiter.index -= openDelimiter.index;\r\n            }\r\n        }\r\n\r\n        // trim end\r\n        if (closeDelimiter.index < endTextNode.textContent.length - 1) {\r\n            endTextNode = this.docParser.splitTextNode(endTextNode, closeDelimiter.index + 1, true);\r\n            if (sameNode) {\r\n                startTextNode = endTextNode;\r\n            }\r\n        }\r\n\r\n        // join nodes\r\n        if (!sameNode) {\r\n            this.docParser.joinTextNodesRange(startTextNode, endTextNode);\r\n            endTextNode = startTextNode;\r\n        }\r\n\r\n        // update offsets of next delimiters\r\n        for (let i = closeDelimiterIndex + 1; i < allDelimiters.length; i++) {\r\n\r\n            let updated = false;\r\n            const curDelimiter = allDelimiters[i];\r\n\r\n            if (curDelimiter.xmlTextNode === openDelimiter.xmlTextNode) {\r\n                curDelimiter.index -= openDelimiter.index;\r\n                updated = true;\r\n            }\r\n\r\n            if (curDelimiter.xmlTextNode === closeDelimiter.xmlTextNode) {\r\n                curDelimiter.index -= closeDelimiter.index + 1;\r\n                updated = true;\r\n            }\r\n\r\n            if (!updated)\r\n                break;\r\n        }\r\n\r\n        // update references\r\n        openDelimiter.xmlTextNode = startTextNode;\r\n        closeDelimiter.xmlTextNode = endTextNode;\r\n    }\r\n\r\n    private processTag(tag: Tag): void {\r\n        tag.rawText = tag.xmlTextNode.textContent;\r\n\r\n        const tagParts = this.tagRegex.exec(tag.rawText);\r\n        const tagContent = (tagParts[1] || '').trim();\r\n        if (!tagContent || !tagContent.length) {\r\n            tag.disposition = TagDisposition.SelfClosed;\r\n            return;\r\n        }\r\n\r\n        if (tagContent.startsWith(this.delimiters.containerTagOpen)) {\r\n            tag.disposition = TagDisposition.Open;\r\n            tag.name = tagContent.slice(this.delimiters.containerTagOpen.length).trim();\r\n\r\n        } else if (tagContent.startsWith(this.delimiters.containerTagClose)) {\r\n            tag.disposition = TagDisposition.Close;\r\n            tag.name = tagContent.slice(this.delimiters.containerTagClose.length).trim();\r\n\r\n        } else {\r\n            tag.disposition = TagDisposition.SelfClosed;\r\n            tag.name = tagContent;\r\n        }\r\n    }\r\n}","import { UnclosedTagError, UnknownContentTypeError } from '../errors';\r\nimport { PluginContent, TemplatePlugin } from '../plugins';\r\nimport { isPromiseLike, toDictionary } from '../utils';\r\nimport { XmlNode } from '../xml';\r\nimport { DelimiterSearcher } from './delimiterSearcher';\r\nimport { ScopeData } from './scopeData';\r\nimport { Tag, TagDisposition } from './tag';\r\nimport { TagParser } from './tagParser';\r\nimport { TemplateContext } from './templateContext';\r\n\r\n/**\r\n * The TemplateCompiler works roughly the same way as a source code compiler.\r\n * It's main steps are:\r\n * \r\n * 1. find delimiters (lexical analysis) :: (Document) => DelimiterMark[]\r\n * 2. extract tags (syntax analysis) :: (DelimiterMark[]) => Tag[]\r\n * 3. perform document replace (code generation) :: (Tag[], data) => Document*\r\n * \r\n * see: https://en.wikipedia.org/wiki/Compiler\r\n */\r\nexport class TemplateCompiler {\r\n\r\n    private readonly pluginsLookup: IMap<TemplatePlugin>;\r\n\r\n    constructor(\r\n        private readonly delimiterSearcher: DelimiterSearcher,\r\n        private readonly tagParser: TagParser,\r\n        plugins: TemplatePlugin[],\r\n        private readonly defaultContentType: string,\r\n        private readonly containerContentType: string\r\n    ) {\r\n        this.pluginsLookup = toDictionary(plugins, p => p.contentType);\r\n    }\r\n\r\n    /**\r\n     * Compiles the template and performs the required replacements using the\r\n     * specified data.\r\n     */\r\n    public async compile(node: XmlNode, data: ScopeData, context: TemplateContext): Promise<void> {\r\n        const tags = this.parseTags(node);\r\n        await this.doTagReplacements(tags, data, context);\r\n    }\r\n\r\n    public parseTags(node: XmlNode): Tag[] {\r\n        const delimiters = this.delimiterSearcher.findDelimiters(node);\r\n        const tags = this.tagParser.parse(delimiters);\r\n        return tags;\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private async doTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        for (let tagIndex = 0; tagIndex < tags.length; tagIndex++) {\r\n\r\n            const tag = tags[tagIndex];\r\n            data.path.push(tag.name);\r\n            const contentType = this.detectContentType(tag, data);\r\n            const plugin = this.pluginsLookup[contentType];\r\n            if (!plugin) {\r\n                throw new UnknownContentTypeError(\r\n                    contentType,\r\n                    tag.rawText,\r\n                    data.path.join('.')\r\n                );\r\n            }\r\n\r\n            if (tag.disposition === TagDisposition.SelfClosed) {\r\n\r\n                // replace simple tag                \r\n                const job = plugin.simpleTagReplacements(tag, data, context);\r\n                if (isPromiseLike(job)) {\r\n                    await job;\r\n                }\r\n\r\n            } else if (tag.disposition === TagDisposition.Open) {\r\n\r\n                // get all tags between the open and close tags\r\n                const closingTagIndex = this.findCloseTagIndex(tagIndex, tag, tags);\r\n                const scopeTags = tags.slice(tagIndex, closingTagIndex + 1);\r\n                tagIndex = closingTagIndex;\r\n\r\n                // replace container tag\r\n                const job = plugin.containerTagReplacements(scopeTags, data, context);\r\n                if (isPromiseLike(job)) {\r\n                    await job;\r\n                }\r\n            }\r\n\r\n            data.path.pop();\r\n        }\r\n    }\r\n\r\n    private detectContentType(tag: Tag, data: ScopeData): string {\r\n\r\n        if (tag.disposition === TagDisposition.Open || tag.disposition === TagDisposition.Close)\r\n            return this.containerContentType;\r\n\r\n        const scopeData = data.getScopeData();\r\n        if (PluginContent.isPluginContent(scopeData))\r\n            return scopeData._type;\r\n\r\n        return this.defaultContentType;\r\n    }\r\n\r\n    private findCloseTagIndex(fromIndex: number, openTag: Tag, tags: Tag[]): number {\r\n\r\n        let i = fromIndex;\r\n        for (; i < tags.length; i++) {\r\n            const closeTag = tags[i];\r\n            if (\r\n                closeTag.name === openTag.name &&\r\n                closeTag.disposition === TagDisposition.Close\r\n            ) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (i === tags.length) {\r\n            throw new UnclosedTagError(openTag.name);\r\n        }\r\n\r\n        return i;\r\n    }\r\n}","import { ImagePlugin } from './imagePlugin';\r\nimport { LinkPlugin } from './linkPlugin';\r\nimport { LoopPlugin } from './loopPlugin';\r\nimport { RawXmlPlugin } from './rawXmlPlugin';\r\nimport { TemplatePlugin } from './templatePlugin';\r\nimport { TextPlugin } from './textPlugin';\r\n\r\nexport function createDefaultPlugins(): TemplatePlugin[] {\r\n    return [\r\n        new LoopPlugin(), \r\n        new RawXmlPlugin(),\r\n        new ImagePlugin(),\r\n        new LinkPlugin(),\r\n        new TextPlugin()\r\n    ];\r\n}","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { XmlGeneralNode, XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * http://officeopenxml.com/anatomyofOOXML.php\r\n */\r\nexport class ContentTypesFile {\r\n\r\n    private static readonly contentTypesFilePath = '[Content_Types].xml';\r\n\r\n    private addedNew = false;\r\n\r\n    private root: XmlNode;\r\n\r\n    private contentTypes: IMap<boolean>;\r\n\r\n    constructor(\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n    }\r\n\r\n    public async ensureContentType(mime: MimeType): Promise<void> {\r\n\r\n        // parse the content types file\r\n        await this.parseContentTypesFile();\r\n\r\n        // already exists\r\n        if (this.contentTypes[mime])\r\n            return;\r\n\r\n        // add new\r\n        const extension = MimeTypeHelper.getDefaultExtension(mime);\r\n        const typeNode = XmlNode.createGeneralNode('Default');\r\n        typeNode.attributes = {\r\n            \"Extension\": extension,\r\n            \"ContentType\": mime\r\n        };\r\n        this.root.childNodes.push(typeNode);\r\n\r\n        // update state\r\n        this.addedNew = true;\r\n        this.contentTypes[mime] = true;\r\n    }\r\n\r\n    public async count(): Promise<number> {\r\n        await this.parseContentTypesFile();\r\n        return this.root.childNodes.filter(node => !XmlNode.isTextNode(node)).length;\r\n    }\r\n\r\n    /**\r\n     * Save the Content Types file back to the zip.  \r\n     * Called automatically by the holding `Docx` before exporting.\r\n     */\r\n    public async save(): Promise<void> {\r\n\r\n        // not change - no need to save\r\n        if (!this.addedNew)\r\n            return;\r\n\r\n        const xmlContent = this.xmlParser.serialize(this.root);\r\n        this.zip.setFile(ContentTypesFile.contentTypesFilePath, xmlContent);\r\n    }\r\n\r\n    private async parseContentTypesFile(): Promise<void> {\r\n        if (this.root)\r\n            return;\r\n\r\n        // parse the xml file\r\n        const contentTypesXml = await this.zip.getFile(ContentTypesFile.contentTypesFilePath).getContentText();\r\n        this.root = this.xmlParser.parse(contentTypesXml);\r\n\r\n        // build the content types lookup\r\n        this.contentTypes = {};\r\n        for (const node of this.root.childNodes) {\r\n\r\n            if (node.nodeName !== 'Default')\r\n                continue;\r\n\r\n            const genNode = (node as XmlGeneralNode);\r\n            const contentTypeAttribute = genNode.attributes['ContentType'];\r\n            if (!contentTypeAttribute)\r\n                continue;\r\n\r\n            this.contentTypes[contentTypeAttribute];\r\n        }\r\n    }\r\n}","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { Binary, Path, sha1 } from '../utils';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * Handles media files of the main document.\r\n */\r\nexport class MediaFiles {\r\n\r\n    private static readonly mediaDir = 'word/media';\r\n\r\n    private hashes: IMap<string>;\r\n    private readonly files = new Map<Binary, string>();\r\n    private nextFileId = 0;\r\n\r\n    constructor(private readonly zip: Zip) {\r\n    }\r\n\r\n    /**\r\n     * Returns the media file path.\r\n     */\r\n    public async add(mediaFile: Binary, mime: MimeType): Promise<string> {\r\n\r\n        // check if already added\r\n        if (this.files.has(mediaFile))\r\n            return this.files.get(mediaFile);\r\n\r\n        // hash existing media files\r\n        await this.hashMediaFiles();\r\n\r\n        // hash the new file  \r\n        // Note: Even though hashing the base64 string may seem inefficient\r\n        // (requires extra step in some cases) in practice it is significantly\r\n        // faster than hashing a 'binarystring'.\r\n        const base64 = await Binary.toBase64(mediaFile);\r\n        const hash = sha1(base64);\r\n\r\n        // check if file already exists\r\n        // note: this can be optimized by keeping both mapping by filename as well as by hash\r\n        let path = Object.keys(this.hashes).find(p => this.hashes[p] === hash);\r\n        if (path)\r\n            return path;\r\n\r\n        // generate unique media file name\r\n        const extension = MimeTypeHelper.getDefaultExtension(mime);\r\n        do {\r\n            this.nextFileId++;\r\n            path = `${MediaFiles.mediaDir}/media${this.nextFileId}.${extension}`;\r\n        } while (this.hashes[path]);\r\n\r\n        // add media to zip\r\n        await this.zip.setFile(path, mediaFile);\r\n\r\n        // add media to our lookups\r\n        this.hashes[path] = hash;\r\n        this.files.set(mediaFile, path);\r\n\r\n        // return\r\n        return path;\r\n    }\r\n\r\n    public async count(): Promise<number> {\r\n        await this.hashMediaFiles();\r\n        return Object.keys(this.hashes).length;\r\n    }\r\n\r\n    private async hashMediaFiles(): Promise<void> {\r\n        if (this.hashes)\r\n            return;\r\n\r\n        this.hashes = {};\r\n        for (const path of this.zip.listFiles()) {\r\n\r\n            if (!path.startsWith(MediaFiles.mediaDir))\r\n                continue;\r\n\r\n            const filename = Path.getFilename(path);\r\n            if (!filename)\r\n                continue;\r\n\r\n            const fileData = await this.zip.getFile(path).getContentBase64();\r\n            const fileHash = sha1(fileData);\r\n            this.hashes[filename] = fileHash;\r\n        }\r\n    }\r\n}","import { Path } from '../utils';\r\nimport { XmlGeneralNode, XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * Handles the relationship logic of a single docx \"part\".  \r\n * http://officeopenxml.com/anatomyofOOXML.php\r\n */\r\nexport class Rels {\r\n\r\n    private root: XmlNode;\r\n    private relIds: IMap<boolean>;\r\n    private relTargets: IMap<string>;\r\n    private nextRelId = 0;\r\n\r\n    private readonly partDir: string;\r\n    private readonly relsFilePath: string;\r\n\r\n    constructor(\r\n        partPath: string,\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n\r\n        this.partDir = Path.getDirectory(partPath);\r\n        const partFilename = Path.getFilename(partPath);\r\n        this.relsFilePath = `${this.partDir}/_rels/${partFilename}.rels`;\r\n    }\r\n\r\n    /**\r\n     * Returns the rel ID.\r\n     */\r\n    public async add(relTarget: string, relType: string, additionalAttributes?: IMap<string>): Promise<string> {\r\n\r\n        // if relTarget is an internal file it should be relative to the part dir\r\n        if (relTarget.startsWith(this.partDir)) {\r\n            relTarget = relTarget.substr(this.partDir.length + 1);\r\n        }\r\n\r\n        // parse rels file\r\n        await this.parseRelsFile();\r\n\r\n        // already exists?\r\n        const relTargetKey = this.getRelTargetKey(relType, relTarget);\r\n        let relId = this.relTargets[relTargetKey];\r\n        if (relId)\r\n            return relId;\r\n\r\n        // add rel node\r\n        relId = this.getNextRelId();\r\n        const relNode = XmlNode.createGeneralNode('Relationship');\r\n        relNode.attributes = Object.assign({\r\n            \"Id\": relId,\r\n            \"Type\": relType,\r\n            \"Target\": relTarget\r\n        }, additionalAttributes);\r\n        this.root.childNodes.push(relNode);\r\n\r\n        // update lookups\r\n        this.relIds[relId] = true;\r\n        this.relTargets[relTargetKey] = relId;\r\n\r\n        // return\r\n        return relId;\r\n    }\r\n\r\n    /**\r\n     * Save the rels file back to the zip.  \r\n     * Called automatically by the holding `Docx` before exporting.\r\n     */\r\n    public async save(): Promise<void> {\r\n\r\n        // not change - no need to save\r\n        if (!this.root)\r\n            return;\r\n\r\n        const xmlContent = this.xmlParser.serialize(this.root);\r\n        this.zip.setFile(this.relsFilePath, xmlContent);\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private getNextRelId(): string {\r\n\r\n        let relId: string;;\r\n        do {\r\n            this.nextRelId++;\r\n            relId = 'rId' + this.nextRelId;\r\n        } while (this.relIds[relId]);\r\n\r\n        return relId;\r\n    }\r\n\r\n    private async parseRelsFile(): Promise<void> {\r\n        if (this.root)\r\n            return;\r\n\r\n        // parse the xml file\r\n        let relsXml: string;\r\n        const relsFile = this.zip.getFile(this.relsFilePath);\r\n        if (relsFile) {\r\n            relsXml = await relsFile.getContentText();\r\n        } else {\r\n            relsXml = `<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\r\n                      </Relationships>`;\r\n        }\r\n        this.root = this.xmlParser.parse(relsXml);\r\n\r\n        // build lookups\r\n        this.relIds = {};\r\n        this.relTargets = {};\r\n        for (const rel of this.root.childNodes) {\r\n\r\n            const attributes = (rel as XmlGeneralNode).attributes;\r\n            if (!attributes)\r\n                continue;\r\n\r\n            // relIds lookup\r\n            const idAttr = attributes['Id'];\r\n            if (!idAttr)\r\n                continue;\r\n            this.relIds[idAttr] = true;\r\n\r\n            // rel target lookup\r\n            const typeAttr = attributes['Type'];\r\n            const targetAttr = attributes['Target'];\r\n            if (typeAttr && targetAttr) {\r\n                const relTargetKey = this.getRelTargetKey(typeAttr, targetAttr);\r\n                this.relTargets[relTargetKey] = idAttr;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getRelTargetKey(type: string, target: string): string {\r\n        return `${type} - ${target}`;\r\n    }\r\n}","import { XmlGeneralNode, XmlNode, XmlParser, XmlTextNode } from '../xml';\r\nimport { Zip } from '../zip';\r\nimport { Docx } from './docx';\r\n\r\nexport class DocxParser {\r\n\r\n    /*\r\n     * Word markup intro:\r\n     * \r\n     * In Word text nodes are contained in \"run\" nodes (which specifies text\r\n     * properties such as font and color). The \"run\" nodes in turn are\r\n     * contained in paragraph nodes which is the core unit of content.\r\n     * \r\n     * Example:\r\n     *\r\n     * <w:p>    <-- paragraph\r\n     *   <w:r>      <-- run\r\n     *     <w:rPr>      <-- run properties\r\n     *       <w:b/>     <-- bold\r\n     *     </w:rPr>\r\n     *     <w:t>This is text.</w:t>     <-- actual text\r\n     *   </w:r>\r\n     * </w:p> \r\n     *\r\n     * see: http://officeopenxml.com/WPcontentOverview.php\r\n     */\r\n\r\n    public static readonly PARAGRAPH_NODE = 'w:p';\r\n    public static readonly PARAGRAPH_PROPERTIES_NODE = 'w:pPr';\r\n    public static readonly RUN_NODE = 'w:r';\r\n    public static readonly RUN_PROPERTIES_NODE = 'w:rPr';\r\n    public static readonly TEXT_NODE = 'w:t';\r\n    public static readonly TABLE_ROW_NODE = 'w:tr';\r\n    public static readonly TABLE_CELL_NODE = 'w:tc';\r\n    public static readonly NUMBER_PROPERTIES_NODE = 'w:numPr';\r\n\r\n    //\r\n    // constructor\r\n    //\r\n\r\n    constructor(\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n    }\r\n\r\n    //\r\n    // parse document\r\n    //\r\n\r\n    public load(zip: Zip): Docx {\r\n        return new Docx(zip, this.xmlParser);\r\n    }\r\n\r\n    //\r\n    // content manipulation\r\n    //\r\n\r\n    /**\r\n     * Split the text node into two text nodes, each with it's own wrapping <w:t> node.\r\n     * Returns the newly created text node.\r\n     * \r\n     * @param textNode \r\n     * @param splitIndex \r\n     * @param addBefore Should the new node be added before or after the original node.\r\n     */\r\n    public splitTextNode(textNode: XmlTextNode, splitIndex: number, addBefore: boolean): XmlTextNode {\r\n\r\n        let firstXmlTextNode: XmlTextNode;\r\n        let secondXmlTextNode: XmlTextNode;\r\n\r\n        // split nodes\r\n        const wordTextNode = this.containingTextNode(textNode);\r\n        const newWordTextNode = XmlNode.cloneNode(wordTextNode, true);\r\n\r\n        // set space preserve to prevent display differences after splitting\r\n        // (otherwise if there was a space in the middle of the text node and it\r\n        // is now at the beginning or end of the text node it will be ignored)\r\n        this.setSpacePreserveAttribute(wordTextNode);\r\n        this.setSpacePreserveAttribute(newWordTextNode);\r\n\r\n        if (addBefore) {\r\n\r\n            // insert new node before existing one\r\n            XmlNode.insertBefore(newWordTextNode, wordTextNode);\r\n\r\n            firstXmlTextNode = XmlNode.lastTextChild(newWordTextNode);\r\n            secondXmlTextNode = textNode;\r\n\r\n        } else {\r\n\r\n            // insert new node after existing one\r\n            const curIndex = wordTextNode.parentNode.childNodes.indexOf(wordTextNode);\r\n            XmlNode.insertChild(wordTextNode.parentNode, newWordTextNode, curIndex + 1);\r\n\r\n            firstXmlTextNode = textNode;\r\n            secondXmlTextNode = XmlNode.lastTextChild(newWordTextNode);\r\n        }\r\n\r\n        // edit text\r\n        const firstText = firstXmlTextNode.textContent;\r\n        const secondText = secondXmlTextNode.textContent;\r\n        firstXmlTextNode.textContent = firstText.substring(0, splitIndex);\r\n        secondXmlTextNode.textContent = secondText.substring(splitIndex);\r\n\r\n        return (addBefore ? firstXmlTextNode : secondXmlTextNode);\r\n    }\r\n\r\n    /**\r\n     * Move all text between the 'from' and 'to' nodes to the 'from' node.\r\n     */\r\n    public joinTextNodesRange(from: XmlTextNode, to: XmlTextNode): void {\r\n\r\n        // find run nodes\r\n        const firstRunNode = this.containingRunNode(from);\r\n        const secondRunNode = this.containingRunNode(to);\r\n\r\n        const paragraphNode = firstRunNode.parentNode;\r\n        if (secondRunNode.parentNode !== paragraphNode)\r\n            throw new Error('Can not join text nodes from separate paragraphs.');\r\n\r\n        // find \"word text nodes\"\r\n        const firstWordTextNode = this.containingTextNode(from);\r\n        const secondWordTextNode = this.containingTextNode(to);\r\n        const totalText: string[] = [];\r\n\r\n        // iterate runs\r\n        let curRunNode = firstRunNode;\r\n        while (curRunNode) {\r\n\r\n            // iterate text nodes\r\n            let curWordTextNode: XmlNode;\r\n            if (curRunNode === firstRunNode) {\r\n                curWordTextNode = firstWordTextNode;\r\n            } else {\r\n                curWordTextNode = this.firstTextNodeChild(curRunNode);\r\n            }\r\n            while (curWordTextNode) {\r\n\r\n                if (curWordTextNode.nodeName !== DocxParser.TEXT_NODE)\r\n                    continue;\r\n\r\n                // move text to first node\r\n                const curXmlTextNode = XmlNode.lastTextChild(curWordTextNode);\r\n                totalText.push(curXmlTextNode.textContent);\r\n\r\n                // next text node\r\n                const textToRemove = curWordTextNode;\r\n                if (curWordTextNode === secondWordTextNode) {\r\n                    curWordTextNode = null;\r\n                } else {\r\n                    curWordTextNode = curWordTextNode.nextSibling;\r\n                }\r\n\r\n                // remove current text node\r\n                if (textToRemove !== firstWordTextNode) {\r\n                    XmlNode.remove(textToRemove);\r\n                }\r\n            }\r\n\r\n            // next run\r\n            const runToRemove = curRunNode;\r\n            if (curRunNode === secondRunNode) {\r\n                curRunNode = null;\r\n            } else {\r\n                curRunNode = curRunNode.nextSibling;\r\n            }\r\n\r\n            // remove current run\r\n            if (!runToRemove.childNodes || !runToRemove.childNodes.length) {\r\n                XmlNode.remove(runToRemove);\r\n            }\r\n        }\r\n\r\n        // set the text content\r\n        const firstXmlTextNode = XmlNode.lastTextChild(firstWordTextNode);\r\n        firstXmlTextNode.textContent = totalText.join('');\r\n    }\r\n\r\n    /**\r\n     * Take all runs from 'second' and move them to 'first'.\r\n     */\r\n    public joinParagraphs(first: XmlNode, second: XmlNode): void {\r\n        if (first === second)\r\n            return;\r\n\r\n        let childIndex = 0;\r\n        while (second.childNodes && childIndex < second.childNodes.length) {\r\n            const curChild = second.childNodes[childIndex];\r\n            if (curChild.nodeName === DocxParser.RUN_NODE) {\r\n                XmlNode.removeChild(second, childIndex);\r\n                XmlNode.appendChild(first, curChild);\r\n            } else {\r\n                childIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setSpacePreserveAttribute(node: XmlGeneralNode): void {\r\n        if (!node.attributes) {\r\n            node.attributes = {};\r\n        }\r\n        if (!node.attributes['xml:space']) {\r\n            node.attributes['xml:space'] = 'preserve';\r\n        }\r\n    }\r\n\r\n    //\r\n    // node queries\r\n    //\r\n\r\n    public isTextNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.TEXT_NODE;\r\n    }\r\n\r\n    public isTableCellNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.TABLE_CELL_NODE;\r\n    }\r\n\r\n    public isParagraphNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.PARAGRAPH_NODE;\r\n    }\r\n\r\n    public isListParagraph(paragraphNode: XmlNode): boolean {\r\n        const paragraphProperties = this.paragraphPropertiesNode(paragraphNode);\r\n        const listNumberProperties = XmlNode.findChildByName(paragraphProperties, DocxParser.NUMBER_PROPERTIES_NODE);\r\n        return !!listNumberProperties;\r\n    }\r\n\r\n    public paragraphPropertiesNode(paragraphNode: XmlNode): XmlNode {\r\n        if (!this.isParagraphNode(paragraphNode))\r\n            throw new Error(`Expected paragraph node but received a '${paragraphNode.nodeName}' node.`);\r\n\r\n        return XmlNode.findChildByName(paragraphNode, DocxParser.PARAGRAPH_PROPERTIES_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search for the first direct child **Word** text node (i.e. a <w:t> node).\r\n     */\r\n    public firstTextNodeChild(node: XmlNode): XmlNode {\r\n\r\n        if (!node)\r\n            return null;\r\n\r\n        if (node.nodeName !== DocxParser.RUN_NODE)\r\n            return null;\r\n\r\n        if (!node.childNodes)\r\n            return null;\r\n\r\n        for (const child of node.childNodes) {\r\n            if (child.nodeName === DocxParser.TEXT_NODE)\r\n                return child;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first **Word** text node (i.e. a <w:t> node).\r\n     */\r\n    public containingTextNode(node: XmlTextNode): XmlGeneralNode {\r\n\r\n        if (!node)\r\n            return null;\r\n\r\n        if (!XmlNode.isTextNode(node))\r\n            throw new Error(`'Invalid argument ${nameof(node)}. Expected a XmlTextNode.`);\r\n\r\n        return XmlNode.findParentByName(node, DocxParser.TEXT_NODE) as XmlGeneralNode;\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first run node.\r\n     */\r\n    public containingRunNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.RUN_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first paragraph node.\r\n     */\r\n    public containingParagraphNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.PARAGRAPH_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first \"table row\" node.\r\n     */\r\n    public containingTableRowNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.TABLE_ROW_NODE);\r\n    }\r\n}","export * from './iLoopStrategy';\r\nexport * from './loopListStrategy';\r\nexport * from './loopParagraphStrategy';\r\nexport * from './loopTableStrategy';\r\n","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopListStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        const containingParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        return this.utilities.docxParser.isListParagraph(containingParagraph);\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        const firstParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        const lastParagraph = this.utilities.docxParser.containingParagraphNode(closeTag.xmlTextNode);\r\n        const paragraphsToRepeat = XmlNode.siblingsInRange(firstParagraph, lastParagraph);\r\n\r\n        // remove the loop tags\r\n        XmlNode.remove(openTag.xmlTextNode);\r\n        XmlNode.remove(closeTag.xmlTextNode);\r\n\r\n        return {\r\n            firstNode: firstParagraph,\r\n            nodesToRepeat: paragraphsToRepeat,\r\n            lastNode: lastParagraph\r\n        };\r\n    }\r\n\r\n    public mergeBack(paragraphGroups: XmlNode[][], firstParagraph: XmlNode, lastParagraphs: XmlNode): void {\r\n\r\n        for (const curParagraphsGroup of paragraphGroups) {\r\n            for (const paragraph of curParagraphsGroup) {\r\n                XmlNode.insertBefore(paragraph, lastParagraphs);\r\n            }\r\n        }\r\n\r\n        // remove the old paragraphs\r\n        XmlNode.remove(firstParagraph);\r\n        if (firstParagraph !== lastParagraphs) {\r\n            XmlNode.remove(lastParagraphs);\r\n        }\r\n    }\r\n}","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopParagraphStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        return true;\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        // gather some info\r\n        let firstParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        let lastParagraph = this.utilities.docxParser.containingParagraphNode(closeTag.xmlTextNode);\r\n        const areSame = (firstParagraph === lastParagraph);\r\n        const parent = firstParagraph.parentNode;\r\n        const firstParagraphIndex = parent.childNodes.indexOf(firstParagraph);\r\n        const lastParagraphIndex = areSame ? firstParagraphIndex : parent.childNodes.indexOf(lastParagraph);\r\n\r\n        // split first paragraphs\r\n        let splitResult = XmlNode.splitByChild(firstParagraph, openTag.xmlTextNode, true);\r\n        firstParagraph = splitResult[0];\r\n        const firstParagraphSplit = splitResult[1];\r\n        if (areSame)\r\n            lastParagraph = firstParagraphSplit;\r\n\r\n        // split last paragraph\r\n        splitResult = XmlNode.splitByChild(lastParagraph, closeTag.xmlTextNode, true);\r\n        const lastParagraphSplit = splitResult[0];\r\n        lastParagraph = splitResult[1];\r\n\r\n        // fix references\r\n        XmlNode.removeChild(parent, firstParagraphIndex + 1);\r\n        if (!areSame)\r\n            XmlNode.removeChild(parent, lastParagraphIndex);\r\n        firstParagraphSplit.parentNode = null;\r\n        lastParagraphSplit.parentNode = null;\r\n\r\n        // extract all paragraphs in between\r\n        let middleParagraphs: XmlNode[];\r\n        if (areSame) {\r\n            this.utilities.docxParser.joinParagraphs(firstParagraphSplit, lastParagraphSplit);\r\n            middleParagraphs = [firstParagraphSplit];\r\n        } else {\r\n            const inBetween = XmlNode.removeSiblings(firstParagraph, lastParagraph);\r\n            middleParagraphs = [firstParagraphSplit].concat(inBetween).concat(lastParagraphSplit);\r\n        }\r\n\r\n        return {\r\n            firstNode: firstParagraph,\r\n            nodesToRepeat: middleParagraphs,\r\n            lastNode: lastParagraph\r\n        };\r\n    }\r\n\r\n    public mergeBack(middleParagraphs: XmlNode[][], firstParagraph: XmlNode, lastParagraph: XmlNode): void {\r\n\r\n        let mergeTo = firstParagraph;\r\n        for (const curParagraphsGroup of middleParagraphs) {\r\n\r\n            // merge first paragraphs\r\n            this.utilities.docxParser.joinParagraphs(mergeTo, curParagraphsGroup[0]);\r\n\r\n            // add middle and last paragraphs to the original document\r\n            for (let i = 1; i < curParagraphsGroup.length; i++) {\r\n                XmlNode.insertBefore(curParagraphsGroup[i], lastParagraph);\r\n                mergeTo = curParagraphsGroup[i];\r\n            }\r\n        }\r\n\r\n        // merge last paragraph\r\n        this.utilities.docxParser.joinParagraphs(mergeTo, lastParagraph);\r\n\r\n        // remove the old last paragraph (was merged into the new one)\r\n        XmlNode.remove(lastParagraph);\r\n    }\r\n}\r\n","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopTableStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        const containingParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        if (!containingParagraph.parentNode)\r\n            return false;\r\n        return this.utilities.docxParser.isTableCellNode(containingParagraph.parentNode);\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        const firstRow = this.utilities.docxParser.containingTableRowNode(openTag.xmlTextNode);\r\n        const lastRow = this.utilities.docxParser.containingTableRowNode(closeTag.xmlTextNode);\r\n        const rowsToRepeat = XmlNode.siblingsInRange(firstRow, lastRow);\r\n\r\n        // remove the loop tags\r\n        XmlNode.remove(openTag.xmlTextNode);\r\n        XmlNode.remove(closeTag.xmlTextNode);\r\n\r\n        return {\r\n            firstNode: firstRow,\r\n            nodesToRepeat: rowsToRepeat,\r\n            lastNode: lastRow\r\n        };\r\n    }\r\n\r\n    public mergeBack(rowGroups: XmlNode[][], firstRow: XmlNode, lastRow: XmlNode): void {\r\n\r\n        for (const curRowsGroup of rowGroups) {\r\n            for (const row of curRowsGroup) {\r\n                XmlNode.insertBefore(row, lastRow);\r\n            }\r\n        }\r\n\r\n        // remove the old rows\r\n        XmlNode.remove(firstRow);\r\n        if (firstRow !== lastRow) {\r\n            XmlNode.remove(lastRow);\r\n        }\r\n    }\r\n}","\r\nexport interface PluginContent {\r\n    _type: string;\r\n}\r\n\r\nexport const PluginContent = {\r\n    isPluginContent(content: any): content is PluginContent {\r\n        return !!content && typeof content._type === 'string';\r\n    }\r\n};","import * as JSZip from 'jszip';\r\nimport { Binary } from '../utils';\r\nimport { JsZipHelper } from './jsZipHelper';\r\nimport { ZipObject } from './zipObject';\r\n\r\nexport class Zip {\r\n\r\n    public static async load(file: Binary): Promise<Zip> {\r\n        const zip = await JSZip.loadAsync(file);\r\n        return new Zip(zip);\r\n    }\r\n\r\n    private constructor(private readonly zip: JSZip) {\r\n    }\r\n\r\n    public getFile(path: string): ZipObject {\r\n        return new ZipObject(this.zip.files[path]);\r\n    }\r\n\r\n    public setFile(path: string, content: string | Binary): void {\r\n        this.zip.file(path, content);\r\n    }\r\n\r\n    public isFileExist(path: string): boolean {\r\n        return !!this.zip.files[path];\r\n    }\r\n\r\n    public listFiles(): string[] {\r\n        return Object.keys(this.zip.files);\r\n    }\r\n\r\n    public async export<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        const zipOutputType: JSZip.OutputType = JsZipHelper.toJsZipOutputType(outputType);\r\n        const output = await this.zip.generateAsync({\r\n            type: zipOutputType,\r\n            compression: \"DEFLATE\",\r\n            compressionOptions: {\r\n                level: 6 // between 1 (best speed) and 9 (best compression)\r\n            }\r\n        });\r\n        return output as T;\r\n    }\r\n}","module.exports = require(\"jszip\");","import { DelimiterSearcher, ScopeData, Tag, TagParser, TemplateCompiler, TemplateContext } from './compilation';\r\nimport { Delimiters } from './delimiters';\r\nimport { MalformedFileError } from './errors';\r\nimport { Docx, DocxParser } from './office';\r\nimport { TemplateHandlerOptions } from './templateHandlerOptions';\r\nimport { Binary } from './utils';\r\nimport { XmlNode, XmlParser } from './xml';\r\nimport { Zip } from './zip';\r\n\r\nexport class TemplateHandler {\r\n\r\n    /**\r\n     * Version number of the `easy-template-x` library.\r\n     */\r\n    public readonly version = (typeof EASY_VERSION !== 'undefined' ? EASY_VERSION : 'null');\r\n\r\n    private readonly xmlParser = new XmlParser();\r\n    private readonly docxParser: DocxParser;\r\n    private readonly compiler: TemplateCompiler;\r\n\r\n    private readonly options: TemplateHandlerOptions;\r\n\r\n    constructor(options?: TemplateHandlerOptions) {\r\n        this.options = new TemplateHandlerOptions(options);\r\n\r\n        //\r\n        // this is the library's composition root\r\n        //\r\n\r\n        this.docxParser = new DocxParser(this.xmlParser);\r\n\r\n        const delimiterSearcher = new DelimiterSearcher(this.docxParser);\r\n        delimiterSearcher.startDelimiter = this.options.delimiters.tagStart;\r\n        delimiterSearcher.endDelimiter = this.options.delimiters.tagEnd;\r\n        delimiterSearcher.maxXmlDepth = this.options.maxXmlDepth;\r\n\r\n        const tagParser = new TagParser(this.docxParser, this.options.delimiters as Delimiters);\r\n\r\n        this.compiler = new TemplateCompiler(\r\n            delimiterSearcher,\r\n            tagParser,\r\n            this.options.plugins,\r\n            this.options.defaultContentType,\r\n            this.options.containerContentType\r\n        );\r\n\r\n        this.options.plugins.forEach(plugin => {\r\n            plugin.setUtilities({\r\n                xmlParser: this.xmlParser,\r\n                docxParser: this.docxParser,\r\n                compiler: this.compiler\r\n            });\r\n        });\r\n    }\r\n\r\n    public async process<T extends Binary>(templateFile: T, data: any): Promise<T> {\r\n\r\n        // load the docx file\r\n        const docx = await this.loadDocx(templateFile);\r\n        const document = await docx.getDocument();\r\n\r\n        // process content (do replacements)        \r\n        const scopeData = new ScopeData(data);\r\n        const context: TemplateContext = {\r\n            docx\r\n        };\r\n        await this.compiler.compile(document, scopeData, context);\r\n\r\n        // export the result\r\n        return docx.export(templateFile.constructor as Constructor<T>);\r\n    }\r\n\r\n    public async parseTags(templateFile: Binary): Promise<Tag[]> {\r\n        const docx = await this.loadDocx(templateFile);\r\n        const document = await docx.getDocument();\r\n        return this.compiler.parseTags(document);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of the main document file.\r\n     */\r\n    public async getText(docxFile: Binary): Promise<string> {\r\n        const docx = await this.loadDocx(docxFile);\r\n        const text = await docx.getDocumentText();\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Get the xml tree of the main document file.\r\n     */\r\n    public async getXml(docxFile: Binary): Promise<XmlNode> {\r\n        const docx = await this.loadDocx(docxFile);\r\n        const document = await docx.getDocument();\r\n        return document;\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private async loadDocx(file: Binary): Promise<Docx> {\r\n\r\n        // load the zip file\r\n        let zip: Zip;\r\n        try {\r\n            zip = await Zip.load(file);\r\n        } catch {\r\n            throw new MalformedFileError('docx');\r\n        }\r\n\r\n        // load the docx file\r\n        const docx = this.docxParser.load(zip);\r\n        return docx;\r\n    }\r\n}"],"sourceRoot":""}