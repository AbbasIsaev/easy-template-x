{"version":3,"sources":["webpack/universalModuleDefinition","webpack/bootstrap","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\delimiterSearcher.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\scopeData.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\tag.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\tagParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\compilation\\templateCompiler.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\delimiters.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\malformedFileError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\maxXmlDepthError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingArgumentError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingCloseDelimiterError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\missingStartDelimiterError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unclosedTagError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unidentifiedFileTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unknownContentTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unopenedTagError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\errors\\unsupportedFileTypeError.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\mimeType.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\contentTypesFile.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\docx.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\docxParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\mediaFiles.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\office\\rels.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\defaultPlugins.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\imagePlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\linkPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopListStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopParagraphStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loop\\loopTableStrategy.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\loopPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\pluginContent.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\rawXmlPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\templatePlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\plugins\\textPlugin.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\templateHandler.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\templateHandlerOptions.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\array.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\base64.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\binary.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\path.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\sha1.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\utils\\types.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlDepthTracker.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlNode.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\xml\\xmlParser.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\index.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\jsZipHelper.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\zip.ts","C:\\Users\\Alon\\Documents\\devel\\easy-template-x\\src\\zip\\zipObject.ts","external \"jszip\"","external \"lodash.get\"","external \"xmldom\""],"names":["MatchState","reset","delimiterIndex","openNodes","firstMatchIndex","DelimiterSearcher","constructor","docxParser","MissingArgumentError","findDelimiters","node","delimiters","match","depth","XmlDepthTracker","maxXmlDepth","lookForOpenDelimiter","isParagraphNode","shouldSearchNode","findNextNode","push","textIndex","textContent","length","delimiterPattern","startDelimiter","endDelimiter","char","firstNode","lastNode","joinTextNodesRange","delimiterMark","createDelimiterMark","XmlNode","isTextNode","parentNode","childNodes","increment","nextSibling","decrement","isOpenDelimiter","index","isOpen","xmlTextNode","getProp","require","ScopeData","data","allData","getScopeData","lastKey","path","result","curPath","slice","undefined","curScopePath","concat","TagDisposition","TagParser","docParser","tagRegex","RegExp","tagStart","tagEnd","parse","tags","openedTag","openedDelimiter","i","delimiter","closeTagText","MissingStartDelimiterError","openTagText","MissingCloseDelimiterError","normalizeTagNodes","processTag","openDelimiter","closeDelimiter","closeDelimiterIndex","allDelimiters","startTextNode","endTextNode","sameNode","splitTextNode","updated","curDelimiter","tag","rawText","tagParts","exec","tagContent","trim","disposition","SelfClosed","startsWith","containerTagOpen","Open","name","containerTagClose","Close","TemplateCompiler","delimiterSearcher","tagParser","plugins","defaultContentType","containerContentType","pluginsLookup","p","contentType","compile","context","parseTags","doTagReplacements","tagIndex","detectContentType","plugin","UnknownContentTypeError","join","job","simpleTagReplacements","closingTagIndex","findCloseTagIndex","scopeTags","containerTagReplacements","pop","scopeData","PluginContent","isPluginContent","_type","fromIndex","openTag","closeTag","UnclosedTagError","Delimiters","initial","Object","assign","encodeAndValidate","Error","keys","key","value","MalformedFileError","expectedFileType","setPrototypeOf","prototype","MaxXmlDepthError","maxDepth","argName","openDelimiterText","closeDelimiterText","tagName","UnidentifiedFileTypeError","tagRawText","UnopenedTagError","UnsupportedFileTypeError","fileType","MimeType","MimeTypeHelper","getDefaultExtension","mime","Png","Jpeg","Gif","Bmp","Svg","getOfficeRelType","ContentTypesFile","zip","xmlParser","ensureContentType","parseContentTypesFile","contentTypes","extension","typeNode","createGeneralNode","attributes","root","addedNew","count","filter","save","xmlContent","serialize","setFile","contentTypesFilePath","contentTypesXml","getFile","getContentText","nodeName","genNode","contentTypeAttribute","Docx","documentPath","_documentPath","isFileExist","rels","Rels","mediaFiles","MediaFiles","getDocument","_document","xml","getDocumentText","xmlDocument","domDocument","domParse","documentElement","export","outputType","saveChanges","document","DocxParser","load","textNode","splitIndex","addBefore","firstXmlTextNode","secondXmlTextNode","wordTextNode","containingTextNode","newWordTextNode","cloneNode","setSpacePreserveAttribute","insertBefore","lastTextChild","curIndex","indexOf","insertChild","firstText","secondText","substring","from","to","firstRunNode","containingRunNode","secondRunNode","paragraphNode","firstWordTextNode","secondWordTextNode","totalText","curRunNode","curWordTextNode","firstTextNodeChild","TEXT_NODE","curXmlTextNode","textToRemove","remove","runToRemove","joinParagraphs","first","second","childIndex","curChild","RUN_NODE","removeChild","appendChild","isTableCellNode","TABLE_CELL_NODE","PARAGRAPH_NODE","isListParagraph","paragraphProperties","paragraphPropertiesNode","listNumberProperties","findChildByName","NUMBER_PROPERTIES_NODE","PARAGRAPH_PROPERTIES_NODE","child","findParentByName","containingParagraphNode","containingTableRowNode","TABLE_ROW_NODE","Map","add","mediaFile","files","has","get","hashMediaFiles","base64","Binary","toBase64","hash","hashes","find","nextFileId","mediaDir","set","listFiles","filename","Path","getFilename","fileData","getContentBase64","fileHash","partPath","partDir","getDirectory","partFilename","relsFilePath","relTarget","relType","additionalAttributes","substr","parseRelsFile","relTargetKey","getRelTargetKey","relId","relTargets","getNextRelId","relNode","relIds","nextRelId","relsXml","relsFile","rel","idAttr","typeAttr","targetAttr","type","target","createDefaultPlugins","LoopPlugin","RawXmlPlugin","ImagePlugin","LinkPlugin","TextPlugin","nextImageId","TemplatePlugin","utilities","content","source","mediaFilePath","docx","format","imageId","imageXml","createMarkup","width","height","insertAfter","markupText","pixelsToEmu","pictureMarkup","markupXml","removeEmptyTextNodes","pixels","Math","round","linkAttributes","TargetMode","linkRelType","wordRunNode","linkMarkup","generateMarkup","insertHyperlinkNode","text","runProps","RUN_PROPERTIES_NODE","linkRunProps","unshift","tagRunNode","tagTextNode","textNodesInRun","runBeforeTag","splitByChild","LoopListStrategy","setUtilities","isApplicable","containingParagraph","splitBefore","firstParagraph","lastParagraph","paragraphsToRepeat","siblingsInRange","nodesToRepeat","mergeBack","paragraphGroups","lastParagraphs","curParagraphsGroup","paragraph","LoopParagraphStrategy","areSame","parent","firstParagraphIndex","lastParagraphIndex","splitResult","firstParagraphSplit","lastParagraphSplit","middleParagraphs","inBetween","removeSiblings","mergeTo","LoopTableStrategy","firstRow","lastRow","rowsToRepeat","rowGroups","curRowsGroup","row","LOOP_CONTENT_TYPE","loopStrategies","forEach","strategy","Array","isArray","loopStrategy","repeatedNodes","repeat","compiledNodes","nodes","times","allResults","curResult","map","nodeGroups","compiledNodeGroups","curNodes","dummyRootNode","compiler","newNode","TEXT_CONTENT_TYPE","stringValue","toString","lines","split","replaceSingleLine","replaceMultiLine","runNode","lineBreak","getLineBreak","lineNode","createWordTextNode","createTextNode","TemplateHandler","options","EASY_VERSION","XmlParser","TemplateHandlerOptions","process","templateFile","loadDocx","getText","docxFile","getXml","file","Zip","pushMany","destArray","items","apply","array","last","toDictionary","keySelector","valueSelector","res","item","Base64","encode","str","btoa","Buffer","isBlob","binary","isBlobConstructor","isArrayBuffer","isArrayBufferConstructor","isBuffer","isBufferConstructor","binaryType","Blob","ArrayBuffer","Promise","resolve","fileReader","FileReader","onload","readAsBinaryString","binaryStr","Uint8Array","reduce","byte","String","fromCharCode","lastSlashIndex","lastIndexOf","sha1","msg","utf8Encode","msgLength","j","wordArray","charCodeAt","w","H0","H1","H2","H3","H4","A","B","C","D","E","temp","blockStart","rotateLeft","cvtHex","toLowerCase","n","s","t4","val","v","replace","utfStr","c","inheritsFrom","derived","base","isPromiseLike","candidate","then","XmlNodeType","TEXT_NODE_NAME","nodeType","Text","General","encodeValue","TypeError","attributeNames","hasChildren","suffix","childrenXml","fromDomNode","domNode","xmlNode","ELEMENT_NODE","curAttribute","prevChild","domChild","deep","clone","cloneNodeDeep","referenceNode","beforeNodeIndex","referenceNodeIndex","RangeError","childAfter","childBefore","splice","currentLastChild","allTextNodes","lastTextNode","newTextNode","removed","lastRemoved","removeMe","markerNode","removeMarkerNode","getDescendantPath","findParent","predicate","childName","range","curNode","recursiveRemoveEmptyTextNodes","childOrIndex","beforeChild","original","prevChildClone","childClone","descendant","curChildIndex","reverse","oldChildren","strippedChild","doc","parser","parseFromString","xmlHeader","xmldom","DOMParser","JsZipHelper","toJsZipOutputType","binaryOrType","JSZip","loadAsync","ZipObject","zipOutputType","output","generateAsync","compression","compressionOptions","level","zipObject","isDirectory","dir","async","getContentBinary"],"mappings":"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","file":"easy-template-x.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"easy-template-x\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"easy-template-x\"] = factory();\n\telse\n\t\troot[\"easy-template-x\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","import { MissingArgumentError } from '../errors';\r\nimport { DocxParser } from '../office';\r\nimport { first, last } from '../utils';\r\nimport { XmlDepthTracker, XmlNode, XmlTextNode } from '../xml';\r\nimport { DelimiterMark } from './delimiterMark';\r\n\r\nclass MatchState {\r\n\r\n    public delimiterIndex = 0;\r\n    public openNodes: XmlTextNode[] = [];\r\n    public firstMatchIndex = -1;\r\n\r\n    public reset() {\r\n        this.delimiterIndex = 0;\r\n        this.openNodes = [];\r\n        this.firstMatchIndex = -1;\r\n    }\r\n}\r\n\r\nexport class DelimiterSearcher {\r\n\r\n    public maxXmlDepth = 20;\r\n    public startDelimiter = \"{\";\r\n    public endDelimiter = \"}\";\r\n\r\n    constructor(private readonly docxParser: DocxParser) {\r\n        if (!docxParser)\r\n            throw new MissingArgumentError(nameof(docxParser));\r\n    }\r\n\r\n    public findDelimiters(node: XmlNode): DelimiterMark[] {\r\n\r\n        //\r\n        // Performance note: \r\n        //\r\n        // The search efficiency is o(m*n) where n is the text size and m is the\r\n        // delimiter length. We could use a variation of the KMP algorithm here\r\n        // to reduce it to o(m+n) but since our m is expected to be small\r\n        // (delimiters defaults to 2 characters and even on custom inputs are\r\n        // not expected to be much longer) it does not worth the extra\r\n        // complexity and effort.\r\n        //\r\n\r\n        const delimiters: DelimiterMark[] = [];\r\n        const match = new MatchState();\r\n        const depth = new XmlDepthTracker(this.maxXmlDepth);\r\n        let lookForOpenDelimiter = true;\r\n\r\n        while (node) {\r\n\r\n            // reset state on paragraph transition\r\n            if (this.docxParser.isParagraphNode(node)) {\r\n                match.reset();\r\n            }\r\n\r\n            // skip irrelevant nodes\r\n            if (!this.shouldSearchNode(node)) {\r\n                node = this.findNextNode(node, depth);\r\n                continue;\r\n            }\r\n\r\n            // search delimiters in text nodes\r\n            match.openNodes.push(node);\r\n            let textIndex = 0;\r\n            while (textIndex < node.textContent.length) {\r\n\r\n                const delimiterPattern = lookForOpenDelimiter ? this.startDelimiter : this.endDelimiter;\r\n\r\n                // char match\r\n                const char = node.textContent[textIndex];\r\n                if (char === delimiterPattern[match.delimiterIndex]) {\r\n\r\n                    // first match\r\n                    if (match.firstMatchIndex === -1) {\r\n                        match.firstMatchIndex = textIndex;\r\n                    }\r\n\r\n                    // full delimiter match\r\n                    if (match.delimiterIndex === delimiterPattern.length - 1) {\r\n\r\n                        // move all delimiters characters to the same text node\r\n                        if (match.openNodes.length > 1) {\r\n                            \r\n                            const firstNode = first(match.openNodes);\r\n                            const lastNode = last(match.openNodes);\r\n                            this.docxParser.joinTextNodesRange(firstNode, lastNode);\r\n                            \r\n                            textIndex += (firstNode.textContent.length - node.textContent.length);\r\n                            node = firstNode;\r\n                        }\r\n\r\n                        // store delimiter\r\n                        const delimiterMark = this.createDelimiterMark(match, lookForOpenDelimiter);\r\n                        delimiters.push(delimiterMark);\r\n\r\n                        // update state\r\n                        lookForOpenDelimiter = !lookForOpenDelimiter;\r\n                        match.reset();\r\n                        if (textIndex < node.textContent.length - 1) {\r\n                            match.openNodes.push(node);\r\n                        }\r\n\r\n                    } else {\r\n                        match.delimiterIndex++;\r\n                    }\r\n                }\r\n\r\n                // no match\r\n                else {\r\n\r\n                    //\r\n                    // go back to first open node\r\n                    //\r\n                    // Required for cases where the text has repeating\r\n                    // characters that are the same as a delimiter prefix.  \r\n                    // For instance:  \r\n                    // Delimiter is '{!' and template text contains the string '{{!'\r\n                    //\r\n                    if (match.firstMatchIndex !== -1) {\r\n                        node = first(match.openNodes);\r\n                        textIndex = match.firstMatchIndex;\r\n                    }\r\n\r\n                    // update state\r\n                    match.reset();\r\n                    if (textIndex < node.textContent.length - 1) {\r\n                        match.openNodes.push(node);\r\n                    }\r\n                }\r\n\r\n                textIndex++;\r\n            }\r\n\r\n            node = this.findNextNode(node, depth);\r\n        }\r\n\r\n        return delimiters;\r\n    }\r\n\r\n    private shouldSearchNode(node: XmlNode): node is XmlTextNode {\r\n\r\n        if (!XmlNode.isTextNode(node))\r\n            return false;\r\n        if (!node.textContent)\r\n            return false;\r\n        if (!node.parentNode)\r\n            return false;\r\n        if (!this.docxParser.isTextNode(node.parentNode))\r\n            return false;\r\n\r\n        return true;\r\n    }\r\n\r\n    private findNextNode(node: XmlNode, depth: XmlDepthTracker): XmlNode {\r\n\r\n        // children\r\n        if (node.childNodes && node.childNodes.length) {\r\n            depth.increment();\r\n            return node.childNodes[0];\r\n        }\r\n\r\n        // siblings\r\n        if (node.nextSibling)\r\n            return node.nextSibling;\r\n\r\n        // parent sibling\r\n        while (node.parentNode) {\r\n\r\n            if (node.parentNode.nextSibling) {\r\n                depth.decrement();\r\n                return node.parentNode.nextSibling;\r\n            }\r\n\r\n            // go up\r\n            depth.decrement();\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    private createDelimiterMark(match: MatchState, isOpenDelimiter: boolean): DelimiterMark {\r\n        return {\r\n            index: match.firstMatchIndex,\r\n            isOpen: isOpenDelimiter,\r\n            xmlTextNode: match.openNodes[0]\r\n        };\r\n    }\r\n}","export * from './delimiterMark';\r\nexport * from './delimiterSearcher';\r\nexport * from './scopeData';\r\nexport * from './tag';\r\nexport * from './tagParser';\r\nexport * from './templateCompiler';\r\nexport * from './templateContext';\r\n","import { TemplateContent, TemplateData } from '../templateData';\r\nimport { last } from '../utils';\r\n\r\nconst getProp = require('lodash.get');\r\n\r\nexport class ScopeData {\r\n    \r\n    public readonly path: (string | number)[] = [];\r\n    public readonly allData: TemplateData;\r\n\r\n    constructor(data: TemplateData) {\r\n        this.allData = data;\r\n    }\r\n\r\n    public getScopeData(): TemplateContent | TemplateData[] {\r\n\r\n        const lastKey = last(this.path);\r\n\r\n        let result: any;\r\n        let curPath = this.path.slice();\r\n\r\n        while (result === undefined && curPath.length) {\r\n            const curScopePath = curPath.slice(0, curPath.length - 1);\r\n            result = getProp(this.allData, curScopePath.concat(lastKey));\r\n            curPath = curScopePath;\r\n        }\r\n        return result;\r\n    }\r\n}","import { XmlTextNode } from '../xml';\r\n\r\nexport enum TagDisposition {\r\n    Open = \"Open\",\r\n    Close = \"Close\",\r\n    SelfClosed = \"SelfClosed\"\r\n}\r\n\r\nexport interface Tag {    \r\n    name: string;\r\n    /**\r\n     * The full tag text, for instance: \"{#my-tag}\".\r\n     */\r\n    rawText: string;\r\n    disposition: TagDisposition;\r\n    xmlTextNode: XmlTextNode;\r\n}","import { Delimiters } from '../delimiters';\r\nimport { MissingArgumentError, MissingCloseDelimiterError, MissingStartDelimiterError } from '../errors';\r\nimport { DocxParser } from '../office';\r\nimport { DelimiterMark } from './delimiterMark';\r\nimport { Tag, TagDisposition } from './tag';\r\n\r\nexport class TagParser {\r\n\r\n    private readonly tagRegex: RegExp;\r\n\r\n    constructor(\r\n        private readonly docParser: DocxParser,\r\n        private readonly delimiters: Delimiters\r\n    ) {\r\n        if (!docParser)\r\n            throw new MissingArgumentError(nameof(docParser));\r\n        if (!delimiters)\r\n            throw new MissingArgumentError(nameof(delimiters));\r\n\r\n        // TODO: regex escape\r\n        this.tagRegex = new RegExp(`^[${delimiters.tagStart}](.*?)[${delimiters.tagEnd}]`, 'mi');\r\n    }\r\n\r\n    public parse(delimiters: DelimiterMark[]): Tag[] {\r\n        const tags: Tag[] = [];\r\n\r\n        let openedTag: Partial<Tag>;\r\n        let openedDelimiter: DelimiterMark;\r\n        for (let i = 0; i < delimiters.length; i++) {\r\n            const delimiter = delimiters[i];\r\n\r\n            // close before open\r\n            if (!openedTag && !delimiter.isOpen) {\r\n                const closeTagText = delimiter.xmlTextNode.textContent;\r\n                throw new MissingStartDelimiterError(closeTagText);\r\n            }\r\n\r\n            // open before close\r\n            if (openedTag && delimiter.isOpen) {\r\n                const openTagText = openedDelimiter.xmlTextNode.textContent;\r\n                throw new MissingCloseDelimiterError(openTagText);\r\n            }\r\n\r\n            // valid open\r\n            if (!openedTag && delimiter.isOpen) {\r\n                openedTag = {};\r\n                openedDelimiter = delimiter;\r\n            }\r\n\r\n            // valid close\r\n            if (openedTag && !delimiter.isOpen) {\r\n\r\n                // normalize the underlying xml structure\r\n                // (make sure the tag's node only includes the tag's text)\r\n                this.normalizeTagNodes(openedDelimiter, delimiter, i, delimiters);\r\n                openedTag.xmlTextNode = openedDelimiter.xmlTextNode;\r\n\r\n                // extract tag info from tag's text\r\n                this.processTag(openedTag as Tag);\r\n                tags.push(openedTag as Tag);\r\n                openedTag = null;\r\n                openedDelimiter = null;\r\n            }\r\n        }\r\n\r\n        return tags;\r\n    }\r\n\r\n    /**\r\n     * Consolidate all tag's text into a single text node.\r\n     * \r\n     * Example: \r\n     * \r\n     * Text node before: \"some text {some tag} some more text\" \r\n     * Text nodes after: [ \"some text \", \"{some tag}\", \" some more text\" ]\r\n     */\r\n    private normalizeTagNodes(\r\n        openDelimiter: DelimiterMark,\r\n        closeDelimiter: DelimiterMark,\r\n        closeDelimiterIndex: number,\r\n        allDelimiters: DelimiterMark[]\r\n    ): void {\r\n\r\n        let startTextNode = openDelimiter.xmlTextNode;\r\n        let endTextNode = closeDelimiter.xmlTextNode;\r\n        const sameNode = (startTextNode === endTextNode);\r\n\r\n        // trim start\r\n        if (openDelimiter.index > 0) {\r\n            this.docParser.splitTextNode(startTextNode, openDelimiter.index, true);\r\n            if (sameNode) {\r\n                closeDelimiter.index -= openDelimiter.index;\r\n            }\r\n        }\r\n\r\n        // trim end\r\n        if (closeDelimiter.index < endTextNode.textContent.length - 1) {\r\n            endTextNode = this.docParser.splitTextNode(endTextNode, closeDelimiter.index + 1, true);\r\n            if (sameNode) {\r\n                startTextNode = endTextNode;\r\n            }\r\n        }\r\n\r\n        // join nodes\r\n        if (!sameNode) {\r\n            this.docParser.joinTextNodesRange(startTextNode, endTextNode);\r\n            endTextNode = startTextNode;\r\n        }\r\n\r\n        // update offsets of next delimiters\r\n        for (let i = closeDelimiterIndex + 1; i < allDelimiters.length; i++) {\r\n\r\n            let updated = false;\r\n            const curDelimiter = allDelimiters[i];\r\n\r\n            if (curDelimiter.xmlTextNode === openDelimiter.xmlTextNode) {\r\n                curDelimiter.index -= openDelimiter.index;\r\n                updated = true;\r\n            }\r\n\r\n            if (curDelimiter.xmlTextNode === closeDelimiter.xmlTextNode) {\r\n                curDelimiter.index -= closeDelimiter.index + 1;\r\n                updated = true;\r\n            }\r\n\r\n            if (!updated)\r\n                break;\r\n        }\r\n\r\n        // update references\r\n        openDelimiter.xmlTextNode = startTextNode;\r\n        closeDelimiter.xmlTextNode = endTextNode;\r\n    }\r\n\r\n    private processTag(tag: Tag): void {\r\n        tag.rawText = tag.xmlTextNode.textContent;\r\n\r\n        const tagParts = this.tagRegex.exec(tag.rawText);\r\n        const tagContent = (tagParts[1] || '').trim();\r\n        if (!tagContent || !tagContent.length) {\r\n            tag.disposition = TagDisposition.SelfClosed;\r\n            return;\r\n        }\r\n\r\n        if (tagContent.startsWith(this.delimiters.containerTagOpen)) {\r\n            tag.disposition = TagDisposition.Open;\r\n            tag.name = tagContent.slice(this.delimiters.containerTagOpen.length).trim();\r\n\r\n        } else if (tagContent.startsWith(this.delimiters.containerTagClose)) {\r\n            tag.disposition = TagDisposition.Close;\r\n            tag.name = tagContent.slice(this.delimiters.containerTagClose.length).trim();\r\n\r\n        } else {\r\n            tag.disposition = TagDisposition.SelfClosed;\r\n            tag.name = tagContent;\r\n        }\r\n    }\r\n}","import { UnclosedTagError, UnknownContentTypeError } from '../errors';\r\nimport { PluginContent, TemplatePlugin } from '../plugins';\r\nimport { isPromiseLike, toDictionary } from '../utils';\r\nimport { XmlNode } from '../xml';\r\nimport { DelimiterSearcher } from './delimiterSearcher';\r\nimport { ScopeData } from './scopeData';\r\nimport { Tag, TagDisposition } from './tag';\r\nimport { TagParser } from './tagParser';\r\nimport { TemplateContext } from './templateContext';\r\n\r\n/**\r\n * The TemplateCompiler works roughly the same way as a source code compiler.\r\n * It's main steps are:\r\n * \r\n * 1. find delimiters (lexical analysis) :: (Document) => DelimiterMark[]\r\n * 2. extract tags (syntax analysis) :: (DelimiterMark[]) => Tag[]\r\n * 3. perform document replace (code generation) :: (Tag[], data) => Document*\r\n * \r\n * see: https://en.wikipedia.org/wiki/Compiler\r\n */\r\nexport class TemplateCompiler {\r\n\r\n    private readonly pluginsLookup: IMap<TemplatePlugin>;\r\n\r\n    constructor(\r\n        private readonly delimiterSearcher: DelimiterSearcher,\r\n        private readonly tagParser: TagParser,\r\n        plugins: TemplatePlugin[],\r\n        private readonly defaultContentType: string,\r\n        private readonly containerContentType: string\r\n    ) {\r\n        this.pluginsLookup = toDictionary(plugins, p => p.contentType);\r\n    }\r\n\r\n    /**\r\n     * Compiles the template and performs the required replacements using the\r\n     * specified data.\r\n     */\r\n    public async compile(node: XmlNode, data: ScopeData, context: TemplateContext): Promise<void> {\r\n        const tags = this.parseTags(node);\r\n        await this.doTagReplacements(tags, data, context);\r\n    }\r\n\r\n    public parseTags(node: XmlNode): Tag[] {\r\n        const delimiters = this.delimiterSearcher.findDelimiters(node);\r\n        const tags = this.tagParser.parse(delimiters);\r\n        return tags;\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private async doTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        for (let tagIndex = 0; tagIndex < tags.length; tagIndex++) {\r\n\r\n            const tag = tags[tagIndex];\r\n            data.path.push(tag.name);\r\n            const contentType = this.detectContentType(tag, data);\r\n            const plugin = this.pluginsLookup[contentType];\r\n            if (!plugin) {\r\n                throw new UnknownContentTypeError(\r\n                    contentType,\r\n                    tag.rawText,\r\n                    data.path.join('.')\r\n                );\r\n            }\r\n\r\n            if (tag.disposition === TagDisposition.SelfClosed) {\r\n\r\n                // replace simple tag                \r\n                const job = plugin.simpleTagReplacements(tag, data, context);\r\n                if (isPromiseLike(job)) {\r\n                    await job;\r\n                }\r\n\r\n            } else if (tag.disposition === TagDisposition.Open) {\r\n\r\n                // get all tags between the open and close tags\r\n                const closingTagIndex = this.findCloseTagIndex(tagIndex, tag, tags);\r\n                const scopeTags = tags.slice(tagIndex, closingTagIndex + 1);\r\n                tagIndex = closingTagIndex;\r\n\r\n                // replace container tag\r\n                const job = plugin.containerTagReplacements(scopeTags, data, context);\r\n                if (isPromiseLike(job)) {\r\n                    await job;\r\n                }\r\n            }\r\n\r\n            data.path.pop();\r\n        }\r\n    }\r\n\r\n    private detectContentType(tag: Tag, data: ScopeData): string {\r\n\r\n        if (tag.disposition === TagDisposition.Open || tag.disposition === TagDisposition.Close)\r\n            return this.containerContentType;\r\n\r\n        const scopeData = data.getScopeData();\r\n        if (PluginContent.isPluginContent(scopeData))\r\n            return scopeData._type;\r\n\r\n        return this.defaultContentType;\r\n    }\r\n\r\n    private findCloseTagIndex(fromIndex: number, openTag: Tag, tags: Tag[]): number {\r\n\r\n        let i = fromIndex;\r\n        for (; i < tags.length; i++) {\r\n            const closeTag = tags[i];\r\n            if (\r\n                closeTag.name === openTag.name &&\r\n                closeTag.disposition === TagDisposition.Close\r\n            ) {\r\n                break;\r\n            }\r\n        }\r\n\r\n        if (i === tags.length) {\r\n            throw new UnclosedTagError(openTag.name);\r\n        }\r\n\r\n        return i;\r\n    }\r\n}","\r\nexport class Delimiters {\r\n\r\n    public tagStart = \"{\";\r\n    public tagEnd = \"}\";\r\n    public containerTagOpen = \"#\";\r\n    public containerTagClose = \"/\";\r\n\r\n    constructor(initial?: Partial<Delimiters>) {\r\n        Object.assign(this, initial);\r\n\r\n        this.encodeAndValidate();\r\n\r\n        if (this.containerTagOpen === this.containerTagClose)\r\n            throw new Error(`${nameof(this.containerTagOpen)} can not be equal to ${nameof(this.containerTagClose)}`);\r\n    }\r\n\r\n    private encodeAndValidate() {\r\n        const keys: (keyof Delimiters)[] = ['tagStart', 'tagEnd', 'containerTagOpen', 'containerTagClose'];\r\n        for (const key of keys) {\r\n\r\n            const value = this[key];\r\n            if (!value)\r\n                throw new Error(`${key} can not be empty.`);\r\n\r\n            if (value !== value.trim())\r\n                throw new Error(`${key} can not contain leading or trailing whitespace.`);\r\n        }\r\n    }\r\n}","export * from './malformedFileError';\r\nexport * from './maxXmlDepthError';\r\nexport * from './missingArgumentError';\r\nexport * from './missingCloseDelimiterError';\r\nexport * from './missingStartDelimiterError';\r\nexport * from './unclosedTagError';\r\nexport * from './unidentifiedFileTypeError';\r\nexport * from './unknownContentTypeError';\r\nexport * from './unopenedTagError';\r\nexport * from './unsupportedFileTypeError';\r\n","export class MalformedFileError extends Error {\r\n\r\n    public readonly expectedFileType: string;\r\n\r\n    constructor(expectedFileType: string) {\r\n        super(`Malformed file detected. Make sure the file is a valid ${expectedFileType} file.`);\r\n\r\n        this.expectedFileType = expectedFileType;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MalformedFileError.prototype);\r\n    }\r\n}","export class MaxXmlDepthError extends Error {\r\n\r\n    public readonly maxDepth: number;\r\n\r\n    constructor(maxDepth: number) {\r\n        super(`XML maximum depth reached (max depth: ${maxDepth}).`);\r\n\r\n        this.maxDepth = maxDepth;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MaxXmlDepthError.prototype);\r\n    }\r\n}","export class MissingArgumentError extends Error {\r\n\r\n    public readonly argName: string;\r\n\r\n    constructor(argName: string) {\r\n        super(`Argument '${argName}' is missing.`);\r\n\r\n        this.argName = argName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingArgumentError.prototype);\r\n    }\r\n}","export class MissingCloseDelimiterError extends Error {\r\n\r\n    public readonly openDelimiterText: string;\r\n\r\n    constructor(openDelimiterText: string) {\r\n        super(`Close delimiter is missing from '${openDelimiterText}'.`);\r\n\r\n        this.openDelimiterText = openDelimiterText;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingCloseDelimiterError.prototype);\r\n    }\r\n}","export class MissingStartDelimiterError extends Error {\r\n\r\n    public readonly closeDelimiterText: string;\r\n\r\n    constructor(closeDelimiterText: string) {\r\n        super(`Open delimiter is missing from '${closeDelimiterText}'.`);\r\n\r\n        this.closeDelimiterText = closeDelimiterText;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, MissingStartDelimiterError.prototype);\r\n    }\r\n}","export class UnclosedTagError extends Error {\r\n\r\n    public readonly tagName: string;\r\n\r\n    constructor(tagName: string) {\r\n        super(`Tag '${tagName}' is never closed.`);\r\n\r\n        this.tagName = tagName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnclosedTagError.prototype);\r\n    }\r\n}","export class UnidentifiedFileTypeError extends Error {\r\n    constructor() {\r\n        super(`The filetype for this file could not be identified, is this file corrupted?`);\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnidentifiedFileTypeError.prototype);\r\n    }\r\n}","export class UnknownContentTypeError extends Error {\r\n\r\n    public readonly tagRawText: string;\r\n    public readonly contentType: string;\r\n    public readonly path: string;\r\n\r\n    constructor(contentType: string, tagRawText: string, path: string) {\r\n        super(`Content type '${contentType}' does not have a registered plugin to handle it.`);\r\n\r\n        this.contentType = contentType;\r\n        this.tagRawText = tagRawText;\r\n        this.path = path;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnknownContentTypeError.prototype);\r\n    }\r\n}","export class UnopenedTagError extends Error {\r\n\r\n    public readonly tagName: string;\r\n\r\n    constructor(tagName: string) {\r\n        super(`Tag '${tagName}' is closed but was never opened.`);\r\n\r\n        this.tagName = tagName;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnopenedTagError.prototype);\r\n    }\r\n}","export class UnsupportedFileTypeError extends Error {\r\n\r\n    public readonly fileType: string;\r\n\r\n    constructor(fileType: string) {\r\n        super(`Filetype \"${fileType}\" is not supported.`);\r\n\r\n        this.fileType = fileType;\r\n\r\n        // typescript hack: https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n        Object.setPrototypeOf(this, UnsupportedFileTypeError.prototype);\r\n    }\r\n}","export * from './compilation';\r\nexport * from './errors';\r\nexport * from './office';\r\nexport * from './plugins';\r\nexport * from './utils';\r\nexport * from './xml';\r\nexport * from './zip';\r\nexport * from './delimiters';\r\nexport * from './mimeType';\r\nexport * from './templateData';\r\nexport * from './templateHandler';\r\nexport * from './templateHandlerOptions';\r\n","import { UnsupportedFileTypeError } from './errors';\r\n\r\nexport enum MimeType {\r\n    Png = 'image/png',\r\n    Jpeg = 'image/jpeg',\r\n    Gif = 'image/gif',\r\n    Bmp = 'image/bmp',\r\n    Svg = 'image/svg+xml'\r\n}\r\n\r\nexport class MimeTypeHelper {\r\n\r\n    public static getDefaultExtension(mime: MimeType): string {\r\n        switch (mime) {\r\n            case MimeType.Png:\r\n                return 'png';\r\n            case MimeType.Jpeg:\r\n                return 'jpg';\r\n            case MimeType.Gif:\r\n                return 'gif';\r\n            case MimeType.Bmp:\r\n                return 'bmp';\r\n            case MimeType.Svg:\r\n                return 'svg';\r\n            default:\r\n                throw new UnsupportedFileTypeError(mime);\r\n        }\r\n    }\r\n\r\n    public static getOfficeRelType(mime: MimeType): string {\r\n        switch (mime) {\r\n            case MimeType.Png:\r\n            case MimeType.Jpeg:\r\n            case MimeType.Gif:\r\n            case MimeType.Bmp:\r\n            case MimeType.Svg:\r\n                return \"http://schemas.openxmlformats.org/officeDocument/2006/relationships/image\";\r\n            default:\r\n                throw new UnsupportedFileTypeError(mime);\r\n        }\r\n    }\r\n}","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { XmlGeneralNode, XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * http://officeopenxml.com/anatomyofOOXML.php\r\n */\r\nexport class ContentTypesFile {\r\n\r\n    private static readonly contentTypesFilePath = '[Content_Types].xml';\r\n\r\n    private addedNew = false;\r\n\r\n    private root: XmlNode;\r\n\r\n    private contentTypes: IMap<boolean>;\r\n\r\n    constructor(\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n    }\r\n\r\n    public async ensureContentType(mime: MimeType): Promise<void> {\r\n\r\n        // parse the content types file\r\n        await this.parseContentTypesFile();\r\n\r\n        // already exists\r\n        if (this.contentTypes[mime])\r\n            return;\r\n\r\n        // add new\r\n        const extension = MimeTypeHelper.getDefaultExtension(mime);\r\n        const typeNode = XmlNode.createGeneralNode('Default');\r\n        typeNode.attributes = {\r\n            \"Extension\": extension,\r\n            \"ContentType\": mime\r\n        };\r\n        this.root.childNodes.push(typeNode);\r\n\r\n        // update state\r\n        this.addedNew = true;\r\n        this.contentTypes[mime] = true;\r\n    }\r\n\r\n    public async count(): Promise<number> {\r\n        await this.parseContentTypesFile();\r\n        return this.root.childNodes.filter(node => !XmlNode.isTextNode(node)).length;\r\n    }\r\n\r\n    /**\r\n     * Save the Content Types file back to the zip.  \r\n     * Called automatically by the holding `Docx` before exporting.\r\n     */\r\n    public async save(): Promise<void> {\r\n\r\n        // not change - no need to save\r\n        if (!this.addedNew)\r\n            return;\r\n\r\n        const xmlContent = this.xmlParser.serialize(this.root);\r\n        this.zip.setFile(ContentTypesFile.contentTypesFilePath, xmlContent);\r\n    }\r\n\r\n    private async parseContentTypesFile(): Promise<void> {\r\n        if (this.root)\r\n            return;\r\n\r\n        // parse the xml file\r\n        const contentTypesXml = await this.zip.getFile(ContentTypesFile.contentTypesFilePath).getContentText();\r\n        this.root = this.xmlParser.parse(contentTypesXml);\r\n\r\n        // build the content types lookup\r\n        this.contentTypes = {};\r\n        for (const node of this.root.childNodes) {\r\n\r\n            if (node.nodeName !== 'Default')\r\n                continue;\r\n\r\n            const genNode = (node as XmlGeneralNode);\r\n            const contentTypeAttribute = genNode.attributes['ContentType'];\r\n            if (!contentTypeAttribute)\r\n                continue;\r\n\r\n            this.contentTypes[contentTypeAttribute];\r\n        }\r\n    }\r\n}","import { MalformedFileError } from '../errors';\r\nimport { Binary } from '../utils';\r\nimport { XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\nimport { ContentTypesFile } from './contentTypesFile';\r\nimport { MediaFiles } from './mediaFiles';\r\nimport { Rels } from './rels';\r\n\r\n/**\r\n * Represents a single docx file.\r\n */\r\nexport class Docx {\r\n\r\n    public get documentPath(): string {\r\n\r\n        if (!this._documentPath) {\r\n\r\n            if (this.zip.isFileExist(\"word/document.xml\")) {\r\n                this._documentPath = \"word/document.xml\";\r\n            }\r\n\r\n            // https://github.com/open-xml-templating/docxtemplater/issues/366\r\n            else if (this.zip.isFileExist(\"word/document2.xml\")) {\r\n                this._documentPath = \"word/document2.xml\";\r\n            }\r\n        }\r\n\r\n        return this._documentPath;\r\n    }\r\n\r\n    public readonly rels: Rels;\r\n    public readonly mediaFiles: MediaFiles;\r\n    public readonly contentTypes: ContentTypesFile;\r\n\r\n    private _documentPath: string;\r\n    private _document: XmlNode;    \r\n\r\n    constructor(\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n        if (!this.documentPath)\r\n            throw new MalformedFileError('docx');\r\n\r\n        this.rels = new Rels(this.documentPath, zip, xmlParser);\r\n        this.mediaFiles = new MediaFiles(zip);\r\n        this.contentTypes = new ContentTypesFile(zip, xmlParser);\r\n    }\r\n\r\n    //\r\n    // public methods\r\n    //\r\n\r\n    /**\r\n     * The xml root of the main document file.\r\n     */\r\n    public async getDocument(): Promise<XmlNode> {\r\n        if (!this._document) {\r\n            const xml = await this.zip.getFile(this.documentPath).getContentText();\r\n            this._document = this.xmlParser.parse(xml);\r\n        }\r\n        return this._document;\r\n    }\r\n\r\n    /**\r\n     * Get the text content of the main document file.\r\n     */\r\n    public async getDocumentText(): Promise<string> {\r\n        const xmlDocument = await this.getDocument();\r\n\r\n        // ugly but good enough...\r\n        const xml = this.xmlParser.serialize(xmlDocument);\r\n        const domDocument = this.xmlParser.domParse(xml);\r\n\r\n        return domDocument.documentElement.textContent;\r\n    }    \r\n\r\n    public async export<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        await this.saveChanges();\r\n        return await this.zip.export(outputType);\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //        \r\n\r\n    private async saveChanges() {\r\n\r\n        // save main document\r\n        const document = await this.getDocument();\r\n        const xmlContent = this.xmlParser.serialize(document);\r\n        this.zip.setFile(this.documentPath, xmlContent);\r\n\r\n        // save other parts\r\n        await this.rels.save();\r\n        await this.contentTypes.save();\r\n    }\r\n}","import { XmlGeneralNode, XmlNode, XmlParser, XmlTextNode } from '../xml';\r\nimport { Zip } from '../zip';\r\nimport { Docx } from './docx';\r\n\r\nexport class DocxParser {\r\n\r\n    /*\r\n     * Word markup intro:\r\n     * \r\n     * In Word text nodes are contained in \"run\" nodes (which specifies text\r\n     * properties such as font and color). The \"run\" nodes in turn are\r\n     * contained in paragraph nodes which is the core unit of content.\r\n     * \r\n     * Example:\r\n     *\r\n     * <w:p>    <-- paragraph\r\n     *   <w:r>      <-- run\r\n     *     <w:rPr>      <-- run properties\r\n     *       <w:b/>     <-- bold\r\n     *     </w:rPr>\r\n     *     <w:t>This is text.</w:t>     <-- actual text\r\n     *   </w:r>\r\n     * </w:p> \r\n     *\r\n     * see: http://officeopenxml.com/WPcontentOverview.php\r\n     */\r\n\r\n    public static readonly PARAGRAPH_NODE = 'w:p';\r\n    public static readonly PARAGRAPH_PROPERTIES_NODE = 'w:pPr';\r\n    public static readonly RUN_NODE = 'w:r';\r\n    public static readonly RUN_PROPERTIES_NODE = 'w:rPr';\r\n    public static readonly TEXT_NODE = 'w:t';\r\n    public static readonly TABLE_ROW_NODE = 'w:tr';\r\n    public static readonly TABLE_CELL_NODE = 'w:tc';\r\n    public static readonly NUMBER_PROPERTIES_NODE = 'w:numPr';\r\n\r\n    //\r\n    // constructor\r\n    //\r\n\r\n    constructor(\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n    }\r\n\r\n    //\r\n    // parse document\r\n    //\r\n\r\n    public load(zip: Zip): Docx {\r\n        return new Docx(zip, this.xmlParser);\r\n    }\r\n\r\n    //\r\n    // content manipulation\r\n    //\r\n\r\n    /**\r\n     * Split the text node into two text nodes, each with it's own wrapping <w:t> node.\r\n     * Returns the newly created text node.\r\n     * \r\n     * @param textNode \r\n     * @param splitIndex \r\n     * @param addBefore Should the new node be added before or after the original node.\r\n     */\r\n    public splitTextNode(textNode: XmlTextNode, splitIndex: number, addBefore: boolean): XmlTextNode {\r\n\r\n        let firstXmlTextNode: XmlTextNode;\r\n        let secondXmlTextNode: XmlTextNode;\r\n\r\n        // split nodes\r\n        const wordTextNode = this.containingTextNode(textNode);\r\n        const newWordTextNode = XmlNode.cloneNode(wordTextNode, true);\r\n\r\n        // set space preserve to prevent display differences after splitting\r\n        // (otherwise if there was a space in the middle of the text node and it\r\n        // is now at the beginning or end of the text node it will be ignored)\r\n        this.setSpacePreserveAttribute(wordTextNode);\r\n        this.setSpacePreserveAttribute(newWordTextNode);\r\n\r\n        if (addBefore) {\r\n\r\n            // insert new node before existing one\r\n            XmlNode.insertBefore(newWordTextNode, wordTextNode);\r\n\r\n            firstXmlTextNode = XmlNode.lastTextChild(newWordTextNode);\r\n            secondXmlTextNode = textNode;\r\n\r\n        } else {\r\n\r\n            // insert new node after existing one\r\n            const curIndex = wordTextNode.parentNode.childNodes.indexOf(wordTextNode);\r\n            XmlNode.insertChild(wordTextNode.parentNode, newWordTextNode, curIndex + 1);\r\n\r\n            firstXmlTextNode = textNode;\r\n            secondXmlTextNode = XmlNode.lastTextChild(newWordTextNode);\r\n        }\r\n\r\n        // edit text\r\n        const firstText = firstXmlTextNode.textContent;\r\n        const secondText = secondXmlTextNode.textContent;\r\n        firstXmlTextNode.textContent = firstText.substring(0, splitIndex);\r\n        secondXmlTextNode.textContent = secondText.substring(splitIndex);\r\n\r\n        return (addBefore ? firstXmlTextNode : secondXmlTextNode);\r\n    }\r\n\r\n    /**\r\n     * Move all text between the 'from' and 'to' nodes to the 'from' node.\r\n     */\r\n    public joinTextNodesRange(from: XmlTextNode, to: XmlTextNode): void {\r\n\r\n        // find run nodes\r\n        const firstRunNode = this.containingRunNode(from);\r\n        const secondRunNode = this.containingRunNode(to);\r\n\r\n        const paragraphNode = firstRunNode.parentNode;\r\n        if (secondRunNode.parentNode !== paragraphNode)\r\n            throw new Error('Can not join text nodes from separate paragraphs.');\r\n\r\n        // find \"word text nodes\"\r\n        const firstWordTextNode = this.containingTextNode(from);\r\n        const secondWordTextNode = this.containingTextNode(to);\r\n        const totalText: string[] = [];\r\n\r\n        // iterate runs\r\n        let curRunNode = firstRunNode;\r\n        while (curRunNode) {\r\n\r\n            // iterate text nodes\r\n            let curWordTextNode: XmlNode;\r\n            if (curRunNode === firstRunNode) {\r\n                curWordTextNode = firstWordTextNode;\r\n            } else {\r\n                curWordTextNode = this.firstTextNodeChild(curRunNode);\r\n            }\r\n            while (curWordTextNode) {\r\n\r\n                if (curWordTextNode.nodeName !== DocxParser.TEXT_NODE)\r\n                    continue;\r\n\r\n                // move text to first node\r\n                const curXmlTextNode = XmlNode.lastTextChild(curWordTextNode);\r\n                totalText.push(curXmlTextNode.textContent);\r\n\r\n                // next text node\r\n                const textToRemove = curWordTextNode;\r\n                if (curWordTextNode === secondWordTextNode) {\r\n                    curWordTextNode = null;\r\n                } else {\r\n                    curWordTextNode = curWordTextNode.nextSibling;\r\n                }\r\n\r\n                // remove current text node\r\n                if (textToRemove !== firstWordTextNode) {\r\n                    XmlNode.remove(textToRemove);\r\n                }\r\n            }\r\n\r\n            // next run\r\n            const runToRemove = curRunNode;\r\n            if (curRunNode === secondRunNode) {\r\n                curRunNode = null;\r\n            } else {\r\n                curRunNode = curRunNode.nextSibling;\r\n            }\r\n\r\n            // remove current run\r\n            if (!runToRemove.childNodes || !runToRemove.childNodes.length) {\r\n                XmlNode.remove(runToRemove);\r\n            }\r\n        }\r\n\r\n        // set the text content\r\n        const firstXmlTextNode = XmlNode.lastTextChild(firstWordTextNode);\r\n        firstXmlTextNode.textContent = totalText.join('');\r\n    }\r\n\r\n    /**\r\n     * Take all runs from 'second' and move them to 'first'.\r\n     */\r\n    public joinParagraphs(first: XmlNode, second: XmlNode): void {\r\n        if (first === second)\r\n            return;\r\n\r\n        let childIndex = 0;\r\n        while (second.childNodes && childIndex < second.childNodes.length) {\r\n            const curChild = second.childNodes[childIndex];\r\n            if (curChild.nodeName === DocxParser.RUN_NODE) {\r\n                XmlNode.removeChild(second, childIndex);\r\n                XmlNode.appendChild(first, curChild);\r\n            } else {\r\n                childIndex++;\r\n            }\r\n        }\r\n    }\r\n\r\n    public setSpacePreserveAttribute(node: XmlGeneralNode): void {\r\n        if (!node.attributes) {\r\n            node.attributes = {};\r\n        }\r\n        if (!node.attributes['xml:space']) {\r\n            node.attributes['xml:space'] = 'preserve';\r\n        }\r\n    }\r\n\r\n    //\r\n    // node queries\r\n    //\r\n\r\n    public isTextNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.TEXT_NODE;\r\n    }\r\n\r\n    public isTableCellNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.TABLE_CELL_NODE;\r\n    }\r\n\r\n    public isParagraphNode(node: XmlNode): boolean {\r\n        return node.nodeName === DocxParser.PARAGRAPH_NODE;\r\n    }\r\n\r\n    public isListParagraph(paragraphNode: XmlNode): boolean {\r\n        const paragraphProperties = this.paragraphPropertiesNode(paragraphNode);\r\n        const listNumberProperties = XmlNode.findChildByName(paragraphProperties, DocxParser.NUMBER_PROPERTIES_NODE);\r\n        return !!listNumberProperties;\r\n    }\r\n\r\n    public paragraphPropertiesNode(paragraphNode: XmlNode): XmlNode {\r\n        if (!this.isParagraphNode(paragraphNode))\r\n            throw new Error(`Expected paragraph node but received a '${paragraphNode.nodeName}' node.`);\r\n\r\n        return XmlNode.findChildByName(paragraphNode, DocxParser.PARAGRAPH_PROPERTIES_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search for the first direct child **Word** text node (i.e. a <w:t> node).\r\n     */\r\n    public firstTextNodeChild(node: XmlNode): XmlNode {\r\n\r\n        if (!node)\r\n            return null;\r\n\r\n        if (node.nodeName !== DocxParser.RUN_NODE)\r\n            return null;\r\n\r\n        if (!node.childNodes)\r\n            return null;\r\n\r\n        for (const child of node.childNodes) {\r\n            if (child.nodeName === DocxParser.TEXT_NODE)\r\n                return child;\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first **Word** text node (i.e. a <w:t> node).\r\n     */\r\n    public containingTextNode(node: XmlTextNode): XmlGeneralNode {\r\n\r\n        if (!node)\r\n            return null;\r\n\r\n        if (!XmlNode.isTextNode(node))\r\n            throw new Error(`'Invalid argument ${nameof(node)}. Expected a XmlTextNode.`);\r\n\r\n        return XmlNode.findParentByName(node, DocxParser.TEXT_NODE) as XmlGeneralNode;\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first run node.\r\n     */\r\n    public containingRunNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.RUN_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first paragraph node.\r\n     */\r\n    public containingParagraphNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.PARAGRAPH_NODE);\r\n    }\r\n\r\n    /**\r\n     * Search **upwards** for the first \"table row\" node.\r\n     */\r\n    public containingTableRowNode(node: XmlNode): XmlNode {\r\n        return XmlNode.findParentByName(node, DocxParser.TABLE_ROW_NODE);\r\n    }\r\n}","export * from './docx';\r\nexport * from './docxParser';\r\n","import { MimeType, MimeTypeHelper } from '../mimeType';\r\nimport { Binary, Path, sha1 } from '../utils';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * Handles media files of the main document.\r\n */\r\nexport class MediaFiles {\r\n\r\n    private static readonly mediaDir = 'word/media';\r\n\r\n    private hashes: IMap<string>;\r\n    private readonly files = new Map<Binary, string>();\r\n    private nextFileId = 0;\r\n\r\n    constructor(private readonly zip: Zip) {\r\n    }\r\n\r\n    /**\r\n     * Returns the media file path.\r\n     */\r\n    public async add(mediaFile: Binary, mime: MimeType): Promise<string> {\r\n\r\n        // check if already added\r\n        if (this.files.has(mediaFile))\r\n            return this.files.get(mediaFile);\r\n\r\n        // hash existing media files\r\n        await this.hashMediaFiles();\r\n\r\n        // hash the new file  \r\n        // Note: Even though hashing the base64 string may seem inefficient\r\n        // (requires extra step in some cases) in practice it is significantly\r\n        // faster than hashing a 'binarystring'.\r\n        const base64 = await Binary.toBase64(mediaFile);\r\n        const hash = sha1(base64);\r\n\r\n        // check if file already exists\r\n        // note: this can be optimized by keeping both mapping by filename as well as by hash\r\n        let path = Object.keys(this.hashes).find(p => this.hashes[p] === hash);\r\n        if (path)\r\n            return path;\r\n\r\n        // generate unique media file name\r\n        const extension = MimeTypeHelper.getDefaultExtension(mime);\r\n        do {\r\n            this.nextFileId++;\r\n            path = `${MediaFiles.mediaDir}/media${this.nextFileId}.${extension}`;\r\n        } while (this.hashes[path]);\r\n\r\n        // add media to zip\r\n        await this.zip.setFile(path, mediaFile);\r\n\r\n        // add media to our lookups\r\n        this.hashes[path] = hash;\r\n        this.files.set(mediaFile, path);\r\n\r\n        // return\r\n        return path;\r\n    }\r\n\r\n    public async count(): Promise<number> {\r\n        await this.hashMediaFiles();\r\n        return Object.keys(this.hashes).length;\r\n    }\r\n\r\n    private async hashMediaFiles(): Promise<void> {\r\n        if (this.hashes)\r\n            return;\r\n\r\n        this.hashes = {};\r\n        for (const path of this.zip.listFiles()) {\r\n\r\n            if (!path.startsWith(MediaFiles.mediaDir))\r\n                continue;\r\n\r\n            const filename = Path.getFilename(path);\r\n            if (!filename)\r\n                continue;\r\n\r\n            const fileData = await this.zip.getFile(path).getContentBase64();\r\n            const fileHash = sha1(fileData);\r\n            this.hashes[filename] = fileHash;\r\n        }\r\n    }\r\n}","import { Path } from '../utils';\r\nimport { XmlGeneralNode, XmlNode, XmlParser } from '../xml';\r\nimport { Zip } from '../zip';\r\n\r\n/**\r\n * Handles the relationship logic of a single docx \"part\".  \r\n * http://officeopenxml.com/anatomyofOOXML.php\r\n */\r\nexport class Rels {\r\n\r\n    private root: XmlNode;\r\n    private relIds: IMap<boolean>;\r\n    private relTargets: IMap<string>;\r\n    private nextRelId = 0;\r\n\r\n    private readonly partDir: string;\r\n    private readonly relsFilePath: string;\r\n\r\n    constructor(\r\n        partPath: string,\r\n        private readonly zip: Zip,\r\n        private readonly xmlParser: XmlParser\r\n    ) {\r\n\r\n        this.partDir = Path.getDirectory(partPath);\r\n        const partFilename = Path.getFilename(partPath);\r\n        this.relsFilePath = `${this.partDir}/_rels/${partFilename}.rels`;\r\n    }\r\n\r\n    /**\r\n     * Returns the rel ID.\r\n     */\r\n    public async add(relTarget: string, relType: string, additionalAttributes?: IMap<string>): Promise<string> {\r\n\r\n        // if relTarget is an internal file it should be relative to the part dir\r\n        if (relTarget.startsWith(this.partDir)) {\r\n            relTarget = relTarget.substr(this.partDir.length + 1);\r\n        }\r\n\r\n        // parse rels file\r\n        await this.parseRelsFile();\r\n\r\n        // already exists?\r\n        const relTargetKey = this.getRelTargetKey(relType, relTarget);\r\n        let relId = this.relTargets[relTargetKey];\r\n        if (relId)\r\n            return relId;\r\n\r\n        // add rel node\r\n        relId = this.getNextRelId();\r\n        const relNode = XmlNode.createGeneralNode('Relationship');\r\n        relNode.attributes = Object.assign({\r\n            \"Id\": relId,\r\n            \"Type\": relType,\r\n            \"Target\": relTarget\r\n        }, additionalAttributes);\r\n        this.root.childNodes.push(relNode);\r\n\r\n        // update lookups\r\n        this.relIds[relId] = true;\r\n        this.relTargets[relTargetKey] = relId;\r\n\r\n        // return\r\n        return relId;\r\n    }\r\n\r\n    /**\r\n     * Save the rels file back to the zip.  \r\n     * Called automatically by the holding `Docx` before exporting.\r\n     */\r\n    public async save(): Promise<void> {\r\n\r\n        // not change - no need to save\r\n        if (!this.root)\r\n            return;\r\n\r\n        const xmlContent = this.xmlParser.serialize(this.root);\r\n        this.zip.setFile(this.relsFilePath, xmlContent);\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private getNextRelId(): string {\r\n\r\n        let relId: string;;\r\n        do {\r\n            this.nextRelId++;\r\n            relId = 'rId' + this.nextRelId;\r\n        } while (this.relIds[relId]);\r\n\r\n        return relId;\r\n    }\r\n\r\n    private async parseRelsFile(): Promise<void> {\r\n        if (this.root)\r\n            return;\r\n\r\n        // parse the xml file\r\n        let relsXml: string;\r\n        const relsFile = this.zip.getFile(this.relsFilePath);\r\n        if (relsFile) {\r\n            relsXml = await relsFile.getContentText();\r\n        } else {\r\n            relsXml = `<Relationships xmlns=\"http://schemas.openxmlformats.org/package/2006/relationships\">\r\n                      </Relationships>`;\r\n        }\r\n        this.root = this.xmlParser.parse(relsXml);\r\n\r\n        // build lookups\r\n        this.relIds = {};\r\n        this.relTargets = {};\r\n        for (const rel of this.root.childNodes) {\r\n\r\n            const attributes = (rel as XmlGeneralNode).attributes;\r\n            if (!attributes)\r\n                continue;\r\n\r\n            // relIds lookup\r\n            const idAttr = attributes['Id'];\r\n            if (!idAttr)\r\n                continue;\r\n            this.relIds[idAttr] = true;\r\n\r\n            // rel target lookup\r\n            const typeAttr = attributes['Type'];\r\n            const targetAttr = attributes['Target'];\r\n            if (typeAttr && targetAttr) {\r\n                const relTargetKey = this.getRelTargetKey(typeAttr, targetAttr);\r\n                this.relTargets[relTargetKey] = idAttr;\r\n            }\r\n        }\r\n    }\r\n\r\n    private getRelTargetKey(type: string, target: string): string {\r\n        return `${type} - ${target}`;\r\n    }\r\n}","import { ImagePlugin } from './imagePlugin';\r\nimport { LinkPlugin } from './linkPlugin';\r\nimport { LoopPlugin } from './loopPlugin';\r\nimport { RawXmlPlugin } from './rawXmlPlugin';\r\nimport { TemplatePlugin } from './templatePlugin';\r\nimport { TextPlugin } from './textPlugin';\r\n\r\nexport function createDefaultPlugins(): TemplatePlugin[] {\r\n    return [\r\n        new LoopPlugin(), \r\n        new RawXmlPlugin(),\r\n        new ImagePlugin(),\r\n        new LinkPlugin(),\r\n        new TextPlugin()\r\n    ];\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { MimeTypeHelper } from '../mimeType';\r\nimport { XmlGeneralNode, XmlNode } from '../xml';\r\nimport { ImageContent } from './imageContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\n/**\r\n * Apparently it is not that important for the ID to be unique...  \r\n * Word displays two images correctly even if they both have the same ID.\r\n * Further more, Word will assign each a unique ID upon saving (it assigns\r\n * consecutive integers starting with 1).  \r\n * \r\n * Note: The same principal applies to image names.\r\n *\r\n * Tested in Word v1908\r\n */\r\nlet nextImageId = 1;\r\n\r\nexport class ImagePlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = 'image';\r\n\r\n    public async simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const content = data.getScopeData() as ImageContent;\r\n        if (!content || !content.source) {\r\n            XmlNode.remove(wordTextNode);\r\n            return;\r\n        }\r\n\r\n        // add the image file into the archive\r\n        const mediaFilePath = await context.docx.mediaFiles.add(content.source, content.format);\r\n        const relType = MimeTypeHelper.getOfficeRelType(content.format);\r\n        const relId = await context.docx.rels.add(mediaFilePath, relType);\r\n        await context.docx.contentTypes.ensureContentType(content.format);\r\n\r\n        // create the xml markup\r\n        const imageId = nextImageId++;\r\n        const imageXml = this.createMarkup(imageId, relId, content.width, content.height);\r\n\r\n        XmlNode.insertAfter(imageXml, wordTextNode);\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n\r\n    private createMarkup(imageId: number, relId: string, width: number, height: number): XmlNode {\r\n\r\n        // http://officeopenxml.com/drwPicInline.php\r\n\r\n        //\r\n        // Performance note:  \r\n        //\r\n        // I've tried to improve the markup generation performance by parsing\r\n        // the string once and caching the result (and of course customizing it\r\n        // per image) but it made no change whatsoever (in both cases 1000 items\r\n        // loop takes around 8 seconds on my machine) so I'm sticking with this\r\n        // approach which I find to be more readable.\r\n        //\r\n\r\n        const name = `Picture ${imageId}`;\r\n        const markupText = `\r\n            <w:drawing>\r\n                <wp:inline distT=\"0\" distB=\"0\" distL=\"0\" distR=\"0\">\r\n                    <wp:extent cx=\"${this.pixelsToEmu(width)}\" cy=\"${this.pixelsToEmu(height)}\"/>\r\n                    <wp:effectExtent l=\"0\" t=\"0\" r=\"0\" b=\"0\"/>\r\n                    <wp:docPr id=\"${imageId}\" name=\"${name}\"/>\r\n                    <wp:cNvGraphicFramePr>\r\n                        <a:graphicFrameLocks xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\" noChangeAspect=\"1\"/>\r\n                    </wp:cNvGraphicFramePr>\r\n                    <a:graphic xmlns:a=\"http://schemas.openxmlformats.org/drawingml/2006/main\">\r\n                        <a:graphicData uri=\"http://schemas.openxmlformats.org/drawingml/2006/picture\">\r\n                            ${this.pictureMarkup(name, relId, width, height)}\r\n                        </a:graphicData>\r\n                    </a:graphic>\r\n                </wp:inline>\r\n            </w:drawing>\r\n        `;\r\n\r\n        const markupXml = this.utilities.xmlParser.parse(markupText) as XmlGeneralNode;\r\n        XmlNode.removeEmptyTextNodes(markupXml); // remove whitespace\r\n\r\n        return markupXml;\r\n    }\r\n\r\n    private pictureMarkup(name: string, relId: string, width: number, height: number) {\r\n\r\n        // http://officeopenxml.com/drwPic.php\r\n\r\n        // legend:\r\n        // nvPicPr - non-visual picture properties - id, name, etc.\r\n        // blipFill - binary large image (or) picture fill - image size, image fill, etc.\r\n        // spPr - shape properties - frame size, frame fill, etc.\r\n\r\n        return `\r\n            <pic:pic xmlns:pic=\"http://schemas.openxmlformats.org/drawingml/2006/picture\">\r\n                <pic:nvPicPr>\r\n                    <pic:cNvPr id=\"0\" name=\"${name}\"/>\r\n                    <pic:cNvPicPr>\r\n                        <a:picLocks noChangeAspect=\"1\" noChangeArrowheads=\"1\"/>\r\n                    </pic:cNvPicPr>\r\n                </pic:nvPicPr>\r\n                <pic:blipFill>\r\n                    <a:blip r:embed=\"${relId}\">\r\n                        <a:extLst>\r\n                            <a:ext uri=\"{28A0092B-C50C-407E-A947-70E740481C1C}\">\r\n                                <a14:useLocalDpi xmlns:a14=\"http://schemas.microsoft.com/office/drawing/2010/main\" val=\"0\"/>\r\n                            </a:ext>\r\n                        </a:extLst>\r\n                    </a:blip>\r\n                    <a:srcRect/>\r\n                    <a:stretch>\r\n                        <a:fillRect/>\r\n                    </a:stretch>\r\n                </pic:blipFill>\r\n                <pic:spPr bwMode=\"auto\">\r\n                    <a:xfrm>\r\n                        <a:off x=\"0\" y=\"0\"/>\r\n                        <a:ext cx=\"${this.pixelsToEmu(width)}\" cy=\"${this.pixelsToEmu(height)}\"/>\r\n                    </a:xfrm>\r\n                    <a:prstGeom prst=\"rect\">\r\n                        <a:avLst/>\r\n                    </a:prstGeom>\r\n                    <a:noFill/>\r\n                    <a:ln>\r\n                        <a:noFill/>\r\n                    </a:ln>\r\n                </pic:spPr>\r\n            </pic:pic>\r\n        `;\r\n    }\r\n\r\n    private pixelsToEmu(pixels: number): number {\r\n\r\n        // https://stackoverflow.com/questions/20194403/openxml-distance-size-units\r\n        // https://docs.microsoft.com/en-us/windows/win32/vml/msdn-online-vml-units#other-units-of-measurement\r\n        // https://en.wikipedia.org/wiki/Office_Open_XML_file_formats#DrawingML\r\n        // http://www.java2s.com/Code/CSharp/2D-Graphics/ConvertpixelstoEMUEMUtopixels.htm\r\n\r\n        return Math.round(pixels * 9525);\r\n    }\r\n}","export * from './defaultPlugins';\r\nexport * from './imageContent';\r\nexport * from './imagePlugin';\r\nexport * from './linkContent';\r\nexport * from './linkPlugin';\r\nexport * from './loopPlugin';\r\nexport * from './pluginContent';\r\nexport * from './rawXmlContent';\r\nexport * from './rawXmlPlugin';\r\nexport * from './templatePlugin';\r\nexport * from './textPlugin';\r\n","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlNode } from '../xml';\r\nimport { LinkContent } from './linkContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport class LinkPlugin extends TemplatePlugin {\r\n\r\n    private static readonly linkRelType = 'http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink';\r\n\r\n    public readonly contentType = 'link';\r\n\r\n    public async simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const content = data.getScopeData() as LinkContent;\r\n        if (!content || !content.target) {\r\n            XmlNode.remove(wordTextNode);\r\n            return;\r\n        }\r\n\r\n        // add rel\r\n        const linkAttributes = { TargetMode: 'External' };\r\n        const relId = await context.docx.rels.add(content.target, LinkPlugin.linkRelType, linkAttributes);\r\n\r\n        // generate markup\r\n        const wordRunNode = this.utilities.docxParser.containingRunNode(wordTextNode);\r\n        const linkMarkup = this.generateMarkup(content, relId, wordRunNode);\r\n\r\n        // add to document\r\n        this.insertHyperlinkNode(linkMarkup, wordRunNode, wordTextNode);\r\n    }\r\n\r\n    private generateMarkup(content: LinkContent, relId: string, wordRunNode: XmlNode) {\r\n\r\n        // http://officeopenxml.com/WPhyperlink.php\r\n\r\n        const markupText = `\r\n            <w:hyperlink r:id=\"${relId}\" w:history=\"1\">\r\n                <w:r>\r\n                    <w:t>${content.text || content.target}</w:t>\r\n                </w:r>\r\n            </w:hyperlink>\r\n        `;\r\n        const markupXml = this.utilities.xmlParser.parse(markupText);\r\n        XmlNode.removeEmptyTextNodes(markupXml); // remove whitespace\r\n\r\n        // copy props from original run node (preserve style)        \r\n        const runProps = wordRunNode.childNodes.find(node => node.nodeName === DocxParser.RUN_PROPERTIES_NODE);\r\n        if (runProps) {\r\n            const linkRunProps = XmlNode.cloneNode(runProps, true);\r\n            markupXml.childNodes[0].childNodes.unshift(linkRunProps);\r\n        }\r\n\r\n        return markupXml;\r\n    }\r\n\r\n    private insertHyperlinkNode(linkMarkup: XmlNode, tagRunNode: XmlNode, tagTextNode: XmlNode) {\r\n\r\n        // Links are inserted at the 'run' level.  \r\n        // Therefor we isolate the link tag to it's own run (it is already\r\n        // isolated to it's own text node), insert the link markup and remove\r\n        // the run.\r\n        let textNodesInRun = tagRunNode.childNodes.filter(node => node.nodeName === DocxParser.TEXT_NODE);\r\n        if (textNodesInRun.length > 1) {\r\n            \r\n            const [runBeforeTag] = XmlNode.splitByChild(tagRunNode, tagTextNode, true);\r\n            textNodesInRun = runBeforeTag.childNodes.filter(node => node.nodeName === DocxParser.TEXT_NODE);\r\n\r\n            XmlNode.insertAfter(linkMarkup, runBeforeTag);\r\n            if (textNodesInRun.length === 0) {\r\n                XmlNode.remove(runBeforeTag);\r\n            }\r\n        }\r\n\r\n        // already isolated\r\n        else {\r\n            XmlNode.insertAfter(linkMarkup, tagRunNode);\r\n            XmlNode.remove(tagRunNode);\r\n        }\r\n    }\r\n}","export * from './iLoopStrategy';\r\nexport * from './loopListStrategy';\r\nexport * from './loopParagraphStrategy';\r\nexport * from './loopTableStrategy';\r\n","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopListStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        const containingParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        return this.utilities.docxParser.isListParagraph(containingParagraph);\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        const firstParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        const lastParagraph = this.utilities.docxParser.containingParagraphNode(closeTag.xmlTextNode);\r\n        const paragraphsToRepeat = XmlNode.siblingsInRange(firstParagraph, lastParagraph);\r\n\r\n        // remove the loop tags\r\n        XmlNode.remove(openTag.xmlTextNode);\r\n        XmlNode.remove(closeTag.xmlTextNode);\r\n\r\n        return {\r\n            firstNode: firstParagraph,\r\n            nodesToRepeat: paragraphsToRepeat,\r\n            lastNode: lastParagraph\r\n        };\r\n    }\r\n\r\n    public mergeBack(paragraphGroups: XmlNode[][], firstParagraph: XmlNode, lastParagraphs: XmlNode): void {\r\n\r\n        for (const curParagraphsGroup of paragraphGroups) {\r\n            for (const paragraph of curParagraphsGroup) {\r\n                XmlNode.insertBefore(paragraph, lastParagraphs);\r\n            }\r\n        }\r\n\r\n        // remove the old paragraphs\r\n        XmlNode.remove(firstParagraph);\r\n        if (firstParagraph !== lastParagraphs) {\r\n            XmlNode.remove(lastParagraphs);\r\n        }\r\n    }\r\n}","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopParagraphStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        return true;\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        // gather some info\r\n        let firstParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        let lastParagraph = this.utilities.docxParser.containingParagraphNode(closeTag.xmlTextNode);\r\n        const areSame = (firstParagraph === lastParagraph);\r\n        const parent = firstParagraph.parentNode;\r\n        const firstParagraphIndex = parent.childNodes.indexOf(firstParagraph);\r\n        const lastParagraphIndex = areSame ? firstParagraphIndex : parent.childNodes.indexOf(lastParagraph);\r\n\r\n        // split first paragraphs\r\n        let splitResult = XmlNode.splitByChild(firstParagraph, openTag.xmlTextNode, true);\r\n        firstParagraph = splitResult[0];\r\n        const firstParagraphSplit = splitResult[1];\r\n        if (areSame)\r\n            lastParagraph = firstParagraphSplit;\r\n\r\n        // split last paragraph\r\n        splitResult = XmlNode.splitByChild(lastParagraph, closeTag.xmlTextNode, true);\r\n        const lastParagraphSplit = splitResult[0];\r\n        lastParagraph = splitResult[1];\r\n\r\n        // fix references\r\n        XmlNode.removeChild(parent, firstParagraphIndex + 1);\r\n        if (!areSame)\r\n            XmlNode.removeChild(parent, lastParagraphIndex);\r\n        firstParagraphSplit.parentNode = null;\r\n        lastParagraphSplit.parentNode = null;\r\n\r\n        // extract all paragraphs in between\r\n        let middleParagraphs: XmlNode[];\r\n        if (areSame) {\r\n            this.utilities.docxParser.joinParagraphs(firstParagraphSplit, lastParagraphSplit);\r\n            middleParagraphs = [firstParagraphSplit];\r\n        } else {\r\n            const inBetween = XmlNode.removeSiblings(firstParagraph, lastParagraph);\r\n            middleParagraphs = [firstParagraphSplit].concat(inBetween).concat(lastParagraphSplit);\r\n        }\r\n\r\n        return {\r\n            firstNode: firstParagraph,\r\n            nodesToRepeat: middleParagraphs,\r\n            lastNode: lastParagraph\r\n        };\r\n    }\r\n\r\n    public mergeBack(middleParagraphs: XmlNode[][], firstParagraph: XmlNode, lastParagraph: XmlNode): void {\r\n\r\n        let mergeTo = firstParagraph;\r\n        for (const curParagraphsGroup of middleParagraphs) {\r\n\r\n            // merge first paragraphs\r\n            this.utilities.docxParser.joinParagraphs(mergeTo, curParagraphsGroup[0]);\r\n\r\n            // add middle and last paragraphs to the original document\r\n            for (let i = 1; i < curParagraphsGroup.length; i++) {\r\n                XmlNode.insertBefore(curParagraphsGroup[i], lastParagraph);\r\n                mergeTo = curParagraphsGroup[i];\r\n            }\r\n        }\r\n\r\n        // merge last paragraph\r\n        this.utilities.docxParser.joinParagraphs(mergeTo, lastParagraph);\r\n\r\n        // remove the old last paragraph (was merged into the new one)\r\n        XmlNode.remove(lastParagraph);\r\n    }\r\n}\r\n","import { Tag } from '../../compilation';\r\nimport { XmlNode } from '../../xml';\r\nimport { PluginUtilities } from '../templatePlugin';\r\nimport { ILoopStrategy, SplitBeforeResult } from './iLoopStrategy';\r\n\r\nexport class LoopTableStrategy implements ILoopStrategy {\r\n\r\n    private utilities: PluginUtilities;\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    public isApplicable(openTag: Tag, closeTag: Tag): boolean {\r\n        const containingParagraph = this.utilities.docxParser.containingParagraphNode(openTag.xmlTextNode);\r\n        if (!containingParagraph.parentNode)\r\n            return false;\r\n        return this.utilities.docxParser.isTableCellNode(containingParagraph.parentNode);\r\n    }\r\n\r\n    public splitBefore(openTag: Tag, closeTag: Tag): SplitBeforeResult {\r\n\r\n        const firstRow = this.utilities.docxParser.containingTableRowNode(openTag.xmlTextNode);\r\n        const lastRow = this.utilities.docxParser.containingTableRowNode(closeTag.xmlTextNode);\r\n        const rowsToRepeat = XmlNode.siblingsInRange(firstRow, lastRow);\r\n\r\n        // remove the loop tags\r\n        XmlNode.remove(openTag.xmlTextNode);\r\n        XmlNode.remove(closeTag.xmlTextNode);\r\n\r\n        return {\r\n            firstNode: firstRow,\r\n            nodesToRepeat: rowsToRepeat,\r\n            lastNode: lastRow\r\n        };\r\n    }\r\n\r\n    public mergeBack(rowGroups: XmlNode[][], firstRow: XmlNode, lastRow: XmlNode): void {\r\n\r\n        for (const curRowsGroup of rowGroups) {\r\n            for (const row of curRowsGroup) {\r\n                XmlNode.insertBefore(row, lastRow);\r\n            }\r\n        }\r\n\r\n        // remove the old rows\r\n        XmlNode.remove(firstRow);\r\n        if (firstRow !== lastRow) {\r\n            XmlNode.remove(lastRow);\r\n        }\r\n    }\r\n}","import { ScopeData, Tag, TemplateContext } from '../compilation';\r\nimport { TemplateData } from '../templateData';\r\nimport { last } from '../utils';\r\nimport { XmlNode } from '../xml';\r\nimport { ILoopStrategy, LoopListStrategy, LoopParagraphStrategy, LoopTableStrategy } from './loop';\r\nimport { PluginUtilities, TemplatePlugin } from './templatePlugin';\r\n\r\nexport const LOOP_CONTENT_TYPE = 'loop';\r\n\r\nexport class LoopPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = LOOP_CONTENT_TYPE;\r\n\r\n    private readonly loopStrategies: ILoopStrategy[] = [\r\n        new LoopTableStrategy(),\r\n        new LoopListStrategy(),\r\n        new LoopParagraphStrategy() // the default strategy\r\n    ];\r\n\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n        this.loopStrategies.forEach(strategy => strategy.setUtilities(utilities));\r\n    }    \r\n\r\n    public async containerTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): Promise<void> {\r\n\r\n        let value = data.getScopeData() as TemplateData[];\r\n\r\n        if (!value || !Array.isArray(value) || !value.length)\r\n            value = [];\r\n\r\n        // vars\r\n        const openTag = tags[0];\r\n        const closeTag = last(tags);\r\n\r\n        // select the suitable strategy\r\n        const loopStrategy = this.loopStrategies.find(strategy => strategy.isApplicable(openTag, closeTag));\r\n        if (!loopStrategy)\r\n            throw new Error(`No loop strategy found for tag '${openTag.rawText}'.`);\r\n\r\n        // prepare to loop\r\n        const { firstNode, nodesToRepeat, lastNode } = loopStrategy.splitBefore(openTag, closeTag);\r\n\r\n        // repeat (loop) the content\r\n        const repeatedNodes = this.repeat(nodesToRepeat, value.length);\r\n\r\n        // recursive compilation \r\n        // (this step can be optimized in the future if we'll keep track of the\r\n        // path to each token and use that to create new tokens instead of\r\n        // search through the text again)\r\n        const compiledNodes = await this.compile(repeatedNodes, data, context);\r\n\r\n        // merge back to the document\r\n        loopStrategy.mergeBack(compiledNodes, firstNode, lastNode);\r\n    }\r\n\r\n    private repeat(nodes: XmlNode[], times: number): XmlNode[][] {\r\n        if (!nodes.length || !times)\r\n            return [];\r\n\r\n        const allResults: XmlNode[][] = [];\r\n\r\n        for (let i = 0; i < times; i++) {\r\n            const curResult = nodes.map(node => XmlNode.cloneNode(node, true));\r\n            allResults.push(curResult);\r\n        }\r\n\r\n        return allResults;\r\n    }\r\n\r\n    private async compile(nodeGroups: XmlNode[][], data: ScopeData, context: TemplateContext): Promise<XmlNode[][]> {\r\n        const compiledNodeGroups: XmlNode[][] = [];\r\n\r\n        // compile each node group with it's relevant data\r\n        for (let i = 0; i < nodeGroups.length; i++) {\r\n\r\n            // create dummy root node\r\n            const curNodes = nodeGroups[i];\r\n            const dummyRootNode = XmlNode.createGeneralNode('dummyRootNode');\r\n            curNodes.forEach(node => XmlNode.appendChild(dummyRootNode, node));\r\n\r\n            // compile the new root\r\n            data.path.push(i);\r\n            await this.utilities.compiler.compile(dummyRootNode, data, context);\r\n            data.path.pop();\r\n\r\n            // disconnect from dummy root\r\n            const curResult: XmlNode[] = [];\r\n            while (dummyRootNode.childNodes && dummyRootNode.childNodes.length) {\r\n                const child = XmlNode.removeChild(dummyRootNode, 0);\r\n                curResult.push(child);\r\n            }\r\n            compiledNodeGroups.push(curResult);\r\n        }\r\n\r\n        return compiledNodeGroups;\r\n    }\r\n}","\r\nexport interface PluginContent {\r\n    _type: string;\r\n}\r\n\r\nexport const PluginContent = {\r\n    isPluginContent(content: any): content is PluginContent {\r\n        return !!content && typeof content._type === 'string';\r\n    }\r\n};","import { ScopeData, Tag } from '../compilation';\r\nimport { XmlNode } from '../xml';\r\nimport { RawXmlContent } from './rawXmlContent';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport class RawXmlPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = 'rawXml';\r\n\r\n    /**\r\n     * Replace the current <w:t> node with the specified xml markup.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData): void {\r\n\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(tag.xmlTextNode);\r\n\r\n        const value = data.getScopeData() as RawXmlContent;\r\n        if (value && typeof value.xml === 'string') {\r\n            const newNode = this.utilities.xmlParser.parse(value.xml);\r\n            XmlNode.insertBefore(newNode, wordTextNode);\r\n        }\r\n\r\n        XmlNode.remove(wordTextNode);\r\n    }\r\n}","import { ScopeData, Tag, TemplateCompiler, TemplateContext } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlParser } from '../xml';\r\n\r\nexport interface PluginUtilities {\r\n    compiler: TemplateCompiler;\r\n    docxParser: DocxParser;\r\n    xmlParser: XmlParser;\r\n}\r\n\r\n/* eslint-disable @typescript-eslint/member-ordering */\r\n\r\nexport abstract class TemplatePlugin {\r\n\r\n    /**\r\n     * The content type this plugin handles.\r\n     */\r\n    public abstract readonly contentType: string;\r\n\r\n    protected utilities: PluginUtilities;\r\n\r\n    /**\r\n     * Called by the TemplateHandler at runtime.\r\n     */\r\n    public setUtilities(utilities: PluginUtilities) {\r\n        this.utilities = utilities;\r\n    }\r\n\r\n    /**\r\n     * This method is called for each self-closing tag.\r\n     * It should implement the specific document manipulation required by the tag.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData, context: TemplateContext): void | Promise<void> {\r\n        // noop\r\n    }\r\n\r\n    /**\r\n     * This method is called for each container tag. It should implement the\r\n     * specific document manipulation required by the tag.\r\n     *\r\n     * @param tags All tags between the opening tag and closing tag (inclusive,\r\n     * i.e. tags[0] is the opening tag and the last item in the tags array is\r\n     * the closing tag).\r\n     */\r\n    public containerTagReplacements(tags: Tag[], data: ScopeData, context: TemplateContext): void | Promise<void> {\r\n        // noop\r\n    }\r\n}","import { ScopeData, Tag } from '../compilation';\r\nimport { DocxParser } from '../office';\r\nimport { XmlNode, XmlTextNode } from '../xml';\r\nimport { TemplatePlugin } from './templatePlugin';\r\n\r\nexport const TEXT_CONTENT_TYPE = 'text';\r\n\r\nexport class TextPlugin extends TemplatePlugin {\r\n\r\n    public readonly contentType = TEXT_CONTENT_TYPE;\r\n\r\n    /**\r\n     * Replace the node text content with the specified value.\r\n     */\r\n    public simpleTagReplacements(tag: Tag, data: ScopeData): void {\r\n\r\n        const value = data.getScopeData();\r\n        const stringValue = (value === null || value === undefined) ? '' : value.toString();\r\n        const lines = stringValue.split('\\n');\r\n\r\n        if (lines.length < 2) {\r\n            this.replaceSingleLine(tag.xmlTextNode, lines.length ? lines[0] : '');\r\n        } else {\r\n            this.replaceMultiLine(tag.xmlTextNode, lines);\r\n        }\r\n    }\r\n\r\n    private replaceSingleLine(textNode: XmlTextNode, text: string) {\r\n\r\n        // set text\r\n        textNode.textContent = text;\r\n\r\n        // make sure leading and trailing whitespace are preserved\r\n        const wordTextNode = this.utilities.docxParser.containingTextNode(textNode);\r\n        this.utilities.docxParser.setSpacePreserveAttribute(wordTextNode);\r\n    }\r\n\r\n    private replaceMultiLine(textNode: XmlTextNode, lines: string[]) {\r\n\r\n        const runNode = this.utilities.docxParser.containingRunNode(textNode);\r\n\r\n        // first line\r\n        textNode.textContent = lines[0];\r\n\r\n        // other lines\r\n        for (let i = 1; i < lines.length; i++) {\r\n\r\n            // add line break\r\n            const lineBreak = this.getLineBreak();\r\n            XmlNode.appendChild(runNode, lineBreak);\r\n\r\n            // add text\r\n            const lineNode = this.createWordTextNode(lines[i]);\r\n            XmlNode.appendChild(runNode, lineNode);\r\n        }\r\n    }\r\n\r\n    private getLineBreak(): XmlNode {\r\n        return XmlNode.createGeneralNode('w:br');\r\n    }\r\n\r\n    private createWordTextNode(text: string): XmlNode {\r\n        const wordTextNode = XmlNode.createGeneralNode(DocxParser.TEXT_NODE);\r\n\r\n        wordTextNode.attributes = {};\r\n        this.utilities.docxParser.setSpacePreserveAttribute(wordTextNode);\r\n\r\n        wordTextNode.childNodes = [\r\n            XmlNode.createTextNode(text)\r\n        ];\r\n\r\n        return wordTextNode;\r\n    }\r\n}","import { DelimiterSearcher, ScopeData, Tag, TagParser, TemplateCompiler, TemplateContext } from './compilation';\r\nimport { Delimiters } from './delimiters';\r\nimport { MalformedFileError } from './errors';\r\nimport { Docx, DocxParser } from './office';\r\nimport { TemplateHandlerOptions } from './templateHandlerOptions';\r\nimport { Binary } from './utils';\r\nimport { XmlNode, XmlParser } from './xml';\r\nimport { Zip } from './zip';\r\n\r\nexport class TemplateHandler {\r\n\r\n    /**\r\n     * Version number of the `easy-template-x` library.\r\n     */\r\n    public readonly version = (typeof EASY_VERSION !== 'undefined' ? EASY_VERSION : 'null');\r\n\r\n    private readonly xmlParser = new XmlParser();\r\n    private readonly docxParser: DocxParser;\r\n    private readonly compiler: TemplateCompiler;\r\n\r\n    private readonly options: TemplateHandlerOptions;\r\n\r\n    constructor(options?: TemplateHandlerOptions) {\r\n        this.options = new TemplateHandlerOptions(options);\r\n\r\n        //\r\n        // this is the library's composition root\r\n        //\r\n\r\n        this.docxParser = new DocxParser(this.xmlParser);\r\n\r\n        const delimiterSearcher = new DelimiterSearcher(this.docxParser);\r\n        delimiterSearcher.startDelimiter = this.options.delimiters.tagStart;\r\n        delimiterSearcher.endDelimiter = this.options.delimiters.tagEnd;\r\n        delimiterSearcher.maxXmlDepth = this.options.maxXmlDepth;\r\n\r\n        const tagParser = new TagParser(this.docxParser, this.options.delimiters as Delimiters);\r\n\r\n        this.compiler = new TemplateCompiler(\r\n            delimiterSearcher,\r\n            tagParser,\r\n            this.options.plugins,\r\n            this.options.defaultContentType,\r\n            this.options.containerContentType\r\n        );\r\n\r\n        this.options.plugins.forEach(plugin => {\r\n            plugin.setUtilities({\r\n                xmlParser: this.xmlParser,\r\n                docxParser: this.docxParser,\r\n                compiler: this.compiler\r\n            });\r\n        });\r\n    }\r\n\r\n    public async process<T extends Binary>(templateFile: T, data: any): Promise<T> {\r\n\r\n        // load the docx file\r\n        const docx = await this.loadDocx(templateFile);\r\n        const document = await docx.getDocument();\r\n\r\n        // process content (do replacements)        \r\n        const scopeData = new ScopeData(data);\r\n        const context: TemplateContext = {\r\n            docx\r\n        };\r\n        await this.compiler.compile(document, scopeData, context);\r\n\r\n        // export the result\r\n        return docx.export(templateFile.constructor as Constructor<T>);\r\n    }\r\n\r\n    public async parseTags(templateFile: Binary): Promise<Tag[]> {\r\n        const docx = await this.loadDocx(templateFile);\r\n        const document = await docx.getDocument();\r\n        return this.compiler.parseTags(document);\r\n    }\r\n\r\n    /**\r\n     * Get the text content of the main document file.\r\n     */\r\n    public async getText(docxFile: Binary): Promise<string> {\r\n        const docx = await this.loadDocx(docxFile);\r\n        const text = await docx.getDocumentText();\r\n        return text;\r\n    }\r\n\r\n    /**\r\n     * Get the xml tree of the main document file.\r\n     */\r\n    public async getXml(docxFile: Binary): Promise<XmlNode> {\r\n        const docx = await this.loadDocx(docxFile);\r\n        const document = await docx.getDocument();\r\n        return document;\r\n    }\r\n\r\n    //\r\n    // private methods\r\n    //\r\n\r\n    private async loadDocx(file: Binary): Promise<Docx> {\r\n\r\n        // load the zip file\r\n        let zip: Zip;\r\n        try {\r\n            zip = await Zip.load(file);\r\n        } catch {\r\n            throw new MalformedFileError('docx');\r\n        }\r\n\r\n        // load the docx file\r\n        const docx = this.docxParser.load(zip);\r\n        return docx;\r\n    }\r\n}","import { Delimiters } from './delimiters';\r\nimport { createDefaultPlugins, LOOP_CONTENT_TYPE, TemplatePlugin, TEXT_CONTENT_TYPE } from './plugins';\r\n\r\nexport class TemplateHandlerOptions {\r\n\r\n    public plugins?: TemplatePlugin[] = createDefaultPlugins();\r\n\r\n    public defaultContentType?= TEXT_CONTENT_TYPE;\r\n\r\n    public containerContentType?= LOOP_CONTENT_TYPE;\r\n\r\n    public delimiters?: Partial<Delimiters> = new Delimiters();\r\n\r\n    public maxXmlDepth?= 20;\r\n\r\n    constructor(initial?: Partial<TemplateHandlerOptions>) {\r\n        Object.assign(this, initial);\r\n\r\n        if (initial) {\r\n            this.delimiters = new Delimiters(initial.delimiters);\r\n        }\r\n\r\n        if (!this.plugins.length) {\r\n            throw new Error('Plugins list can not be empty');\r\n        }\r\n    }\r\n}","\r\nexport type ItemMapper<TIn, TOut = string> = (item: TIn, index: number) => TOut;\r\n\r\nexport function pushMany<T>(destArray: T[], items: T[]): void {\r\n    Array.prototype.push.apply(destArray, items);\r\n}\r\n\r\nexport function first<T>(array: T[]): T {\r\n    if (!array.length)\r\n        return undefined;\r\n    return array[0];\r\n}\r\n\r\nexport function last<T>(array: T[]): T {\r\n    if (!array.length)\r\n        return undefined;\r\n    return array[array.length - 1];\r\n}\r\n\r\nexport function toDictionary<TIn, TOut = TIn>(array: TIn[], keySelector: ItemMapper<TIn>, valueSelector?: ItemMapper<TIn, TOut>): IMap<TOut> {\r\n    if (!array.length)\r\n        return {};\r\n\r\n    const res: IMap<any> = {};\r\n    array.forEach((item, index) => {\r\n        const key = keySelector(item, index);\r\n        const value = (valueSelector ? valueSelector(item, index) : item);\r\n        if (res[key])\r\n            throw new Error(`Key '${key}' already exists in the dictionary.`);\r\n        res[key] = value;\r\n    });\r\n    return res;\r\n};","export class Base64 {\r\n\r\n    public static encode(str: string): string {\r\n        \r\n        // browser\r\n        if (typeof btoa !== 'undefined') \r\n            return btoa(str);\r\n\r\n        // node\r\n        // https://stackoverflow.com/questions/23097928/node-js-btoa-is-not-defined-error#38446960\r\n        return new Buffer(str, 'binary').toString('base64');\r\n    }\r\n}","import { Base64 } from './base64';\r\nimport { inheritsFrom } from './types';\r\n\r\nexport type Binary = Blob | Buffer | ArrayBuffer;\r\n\r\nexport const Binary = {\r\n\r\n    //\r\n    // type detection\r\n    //\r\n\r\n    isBlob(binary: any): binary is Blob {\r\n        return this.isBlobConstructor(binary.constructor);\r\n    },\r\n\r\n    isArrayBuffer(binary: any): binary is ArrayBuffer {\r\n        return this.isArrayBufferConstructor(binary.constructor);\r\n    },\r\n\r\n    isBuffer(binary: any): binary is Buffer {\r\n        return this.isBufferConstructor(binary.constructor);\r\n    },\r\n\r\n    isBlobConstructor(binaryType: Constructor<any>): binaryType is Constructor<Blob> {\r\n        return (typeof Blob !== 'undefined' && inheritsFrom(binaryType, Blob));\r\n    },\r\n\r\n    isArrayBufferConstructor(binaryType: Constructor<any>): binaryType is Constructor<ArrayBuffer> {\r\n        return (typeof ArrayBuffer !== 'undefined' && inheritsFrom(binaryType, ArrayBuffer));\r\n    },\r\n\r\n    isBufferConstructor(binaryType: Constructor<any>): binaryType is Constructor<Buffer> {\r\n        return (typeof Buffer !== 'undefined' && inheritsFrom(binaryType, Buffer));\r\n    },\r\n\r\n    //\r\n    // utilities\r\n    //\r\n\r\n    toBase64(binary: Binary): Promise<string> {\r\n\r\n        if (this.isBlob(binary)) {\r\n            return new Promise(resolve => {\r\n                const fileReader = new FileReader();\r\n                fileReader.onload = function () {\r\n                    const base64 = Base64.encode(this.result as string);\r\n                    resolve(base64);\r\n                };\r\n                fileReader.readAsBinaryString(binary);\r\n            });\r\n        }\r\n\r\n        if (this.isBuffer(binary)) {\r\n            return Promise.resolve(binary.toString('base64'));\r\n        }\r\n\r\n        if (this.isArrayBuffer(binary)) {\r\n            // https://stackoverflow.com/questions/9267899/arraybuffer-to-base64-encoded-string#42334410\r\n            const binaryStr = new Uint8Array(binary).reduce((str, byte) => str + String.fromCharCode(byte), '');\r\n            const base64 = Base64.encode(binaryStr);\r\n            return Promise.resolve(base64);\r\n        }\r\n\r\n        throw new Error(`Binary type '${(binary as any).constructor.name}' is not supported.`);\r\n    }\r\n};\r\n\r\n","export * from './array';\r\nexport * from './base64';\r\nexport * from './binary';\r\nexport * from './path';\r\nexport * from './sha1';\r\nexport * from './types';\r\n","export class Path {\r\n\r\n    public static getFilename(path: string): string {\r\n        const lastSlashIndex = path.lastIndexOf('/');\r\n        return path.substr(lastSlashIndex + 1);\r\n    }\r\n\r\n    public static getDirectory(path: string): string {\r\n        const lastSlashIndex = path.lastIndexOf('/');\r\n        return path.substring(0, lastSlashIndex);\r\n    }\r\n}","/**\r\n * Secure Hash Algorithm (SHA1)\r\n * \r\n * Taken from here: http://www.webtoolkit.info/javascript-sha1.html\r\n * \r\n * Recommended here: https://stackoverflow.com/questions/6122571/simple-non-secure-hash-function-for-javascript#6122732\r\n */\r\nexport function sha1(msg: string) {\r\n\r\n    msg = utf8Encode(msg);\r\n    const msgLength = msg.length;\r\n\r\n    let i, j;\r\n\r\n    const wordArray = [];\r\n    for (i = 0; i < msgLength - 3; i += 4) {\r\n        j = msg.charCodeAt(i) << 24 | msg.charCodeAt(i + 1) << 16 |\r\n            msg.charCodeAt(i + 2) << 8 | msg.charCodeAt(i + 3);\r\n        wordArray.push(j);\r\n    }\r\n\r\n    switch (msgLength % 4) {\r\n        case 0:\r\n            i = 0x080000000;\r\n            break;\r\n        case 1:\r\n            i = msg.charCodeAt(msgLength - 1) << 24 | 0x0800000;\r\n            break;\r\n        case 2:\r\n            i = msg.charCodeAt(msgLength - 2) << 24 | msg.charCodeAt(msgLength - 1) << 16 | 0x08000;\r\n            break;\r\n        case 3:\r\n            i = msg.charCodeAt(msgLength - 3) << 24 | msg.charCodeAt(msgLength - 2) << 16 | msg.charCodeAt(msgLength - 1) << 8 | 0x80;\r\n            break;\r\n    }\r\n    wordArray.push(i);\r\n\r\n    while ((wordArray.length % 16) != 14) {\r\n        wordArray.push(0);\r\n    }\r\n\r\n    wordArray.push(msgLength >>> 29);\r\n    wordArray.push((msgLength << 3) & 0x0ffffffff);\r\n\r\n    const w = new Array(80);\r\n    let H0 = 0x67452301;\r\n    let H1 = 0xEFCDAB89;\r\n    let H2 = 0x98BADCFE;\r\n    let H3 = 0x10325476;\r\n    let H4 = 0xC3D2E1F0;\r\n    let A, B, C, D, E;\r\n    let temp;\r\n    for (let blockStart = 0; blockStart < wordArray.length; blockStart += 16) {\r\n\r\n        for (i = 0; i < 16; i++) {\r\n            w[i] = wordArray[blockStart + i];\r\n        }\r\n        for (i = 16; i <= 79; i++) {\r\n            w[i] = rotateLeft(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);\r\n        }\r\n        A = H0;\r\n        B = H1;\r\n        C = H2;\r\n        D = H3;\r\n        E = H4;\r\n        for (i = 0; i <= 19; i++) {\r\n            temp = (rotateLeft(A, 5) + ((B & C) | (~B & D)) + E + w[i] + 0x5A827999) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 20; i <= 39; i++) {\r\n            temp = (rotateLeft(A, 5) + (B ^ C ^ D) + E + w[i] + 0x6ED9EBA1) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 40; i <= 59; i++) {\r\n            temp = (rotateLeft(A, 5) + ((B & C) | (B & D) | (C & D)) + E + w[i] + 0x8F1BBCDC) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        for (i = 60; i <= 79; i++) {\r\n            temp = (rotateLeft(A, 5) + (B ^ C ^ D) + E + w[i] + 0xCA62C1D6) & 0x0ffffffff;\r\n            E = D;\r\n            D = C;\r\n            C = rotateLeft(B, 30);\r\n            B = A;\r\n            A = temp;\r\n        }\r\n        H0 = (H0 + A) & 0x0ffffffff;\r\n        H1 = (H1 + B) & 0x0ffffffff;\r\n        H2 = (H2 + C) & 0x0ffffffff;\r\n        H3 = (H3 + D) & 0x0ffffffff;\r\n        H4 = (H4 + E) & 0x0ffffffff;\r\n    }\r\n    temp = cvtHex(H0) + cvtHex(H1) + cvtHex(H2) + cvtHex(H3) + cvtHex(H4);\r\n    return temp.toLowerCase();\r\n}\r\n\r\nfunction rotateLeft(n: any, s: any) {\r\n    const t4 = (n << s) | (n >>> (32 - s));\r\n    return t4;\r\n}\r\n\r\nfunction cvtHex(val: any) {\r\n    let str = \"\";\r\n    for (let i = 7; i >= 0; i--) {\r\n        const v = (val >>> (i * 4)) & 0x0f;\r\n        str += v.toString(16);\r\n    }\r\n    return str;\r\n}\r\n\r\nfunction utf8Encode(str: string) {\r\n    str = str.replace(/\\r\\n/g, \"\\n\");\r\n    let utfStr = \"\";\r\n    for (let n = 0; n < str.length; n++) {\r\n        const c = str.charCodeAt(n);\r\n        if (c < 128) {\r\n            utfStr += String.fromCharCode(c);\r\n\r\n        } else if ((c > 127) && (c < 2048)) {\r\n            utfStr += String.fromCharCode((c >> 6) | 192);\r\n            utfStr += String.fromCharCode((c & 63) | 128);\r\n\r\n        } else {\r\n            utfStr += String.fromCharCode((c >> 12) | 224);\r\n            utfStr += String.fromCharCode(((c >> 6) & 63) | 128);\r\n            utfStr += String.fromCharCode((c & 63) | 128);\r\n        }\r\n    }\r\n    return utfStr;\r\n}\r\n","\r\nexport function inheritsFrom(derived: Constructor<any>, base: Constructor<any>): boolean {\r\n    // https://stackoverflow.com/questions/14486110/how-to-check-if-a-javascript-class-inherits-another-without-creating-an-obj\r\n    return derived === base || derived.prototype instanceof base;\r\n}\r\n\r\nexport function isPromiseLike<T>(candidate: any): candidate is PromiseLike<T> {\r\n    return !!candidate && typeof candidate === 'object' && typeof candidate.then === 'function';\r\n}","export * from './xmlDepthTracker';\r\nexport * from './xmlNode';\r\nexport * from './xmlParser';\r\n","import { MaxXmlDepthError } from '../errors';\r\n\r\nexport class XmlDepthTracker {\r\n    \r\n    private depth = 0;\r\n\r\n    constructor(private readonly maxDepth: number) { }\r\n\r\n    public increment(): void {\r\n        this.depth++;\r\n        if (this.depth > this.maxDepth) {\r\n            throw new MaxXmlDepthError(this.maxDepth);\r\n        }\r\n    }\r\n\r\n    public decrement(): void {\r\n        this.depth--;\r\n    }\r\n}","import { MissingArgumentError } from '../errors';\r\nimport { last } from '../utils';\r\n\r\nexport enum XmlNodeType {\r\n    Text = \"Text\",\r\n    General = \"General\"\r\n}\r\n\r\nexport type XmlNode = XmlTextNode | XmlGeneralNode;\r\n\r\nexport interface XmlNodeBase {\r\n    nodeType: XmlNodeType;\r\n    nodeName: string;\r\n    parentNode?: XmlNode;\r\n    childNodes?: XmlNode[];\r\n    nextSibling?: XmlNode;\r\n}\r\n\r\nexport const TEXT_NODE_NAME = '#text'; // see: https://developer.mozilla.org/en-US/docs/Web/API/Node/nodeName\r\n\r\nexport interface XmlTextNode extends XmlNodeBase {\r\n    nodeType: XmlNodeType.Text;\r\n    nodeName: typeof TEXT_NODE_NAME;\r\n    textContent: string;\r\n}\r\n\r\nexport interface XmlGeneralNode extends XmlNodeBase {\r\n    nodeType: XmlNodeType.General;\r\n    attributes?: IMap<string>;\r\n}\r\n\r\nexport const XmlNode = {\r\n\r\n    //\r\n    // factories\r\n    //\r\n\r\n    createTextNode(text?: string): XmlTextNode {\r\n        return {\r\n            nodeType: XmlNodeType.Text,\r\n            nodeName: TEXT_NODE_NAME,\r\n            textContent: text\r\n        };\r\n    },\r\n\r\n    createGeneralNode(name: string): XmlGeneralNode {\r\n        return {\r\n            nodeType: XmlNodeType.General,\r\n            nodeName: name\r\n        };\r\n    },\r\n\r\n    //\r\n    // serialization\r\n    //\r\n\r\n    /**\r\n     * Encode string to make it safe to use inside xml tags.\r\n     * \r\n     * https://stackoverflow.com/questions/7918868/how-to-escape-xml-entities-in-javascript\r\n     */\r\n    encodeValue(str: string): string {\r\n        if (str === null || str === undefined)\r\n            throw new MissingArgumentError(nameof(str));\r\n        if (typeof str !== 'string')\r\n            throw new TypeError(`Expected a string, got '${(str as any).constructor.name}'.`);\r\n\r\n        return str.replace(/[<>&'\"]/g, c => {\r\n            switch (c) {\r\n                case '<': return '&lt;';\r\n                case '>': return '&gt;';\r\n                case '&': return '&amp;';\r\n                case '\\'': return '&apos;';\r\n                case '\"': return '&quot;';\r\n            }\r\n            return '';\r\n        });\r\n    },\r\n\r\n    serialize(node: XmlNode): string {\r\n        if (this.isTextNode(node))\r\n            return this.encodeValue(node.textContent || '');\r\n\r\n        // attributes\r\n        let attributes = '';\r\n        if (node.attributes) {\r\n            const attributeNames = Object.keys(node.attributes);\r\n            if (attributeNames.length) {\r\n                attributes = ' ' + attributeNames\r\n                    .map(name => `${name}=\"${node.attributes[name]}\"`)\r\n                    .join(' ');\r\n            }\r\n        }\r\n\r\n        // open tag\r\n        const hasChildren = (node.childNodes || []).length > 0;\r\n        const suffix = hasChildren ? '' : '/';\r\n        const openTag = `<${node.nodeName}${attributes}${suffix}>`;\r\n\r\n        let xml: string;\r\n\r\n        if (hasChildren) {\r\n\r\n            // child nodes\r\n            const childrenXml = node.childNodes\r\n                .map(child => this.serialize(child))\r\n                .join('');\r\n\r\n            // close tag\r\n            const closeTag = `</${node.nodeName}>`;\r\n\r\n            xml = openTag + childrenXml + closeTag;\r\n        } else {\r\n            xml = openTag;\r\n        }\r\n\r\n        return xml;\r\n    },\r\n\r\n    /**\r\n     * The conversion is always deep.\r\n     */\r\n    fromDomNode(domNode: Node): XmlNode {\r\n        let xmlNode: XmlNode;\r\n\r\n        // basic properties\r\n        if (domNode.nodeType === domNode.TEXT_NODE) {\r\n\r\n            xmlNode = this.createTextNode(domNode.textContent);\r\n\r\n        } else {\r\n\r\n            xmlNode = this.createGeneralNode(domNode.nodeName);\r\n\r\n            // attributes\r\n            if (domNode.nodeType === domNode.ELEMENT_NODE) {\r\n                const attributes = (domNode as Element).attributes;\r\n                if (attributes) {\r\n                    (xmlNode as XmlGeneralNode).attributes = {};\r\n                    for (let i = 0; i < attributes.length; i++) {\r\n                        const curAttribute = attributes.item(i);\r\n                        (xmlNode as XmlGeneralNode).attributes[curAttribute.name] = curAttribute.value;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // children\r\n        if (domNode.childNodes) {\r\n            xmlNode.childNodes = [];\r\n            let prevChild: XmlNode;\r\n            for (let i = 0; i < domNode.childNodes.length; i++) {\r\n\r\n                // clone child\r\n                const domChild = domNode.childNodes.item(i);\r\n                const curChild = this.fromDomNode(domChild);\r\n\r\n                // set references                \r\n                xmlNode.childNodes.push(curChild);\r\n                curChild.parentNode = xmlNode;\r\n                if (prevChild) {\r\n                    prevChild.nextSibling = curChild;\r\n                }\r\n                prevChild = curChild;\r\n            }\r\n        }\r\n\r\n        return xmlNode as XmlNode;\r\n    },\r\n\r\n    //\r\n    // core functions\r\n    //\r\n\r\n    isTextNode(node: XmlNode): node is XmlTextNode {\r\n        if (node.nodeType === XmlNodeType.Text || node.nodeName === TEXT_NODE_NAME) {\r\n            if (!(node.nodeType === XmlNodeType.Text && node.nodeName === TEXT_NODE_NAME)) {\r\n                throw new Error(`Invalid text node. Type: '${node.nodeType}', Name: '${node.nodeName}'.`);\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    },\r\n\r\n    cloneNode<T extends XmlNode>(node: T, deep: boolean): T {\r\n        if (!node)\r\n            throw new MissingArgumentError(nameof(node));\r\n\r\n        if (!deep) {\r\n            const clone = Object.assign({}, node);\r\n            clone.parentNode = null;\r\n            clone.childNodes = (node.childNodes ? [] : null);\r\n            clone.nextSibling = null;\r\n            return clone;\r\n        } else {\r\n            const clone = cloneNodeDeep(node);\r\n            clone.parentNode = null;\r\n            return clone;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Insert the node as a new sibling, before the original node.\r\n     *\r\n     * * **Note**: It is more efficient to use the insertChild function if you\r\n     *   already know the relevant index.\r\n     */\r\n    insertBefore(newNode: XmlNode, referenceNode: XmlNode): void {\r\n        if (!newNode)\r\n            throw new MissingArgumentError(nameof(newNode));\r\n        if (!referenceNode)\r\n            throw new MissingArgumentError(nameof(referenceNode));\r\n\r\n        if (!referenceNode.parentNode)\r\n            throw new Error(`'${nameof(referenceNode)}' has no parent`);\r\n\r\n        const childNodes = referenceNode.parentNode.childNodes;\r\n        const beforeNodeIndex = childNodes.indexOf(referenceNode);\r\n        XmlNode.insertChild(referenceNode.parentNode, newNode, beforeNodeIndex);\r\n    },\r\n\r\n    /**\r\n     * Insert the node as a new sibling, after the original node.\r\n     *\r\n     * * **Note**: It is more efficient to use the insertChild function if you\r\n     *   already know the relevant index.\r\n     */\r\n    insertAfter(newNode: XmlNode, referenceNode: XmlNode): void {\r\n        if (!newNode)\r\n            throw new MissingArgumentError(nameof(newNode));\r\n        if (!referenceNode)\r\n            throw new MissingArgumentError(nameof(referenceNode));\r\n\r\n        if (!referenceNode.parentNode)\r\n            throw new Error(`'${nameof(referenceNode)}' has no parent`);\r\n\r\n        const childNodes = referenceNode.parentNode.childNodes;\r\n        const referenceNodeIndex = childNodes.indexOf(referenceNode);\r\n        XmlNode.insertChild(referenceNode.parentNode, newNode, referenceNodeIndex + 1);\r\n    },\r\n\r\n    insertChild(parent: XmlNode, child: XmlNode, childIndex: number): void {\r\n        if (!parent)\r\n            throw new MissingArgumentError(nameof(parent));\r\n        if (XmlNode.isTextNode(parent))\r\n            throw new Error('Appending children to text nodes is forbidden');\r\n        if (!child)\r\n            throw new MissingArgumentError(nameof(child));\r\n\r\n        if (!parent.childNodes)\r\n            parent.childNodes = [];\r\n\r\n        // revert to append\r\n        if (childIndex === parent.childNodes.length) {\r\n            XmlNode.appendChild(parent, child);\r\n            return;\r\n        }\r\n\r\n        if (childIndex > parent.childNodes.length)\r\n            throw new RangeError(`Child index ${childIndex} is out of range. Parent has only ${parent.childNodes.length} child nodes.`);\r\n\r\n        // update references\r\n        child.parentNode = parent;\r\n\r\n        const childAfter = parent.childNodes[childIndex];\r\n        child.nextSibling = childAfter;\r\n\r\n        if (childIndex > 0) {\r\n            const childBefore = parent.childNodes[childIndex - 1];\r\n            childBefore.nextSibling = child;\r\n        }\r\n\r\n        // append\r\n        parent.childNodes.splice(childIndex, 0, child);\r\n    },\r\n\r\n    appendChild(parent: XmlNode, child: XmlNode): void {\r\n        if (!parent)\r\n            throw new MissingArgumentError(nameof(parent));\r\n        if (XmlNode.isTextNode(parent))\r\n            throw new Error('Appending children to text nodes is forbidden');\r\n        if (!child)\r\n            throw new MissingArgumentError(nameof(child));\r\n\r\n        if (!parent.childNodes)\r\n            parent.childNodes = [];\r\n\r\n        // update references\r\n        if (parent.childNodes.length) {\r\n            const currentLastChild = parent.childNodes[parent.childNodes.length - 1];\r\n            currentLastChild.nextSibling = child;\r\n        }\r\n        child.nextSibling = null;\r\n        child.parentNode = parent;\r\n\r\n        // append\r\n        parent.childNodes.push(child);\r\n    },\r\n\r\n    /**\r\n     * Removes the node from it's parent.\r\n     * \r\n     * * **Note**: It is more efficient to call removeChild(parent, childIndex).\r\n     */\r\n    remove(node: XmlNode): void {\r\n        if (!node)\r\n            throw new MissingArgumentError(nameof(node));\r\n\r\n        if (!node.parentNode)\r\n            throw new Error('Node has no parent');\r\n\r\n        removeChild(node.parentNode, node);\r\n    },\r\n\r\n    removeChild,\r\n\r\n    //\r\n    // utility functions\r\n    //    \r\n\r\n    /**\r\n     * Gets the last direct child text node if it exists. Otherwise creates a\r\n     * new text node, appends it to 'node' and return the newly created text\r\n     * node.\r\n     *\r\n     * The function also makes sure the returned text node has a valid string\r\n     * value.\r\n     */\r\n    lastTextChild(node: XmlNode): XmlTextNode {\r\n        if (XmlNode.isTextNode(node)) {\r\n            return node;\r\n        }\r\n\r\n        // existing text nodes\r\n        if (node.childNodes) {\r\n            const allTextNodes = node.childNodes.filter(child => XmlNode.isTextNode(child)) as XmlTextNode[];\r\n            if (allTextNodes.length) {\r\n                const lastTextNode = last(allTextNodes);\r\n                if (!lastTextNode.textContent)\r\n                    lastTextNode.textContent = '';\r\n                return lastTextNode;\r\n            }\r\n        }\r\n\r\n        // create new text node\r\n        const newTextNode: XmlTextNode = {\r\n            nodeType: XmlNodeType.Text,\r\n            nodeName: TEXT_NODE_NAME,\r\n            textContent: ''\r\n        };\r\n\r\n        XmlNode.appendChild(node, newTextNode);\r\n        return newTextNode;\r\n    },\r\n\r\n    /**\r\n     * Remove sibling nodes between 'from' and 'to' excluding both.\r\n     * Return the removed nodes.\r\n     */\r\n    removeSiblings(from: XmlNode, to: XmlNode): XmlNode[] {\r\n        if (from === to)\r\n            return [];\r\n\r\n        const removed: XmlNode[] = [];\r\n        let lastRemoved: XmlNode;\r\n        from = from.nextSibling;\r\n        while (from !== to) {\r\n            const removeMe = from;\r\n            from = from.nextSibling;\r\n\r\n            XmlNode.remove(removeMe);\r\n            removed.push(removeMe);\r\n\r\n            if (lastRemoved)\r\n                lastRemoved.nextSibling = removeMe;\r\n            lastRemoved = removeMe;\r\n        }\r\n\r\n        return removed;\r\n    },\r\n\r\n    /**\r\n     * Split the original node into two sibling nodes.\r\n     * Returns both nodes.\r\n     *\r\n     * @param root The node to split\r\n     * @param markerNode The node that marks the split position.      \r\n     */\r\n    splitByChild(root: XmlNode, markerNode: XmlNode, removeMarkerNode: boolean): [XmlNode, XmlNode] {\r\n\r\n        // find the split path\r\n        const path = getDescendantPath(root, markerNode);\r\n\r\n        // split\r\n        const split = XmlNode.cloneNode(root, false);\r\n        const childIndex = path[0] + 1;\r\n        while (childIndex < root.childNodes.length) {\r\n            const curChild = root.childNodes[childIndex];\r\n            XmlNode.remove(curChild);\r\n            XmlNode.appendChild(split, curChild);\r\n        }\r\n\r\n        if (root.parentNode) {\r\n            XmlNode.insertAfter(split, root);\r\n        }\r\n\r\n        // remove marker node\r\n        if (removeMarkerNode && root.childNodes.length) {\r\n            XmlNode.removeChild(root, root.childNodes.length - 1);\r\n        }\r\n\r\n        return [root, split];\r\n    },\r\n\r\n    findParent(node: XmlNode, predicate: (node: XmlNode) => boolean): XmlNode {\r\n        if (!node)\r\n            return null;\r\n\r\n        while (node.parentNode) {\r\n\r\n            if (predicate(node))\r\n                return node;\r\n\r\n            node = node.parentNode;\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    findParentByName(node: XmlNode, nodeName: string): XmlNode {\r\n        return XmlNode.findParent(node, n => n.nodeName === nodeName);\r\n    },\r\n\r\n    findChildByName(node: XmlNode, childName: string): XmlNode {\r\n        if (!node)\r\n            return null;\r\n        return (node.childNodes || []).find(child => child.nodeName === childName);\r\n    },\r\n\r\n    /**\r\n     * Returns all siblings between 'firstNode' and 'lastNode' inclusive.\r\n     */\r\n    siblingsInRange(firstNode: XmlNode, lastNode: XmlNode): XmlNode[] {\r\n        if (!firstNode)\r\n            throw new MissingArgumentError(nameof(firstNode));\r\n        if (!lastNode)\r\n            throw new MissingArgumentError(nameof(lastNode));\r\n\r\n        const range: XmlNode[] = [];\r\n        let curNode = firstNode;\r\n        while (curNode && curNode !== lastNode) {\r\n            range.push(curNode);\r\n            curNode = curNode.nextSibling;\r\n        }\r\n\r\n        if (!curNode)\r\n            throw new Error('Nodes are not siblings.');\r\n\r\n        range.push(lastNode);\r\n        return range;\r\n    },\r\n\r\n    /**\r\n     * Recursively removes text nodes leaving only \"general nodes\".\r\n     */\r\n    removeEmptyTextNodes(node: XmlNode): void {\r\n        recursiveRemoveEmptyTextNodes(node);\r\n    },\r\n};\r\n\r\n//\r\n// overloaded functions\r\n//\r\n\r\n/**\r\n * Remove a child node from it's parent. Returns the removed child.\r\n * \r\n * * **Note:** Prefer calling with explicit index.\r\n */\r\nfunction removeChild(parent: XmlNode, child: XmlNode): XmlNode;\r\n/**\r\n * Remove a child node from it's parent. Returns the removed child.\r\n */\r\nfunction removeChild(parent: XmlNode, childIndex: number): XmlNode;\r\nfunction removeChild(parent: XmlNode, childOrIndex: XmlNode | number): XmlNode {\r\n    if (!parent)\r\n        throw new MissingArgumentError(nameof(parent));\r\n    if (childOrIndex === null || childOrIndex === undefined)\r\n        throw new MissingArgumentError(nameof(childOrIndex));\r\n\r\n    if (!parent.childNodes || !parent.childNodes.length)\r\n        throw new Error('Parent node has node children');\r\n\r\n    // get child index\r\n    let childIndex: number;\r\n    if (typeof childOrIndex === 'number') {\r\n        childIndex = childOrIndex;\r\n    } else {\r\n        childIndex = parent.childNodes.indexOf(childOrIndex);\r\n        if (childIndex === -1)\r\n            throw new Error('Specified child node is not a child of the specified parent');\r\n    }\r\n\r\n    if (childIndex >= parent.childNodes.length)\r\n        throw new RangeError(`Child index ${childIndex} is out of range. Parent has only ${parent.childNodes.length} child nodes.`);\r\n\r\n    // update references\r\n    const child = parent.childNodes[childIndex];\r\n    if (childIndex > 0) {\r\n        const beforeChild = parent.childNodes[childIndex - 1];\r\n        beforeChild.nextSibling = child.nextSibling;\r\n    }\r\n    child.parentNode = null;\r\n    child.nextSibling = null;\r\n\r\n    // remove and return\r\n    return parent.childNodes.splice(childIndex, 1)[0];\r\n}\r\n\r\n//\r\n// private functions\r\n//\r\n\r\nfunction cloneNodeDeep<T extends XmlNode>(original: T): T {\r\n\r\n    const clone: XmlNode = ({} as any);\r\n\r\n    // basic properties\r\n    clone.nodeType = original.nodeType;\r\n    clone.nodeName = original.nodeName;\r\n    if (XmlNode.isTextNode(original)) {\r\n        (clone as XmlTextNode).textContent = original.textContent;\r\n    } else {\r\n        const attributes = (original as XmlGeneralNode).attributes;\r\n        if (attributes) {\r\n            (clone as XmlGeneralNode).attributes = Object.assign({}, attributes);\r\n        }\r\n    }\r\n\r\n    // children\r\n    if (original.childNodes) {\r\n        clone.childNodes = [];\r\n        let prevChildClone: XmlNode;\r\n        for (const child of original.childNodes) {\r\n\r\n            // clone child\r\n            const childClone = cloneNodeDeep(child);\r\n\r\n            // set references                \r\n            clone.childNodes.push(childClone);\r\n            childClone.parentNode = clone;\r\n            if (prevChildClone) {\r\n                prevChildClone.nextSibling = childClone;\r\n            }\r\n            prevChildClone = childClone;\r\n        }\r\n    }\r\n\r\n    return clone as T;\r\n}\r\n\r\nfunction getDescendantPath(root: XmlNode, descendant: XmlNode): number[] {\r\n    const path: number[] = [];\r\n\r\n    let node = descendant;\r\n    while (node !== root) {\r\n        const parent = node.parentNode;\r\n        if (!parent)\r\n            throw new Error(`Argument ${nameof(descendant)} is not a descendant of ${nameof(root)}`);\r\n\r\n        const curChildIndex = parent.childNodes.indexOf(node);\r\n        path.push(curChildIndex);\r\n\r\n        node = parent;\r\n    }\r\n\r\n    return path.reverse();\r\n}\r\n\r\nfunction recursiveRemoveEmptyTextNodes(node: XmlNode): XmlNode {\r\n\r\n    if (!node.childNodes)\r\n        return node;\r\n\r\n    const oldChildren = node.childNodes;\r\n    node.childNodes = [];\r\n    for (const child of oldChildren) {\r\n        if (XmlNode.isTextNode(child)) {\r\n\r\n            // https://stackoverflow.com/questions/1921688/filtering-whitespace-only-strings-in-javascript#1921694\r\n            if (child.textContent && child.textContent.match(/\\S/)) {\r\n                node.childNodes.push(child);\r\n            }\r\n            \r\n            continue;\r\n        }\r\n        const strippedChild = recursiveRemoveEmptyTextNodes(child);\r\n        node.childNodes.push(strippedChild);\r\n    }\r\n\r\n    return node;\r\n}","import * as xmldom from 'xmldom';\r\nimport { MissingArgumentError } from '../errors';\r\nimport { XmlNode } from './xmlNode';\r\n\r\nexport class XmlParser {\r\n\r\n    private static xmlHeader = '<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>';\r\n    /**\r\n     * We always use the DOMParser from 'xmldom', even in the browser since it\r\n     * handles xml namespaces more forgivingly (required mainly by the\r\n     * RawXmlPlugin).\r\n     */\r\n    private static readonly parser = new xmldom.DOMParser();\r\n\r\n    public parse(str: string): XmlNode {\r\n        const doc = this.domParse(str);\r\n        return XmlNode.fromDomNode(doc.documentElement);\r\n    }\r\n\r\n    public domParse(str: string): Document {\r\n        if (str === null || str === undefined)\r\n            throw new MissingArgumentError(nameof(str));\r\n\r\n        return XmlParser.parser.parseFromString(str, \"text/xml\");\r\n    }\r\n\r\n    public serialize(xmlNode: XmlNode): string {\r\n        return XmlParser.xmlHeader + XmlNode.serialize(xmlNode);\r\n    }    \r\n}\r\n","export * from './zip';\r\nexport * from './zipObject';\r\n","import * as JSZip from 'jszip';\r\nimport { MissingArgumentError } from '../errors';\r\nimport { Binary } from '../utils';\r\n\r\nexport class JsZipHelper {\r\n\r\n    public static toJsZipOutputType(binary: Binary): JSZip.OutputType;\r\n    public static toJsZipOutputType(binaryType: Constructor<Binary>): JSZip.OutputType;\r\n    public static toJsZipOutputType(binaryOrType: Binary | Constructor<Binary>): JSZip.OutputType {\r\n\r\n        if (!binaryOrType)\r\n            throw new MissingArgumentError(nameof(binaryOrType));\r\n\r\n        let binaryType: Constructor<Binary>;\r\n        if (typeof binaryOrType === 'function') {\r\n            binaryType = binaryOrType as Constructor<Binary>;\r\n        } else {\r\n            binaryType = binaryOrType.constructor as Constructor<Binary>;\r\n        }\r\n\r\n        if (Binary.isBlobConstructor(binaryType))\r\n            return 'blob';\r\n        if (Binary.isArrayBufferConstructor(binaryType))\r\n            return 'arraybuffer';\r\n        if (Binary.isBufferConstructor(binaryType))\r\n            return 'nodebuffer';\r\n\r\n        throw new Error(`Binary type '${binaryType.name}' is not supported.`);\r\n    };\r\n}","import * as JSZip from 'jszip';\r\nimport { Binary } from '../utils';\r\nimport { JsZipHelper } from './jsZipHelper';\r\nimport { ZipObject } from './zipObject';\r\n\r\nexport class Zip {\r\n\r\n    public static async load(file: Binary): Promise<Zip> {\r\n        const zip = await JSZip.loadAsync(file);\r\n        return new Zip(zip);\r\n    }\r\n\r\n    private constructor(private readonly zip: JSZip) {\r\n    }\r\n\r\n    public getFile(path: string): ZipObject {\r\n        return new ZipObject(this.zip.files[path]);\r\n    }\r\n\r\n    public setFile(path: string, content: string | Binary): void {\r\n        this.zip.file(path, content);\r\n    }\r\n\r\n    public isFileExist(path: string): boolean {\r\n        return !!this.zip.files[path];\r\n    }\r\n\r\n    public listFiles(): string[] {\r\n        return Object.keys(this.zip.files);\r\n    }\r\n\r\n    public async export<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        const zipOutputType: JSZip.OutputType = JsZipHelper.toJsZipOutputType(outputType);\r\n        const output = await this.zip.generateAsync({\r\n            type: zipOutputType,\r\n            compression: \"DEFLATE\",\r\n            compressionOptions: {\r\n                level: 6 // between 1 (best speed) and 9 (best compression)\r\n            }\r\n        });\r\n        return output as T;\r\n    }\r\n}","import * as JSZip from 'jszip';\r\nimport { Binary } from '../utils';\r\nimport { JsZipHelper } from './jsZipHelper';\r\n\r\nexport class ZipObject {\r\n\r\n    public get name(): string {\r\n        return this.zipObject.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this.zipObject.name = value;\r\n    }\r\n\r\n    public get isDirectory(): boolean {\r\n        return this.zipObject.dir;\r\n    }\r\n\r\n    constructor(private readonly zipObject: JSZip.JSZipObject) { }\r\n\r\n    public getContentText(): Promise<string> {\r\n        return this.zipObject.async('text');\r\n    }\r\n    \r\n    public getContentBase64(): Promise<string> {\r\n        return this.zipObject.async('binarystring');\r\n    }\r\n\r\n    public getContentBinary<T extends Binary>(outputType: Constructor<T>): Promise<T> {\r\n        const zipOutputType: JSZip.OutputType = JsZipHelper.toJsZipOutputType(outputType);\r\n        return this.zipObject.async(zipOutputType) as any;\r\n    }\r\n}","module.exports = require(\"jszip\");","module.exports = require(\"lodash.get\");","module.exports = require(\"xmldom\");"],"sourceRoot":""}